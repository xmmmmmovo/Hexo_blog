<!DOCTYPE html><html><head><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?9f5831169aaf76f2ba63765d546a2ef6"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script><meta charset="utf-8"><title>【译】探索Rust中的动态分发 - 异国迷宫的十字路口</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="rust"><meta name="description" content="关于Rust中trait object和虚表"><meta property="og:type" content="article"><meta property="og:title" content="【译】探索Rust中的动态分发"><meta property="og:url" content="http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/index.html"><meta property="og:site_name" content="异国迷宫的十字路口"><meta property="og:description" content="关于Rust中trait object和虚表"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_layout-2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_layout_cpp.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_and_clone_cpp-1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_clone_rust_candidate_1-1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/clone_mammal_rust-1.png"><meta property="article:published_time" content="2021-02-07T07:43:03.000Z"><meta property="article:modified_time" content="2021-03-28T17:14:07.504Z"><meta property="article:author" content="xmmmmmovo"><meta property="article:tag" content="rust"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_layout-2.png"><link rel="alternate" type="application/atom+xml" title="异国迷宫的十字路口" href="/atom.xml"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/css/style.css"><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(/img/brand.png)"><div class="brand"> <a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cn.gravatar.com/avatar/bbca35300364b268662a56b05d130341s"></a><hgroup class="introduce"><h5 class="nickname">xmmmmmovo</h5> <a href="mailto:lolicoin@foxmail.com" title="lolicoin@foxmail.com" class="mail">lolicoin@foxmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-user"></i> 关于</a></li><li class="waves-block waves-effect"><a href="/links"><i class="icon icon-lg icon-external-link"></i> 友链</a></li><li class="waves-block waves-effect"><a href="https://github.com/xmmmmmovo" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="https://travellings.now.sh/" target="_blank"><i class="icon icon-lg icon-subway"></i> 开往~新世界~</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">【译】探索Rust中的动态分发</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">【译】探索Rust中的动态分发</h1><h5 class="subtitle"> <time datetime="2021-02-07T07:43:03.000Z" itemprop="datePublished" class="page-time">2021-02-07</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/translation/">translation</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap post-toc-shrink" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rust中的虚表"><span class="post-toc-number">1.</span> <span class="post-toc-text">Rust中的虚表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多约束trait-object"><span class="post-toc-number">2.</span> <span class="post-toc-text">多约束trait object</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结论"><span class="post-toc-number">3.</span> <span class="post-toc-text">结论</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最终代码-自己实现"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">最终代码(自己实现)</span></a></li></ol></li></ol></nav></aside><article id="post-translation-Exploring-Dynamic-Dispatch-in-Rust" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">【译】探索Rust中的动态分发</h1><div class="post-meta"><time class="post-time" title="2021-02-07 15:43:03" datetime="2021-02-07T07:43:03.000Z" itemprop="datePublished"><i class="icon icon-calendar"></i> 2021-02-07</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/translation/">translation</a></li></ul><span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none"><i class="icon icon-eye" style="padding:0 .3em"></i><span id="busuanzi_value_page_pv"></span></span></div><div class="post-content" id="post-content" itemprop="postContent"><p>关于Rust中trait object和虚表<a id="more"></a></p><blockquote><p>原文链接：<a href="https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/" target="_blank" rel="noopener">Exploring Dynamic Dispatch in Rust</a></p><p>时间：2017-3-07</p><p>本文发表时间在2018edtion之前，观点可能不代表最新版本Rust（比如现在有了dyn关键词）</p></blockquote><p>首先我要说的是我是Rust的新手（尽管到目前为止我很喜欢这门语言！），因此，如果我出现了技术错误，请告知我，我会试着纠正。所以，开始吧。<br>在下面代码片段中可以看到我研究动态分发的真正原因。假设我要创建一个CloningLab结构体，其中包含一个由<code>trait object</code>（在本例中为Mammal）构成的<code>vector</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CloningLab</span></span> &#123;</span><br><span class="line">    subjects: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;Mammal&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mammal</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span></span> &#123;</span><br><span class="line">    meow_factor: <span class="built_in">u8</span>,</span><br><span class="line">    purr_factor: <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Mammal <span class="keyword">for</span> Cat &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Cat::walk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Cat::run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常运行。你可以可以遍历subjects向量(vector)，并可以调用<code>run</code>或<code>walk</code>方法。但是，当你想对一个<code>trait object</code>添加一个额外的<code>trait</code>约束的话便会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CloningLab</span></span> &#123;</span><br><span class="line">    subjects: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;Mammal + <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CloningLab &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone_subjects</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;Mammal + <span class="built_in">Clone</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.subjects.clone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0225]: only the builtin traits can be used <span class="keyword">as</span> closure or object bounds</span><br><span class="line"> --&gt; test1.rs:<span class="number">3</span>:<span class="number">32</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     subjects: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;Mammal + <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">  |                                ^^^^^ non-builtin <span class="class"><span class="keyword">trait</span> <span class="title">used</span></span> <span class="keyword">as</span> bounds</span><br></pre></td></tr></table></figure><p>这令我非常的惊奇。在我看来，一个具有多个约束的<code>trait object</code>大抵可以类比于<code>C++</code>中的多继承。我以为其中实例都拥有多个虚函数表指针(vpointer)对应每一个基类，并且能正确分发。鉴于Rust仍还是一门年轻的语言，我很理解为什么开发人员可能不希望引入这种复杂性大大提升的特性(一直坚持糟糕的设计则会事倍功半)，但是我想弄清楚这样的系统究竟是如何运作的(或无法运作)。</p><h3 id="Rust中的虚表"><a href="#Rust中的虚表" class="headerlink" title="Rust中的虚表"></a>Rust中的虚表</h3><p>如<code>C++</code>那样，动态分发在Rust中是通过函数指针表实现的（<a href="https://doc.rust-lang.org/book/trait-objects.html#representation" target="_blank" rel="noopener">在Rust文档中有描述</a>）。根据文档，构成<code>Cat</code>的<code>Mammal</code>这个<code>trait object</code>的内存布局由两个指针组成，如下所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_layout-2.png" alt="cat_layout-2" title=""></div><div class="image-caption">cat_layout-2</div></figure><p>令我惊讶的是，对象的数据成员还有一个中间层。这看起来和C++表示形式有所不同：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_layout_cpp.png" alt="cat_layout_cpp" title=""></div><div class="image-caption">cat_layout_cpp</div></figure><p>先是虚表(vtable)指针，随后则是数据成员。Rust方法很有趣。 “构造”<code>trait object</code>时会产生成本，这与C++的方法不同，在C++中，强制转换为基类指针是零成本的（或者对于多重继承来说只是一些附加成本）。但这成本很小。 Rust方法的好处是，如果对象从未在多态上下文中使用过，则该对象不必存储虚表指针。我认为Rust励使用单态性这种说法比较好一些，所以这可能是一个不错的权衡方案。</p><h3 id="多约束trait-object"><a href="#多约束trait-object" class="headerlink" title="多约束trait object"></a>多约束trait object</h3><p>让我们回到最开始的那个问题，让我们思考一下这个问题如何在<code>C++</code>中解决。如果我们有为某个结构体实现的多个<code>trait</code>(纯虚类)，那么我们的结构体实例内存布局将如下(例：<code>Mammal</code>和<code>Clone</code>)：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_and_clone_cpp-1.png" alt="cat_and_clone_cpp-1" title=""></div><div class="image-caption">cat_and_clone_cpp-1</div></figure><p>可以看到我们现在有多个虚表指针，每个指针对应于<code>Cat</code>继承的一个基类（包含虚函数）。为了把一个<code>Cat*</code>转为<code>Mammal*</code>，我们不需要做任何事，但是要把<code>Cat*</code>转为一个<code>Clone*</code>，编译器将会为<code>this</code>指针增加 8 字节（用来跳到下一个指针，假定 <code>sizeof(void*) == 8</code> ）。</p><p>不难想象在Rust中类似的情形：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/cat_clone_rust_candidate_1-1.png" alt="cat_clone_rust_candidate_1-1" title=""></div><div class="image-caption">cat_clone_rust_candidate_1-1</div></figure><p>所以现在在这个<code>trait object</code>里面有两个虚表指针了。如果编译器需要对于<code>Mammal + Clone</code>这个<code>trait object</code>履行动态分发的原则的话，它可以访问对应虚表中的对应项并执行调用。然而Rust(还)并不支持结构体继承，所以并不存在把正确的子对象作为<code>self</code>传递的问题。<code>self</code>永远指向的是<code>data</code>指针。</p><p>这看上去好像可以很好的运行，但是这种方案也带来了一些冗余。对于这个类型的大小（size）、对齐（alignment）以及<code>drop</code>指针使我们有了多份拷贝。我们可以通过组合虚表来消除这些冗余。这基本上就是当你执行 trait 继承时会发生的事情：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CloneMammal</span></span>: <span class="built_in">Clone</span> + Mammal&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; CloneMammal <span class="keyword">for</span> T <span class="keyword">where</span> T: <span class="built_in">Clone</span> + Mammal&#123;&#125;</span><br></pre></td></tr></table></figure><p>以这种方式使用 trait 继承是一个通常建议的技巧，以绕过 trait 对象的正常限制。trait 继承的使用产生了一个单独的虚表，没有任何冗余。所以内存布局如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/clone_mammal_rust-1.png" alt="clone_mammal_rust-1" title=""></div><div class="image-caption">clone_mammal_rust-1</div></figure><p><strong>译者：翻译到一半结果发现有人已经翻译完了😅️(人麻了)</strong></p><p><strong>那就直接贴网址吧 下面的基本是复制的翻译:<a href="https://juejin.cn/post/6872898487244029960" target="_blank" rel="noopener">点击跳转</a></strong></p><p>更加简单！并且你现在就可以这么做！或许我们真正想要的是，当我们写出一个多约束的 trait 对象时，让编译器为我们生成一个这样的 trait（译者注：指仅含有单个虚表的 trait）。但是等一下，这里存在一些重要的限制。即，你不能把一个<code>Clone + Mammal</code>的 trait 对象转为一个<code>Clone</code>的 trait 对象。这似乎是很奇怪的行为，但是不难看到为什么这样的转换行不通。</p><p>假定你尝试写出下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = Cat &#123;</span><br><span class="line">  meow_factor: <span class="number">7</span></span><br><span class="line">  purr_factor: <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No problem, a CloneMammal is impl for Cat</span></span><br><span class="line"><span class="keyword">let</span> clone_mammal: &amp;CloneMammal = cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error!</span></span><br><span class="line"><span class="keyword">let</span> clone: &amp;<span class="built_in">Clone</span> = &amp;clone_mammal;</span><br></pre></td></tr></table></figure><p>第 10 行一定无法编译，因为编译器不可能找到对应的虚表来放入这个 trait 对象。它只知道这个被引用的对象实现了<code>Clone + Mammal</code>，但是它无法区分这二者。当然，我们可以区分它一定是个<code>Cat</code>，但是如果代码像下面这样呢：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = Cat &#123;</span><br><span class="line">  meow_factor: <span class="number">7</span></span><br><span class="line">  purr_factor: <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = Dog &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone_mammal: &amp;CloneMammal;</span><br><span class="line"><span class="keyword">if</span> get_random_bool() == <span class="literal">true</span> &#123;</span><br><span class="line">  clone_mammal = &amp;cat;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  clone_mammal = &amp;dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error! How can the compiler know what vtable to</span></span><br><span class="line"><span class="comment">// point to?</span></span><br><span class="line"><span class="keyword">let</span> clone: &amp;<span class="built_in">Clone</span> = &amp;clone_mammal;</span><br></pre></td></tr></table></figure><p>这里的问题就更加清晰了。编译器怎么知道要对 17 行正在构造的 trait 对象放入什么样的虚表呢？如果<code>clone_mammal</code>指向一个<code>Cat</code>，那么它应该是<code>Clone</code>的<code>Cat</code>虚表，如果它指向一个<code>Dog</code>，那么它应该是<code>Clone</code>的<code>Dog</code>虚表。<br> 所以 trait 继承这种方式有这种限制。你无法把一个 trait 对象转成 trait 对象的其他类型，即使当这个你想要的 trait 对象比你已经拥有的更加具体。</p><p>多个虚表指针的方式对于具有多约束的trait对象来说，看起来是一种好的方式。通过它，转换为一个低约束的trait对象就不是问题了。编译器应该使用的虚表就是<code>Clone</code>虚表指针指向的位置。</p><p><strong>下面就不是我复制的了</strong></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我希望完成这些能对一些读者带来收获。它肯定帮助我整理了对<code>trait object</code>的思考方式。在实践中，我认为这并不是一个真正紧迫的问题，这个限制只是让我感到惊讶罢了。</p><h4 id="最终代码-自己实现"><a href="#最终代码-自己实现" class="headerlink" title="最终代码(自己实现)"></a>最终代码(自己实现)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NewTrait</span></span>: Mammal + std::clone::<span class="built_in">Clone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CloningLab</span></span>&lt;T: NewTrait&gt; &#123;</span><br><span class="line">    subjects: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: NewTrait&gt; CloningLab&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone_subjects</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.subjects.clone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mammal</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span></span> &#123;</span><br><span class="line">    meow_factor: <span class="built_in">u8</span>,</span><br><span class="line">    purr_factor: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Mammal <span class="keyword">for</span> Cat &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Cat::walk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Cat::run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，解决思路便是以泛型限制<code>trait object</code>，可能是<code>Rust</code>团队希望单态和多态分别用不同的语法来实现吧。</p></div><blockquote class="post-copyright"><div class="content"> <span class="post-time">最后更新时间：<time datetime="2021-03-28T17:14:07.504Z" itemprop="dateUpdated">2021-03-29 01:14:07</time></span><br> 如非注明转载，均为本文原创或编译，转载请注明出处。<br>本文链接：<a href="/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" target="_blank" rel="external">http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/</a><br>本文遵循<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div><footer> <a href="http://blog.fivezha.cn"><img src="https://cn.gravatar.com/avatar/bbca35300364b268662a56b05d130341s" alt="xmmmmmovo"> xmmmmmovo</a></footer></blockquote><div class="page-reward"> <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&title=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&pic=https://cn.gravatar.com/avatar/bbca35300364b268662a56b05d130341s" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&title=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&source=关于Rust中trait object和虚表" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&via=http://blog.fivezha.cn" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/2021/02/23/steelseries-mouse-change-microchip/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">记录一次修复我的赛睿鼠标的过程</h4></a></div><div class="waves-block waves-effect next"><a href="/2021/01/26/a-week-with-macbookpro-m1/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">MacBook Pro(2020 M1)半个月使用体验</h4></a></div></nav><div class="comments vcomment" id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="昵称,邮箱,网址(https://)".split(",").filter(function(a){return-1<GUEST_INFO.indexOf(a)});new Valine({el:"#comments",notify:!0,verify:!1,appId:"55ujxYDQhAADDjyqYIwt1e1e-gzGzoHsz",appKey:"F1sOiWvmQ6AJvItQoKMKFFEd",avatar:"mp",placeholder:"有什么想法都可以写昂~",guest_info:0==guest_info.length?GUEST_INFO:guest_info,pageSize:"15",emojiCDN:"//cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/",emojiMaps:{alu2:"alu/不出所料.png",alu3:"alu/不说话.png",alu4:"alu/不高兴.png",alu5:"alu/中刀.png",alu6:"alu/中指.png",alu7:"alu/中枪.png",alu8:"alu/亲亲.png",alu9:"alu/便便.png",alu10:"alu/内伤.png",alu11:"alu/击掌.png",alu12:"alu/口水.png",alu13:"alu/吐.png",alu14:"alu/吐舌.png",alu15:"alu/吐血倒地.png",alu16:"alu/呲牙.png",alu17:"alu/咽气.png",alu18:"alu/哭泣.png",alu19:"alu/喜极而泣.png",alu20:"alu/喷水.png",alu21:"alu/喷血.png",alu22:"alu/坐等.png",alu23:"alu/害羞.png",alu24:"alu/小眼睛.png",alu25:"alu/尴尬.png",alu26:"alu/得意.png",alu27:"alu/惊喜.png",alu28:"alu/想一想.png",alu29:"alu/愤怒.png",alu30:"alu/扇耳光.png",alu31:"alu/投降.png",alu32:"alu/抠鼻.png",alu33:"alu/抽烟.png",alu34:"alu/无奈.png",alu35:"alu/无所谓.png",alu36:"alu/无语.png",alu37:"alu/暗地观察.png",alu38:"alu/期待.png",alu39:"alu/欢呼.png",alu40:"alu/汗.png",alu41:"alu/深思.png",alu42:"alu/狂汗.png",alu43:"alu/献花.png",alu44:"alu/献黄瓜.png",alu45:"alu/皱眉.png",alu46:"alu/看不见.png",alu47:"alu/看热闹.png",alu48:"alu/瞅你.png",alu49:"alu/肿包.png",alu50:"alu/脸红.png",alu51:"alu/蜡烛.png",alu52:"alu/装大款.png",alu53:"alu/观察.png",alu54:"alu/赞一个.png",alu55:"alu/邪恶.png",alu56:"alu/锁眉.png",alu57:"alu/长草.png",alu58:"alu/阴暗.png",alu59:"alu/高兴.png",alu60:"alu/黑线.png",alu61:"alu/鼓掌.png"}})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 感恩亲人~<i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"> <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码"></div> <label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.png" data-alipay="/img/alipay.png"><div class="reward-toggle-ctrol"> <span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-item switch" id="switvh">切换</span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script src="//unpkg.com/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/clipboard.min.js"></script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/copy.min.js"></script></div><footer class="footer"><div class="top"><p> <span id="busuanzi_container_site_uv" style="display:none">站点总访客数：<span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv" style="display:none">站点总访问量：<span id="busuanzi_value_site_pv"></span></span></p><p> <span>xmmmmmovo &copy; 2017 - 2021</span> <span><a href="http://beian.miit.gov.cn/" target="_blank">鲁ICP备20025683号-1</a><br> Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">Indigo</a> Modified <a href="https://github.com/xmmmmmovo/indigomod" target="_blank">indigomod</a></span></p></div><div class="bottom"><p><span><a href="/atom.xml" target="_blank" class="rss" title="RSS"><i class="icon icon-lg icon-rss"></i></a></span> <span>内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 协议</a></span></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&title=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&pic=https://cn.gravatar.com/avatar/bbca35300364b268662a56b05d130341s" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&title=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&source=关于Rust中trait object和虚表" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【译】探索Rust中的动态分发》 — 异国迷宫的十字路口&url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/&via=http://blog.fivezha.cn" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p> <img src="//api.qrserver.com/v1/create-qr-code/?data=http://blog.fivezha.cn/2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis"> {tags}</div> <time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/search.min.js" async></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>