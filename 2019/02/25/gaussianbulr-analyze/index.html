<!DOCTYPE html><html><head><script src="https://cdn.staticfile.org/echarts/4.8.0/echarts.min.js"></script><meta charset="utf-8"><title>opencv中高斯模糊(滤波器)的源码解析(c++版) - 异国迷宫的十字路口</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="c++,cv"><meta name="description" content="因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码"><meta property="og:type" content="article"><meta property="og:title" content="opencv中高斯模糊(滤波器)的源码解析(c++版)"><meta property="og:url" content="http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/index.html"><meta property="og:site_name" content="异国迷宫的十字路口"><meta property="og:description" content="因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%AE%8F%E5%AE%9A%E4%B9%89.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%AE%8F%E5%AE%9A%E4%B9%892.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/WIN32.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%8D%B7%E7%A7%AF.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%85%B3%E9%94%AE%E5%AD%97%E6%9F%A5%E6%89%BE1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%87%BD%E6%95%B01.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%87%BD%E6%95%B02.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%87%BD%E6%95%B03.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/bin.png"><meta property="article:published_time" content="2019-02-25T11:40:25.000Z"><meta property="article:modified_time" content="2020-08-04T06:06:25.039Z"><meta property="article:author" content="xmmmmmovo"><meta property="article:tag" content="c++"><meta property="article:tag" content="cv"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A32.png"><link rel="alternate" type="application/atom+xml" title="异国迷宫的十字路口" href="/atom.xml"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/css/style.css"><script>window.lazyScripts=[]</script><script>var _mtac={};!function(){var t=document.createElement("script");t.src="//pingjs.qq.com/h5/stats.js?v2.0.4",t.setAttribute("name","MTAH5"),t.setAttribute("sid","500725321");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(/img/brand.png)"><div class="brand"> <a href="/" class="avatar waves-effect waves-circle waves-light"><img src="/img/avatar.png"></a><hgroup class="introduce"><h5 class="nickname">xmmmmmovo</h5> <a href="mailto:lolicoin@foxmail.com" title="lolicoin@foxmail.com" class="mail">lolicoin@foxmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-user"></i> 关于</a></li><li class="waves-block waves-effect"><a href="/links"><i class="icon icon-lg icon-external-link"></i> 友链</a></li><li class="waves-block waves-effect"><a href="https://github.com/xmmmmmovo" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="https://travellings.now.sh/" target="_blank"><i class="icon icon-lg icon-paper-plane"></i> 开往~新世界~</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">opencv中高斯模糊(滤波器)的源码解析(c++版)</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">opencv中高斯模糊(滤波器)的源码解析(c++版)</h1><h5 class="subtitle"> <time datetime="2019-02-25T11:40:25.000Z" itemprop="datePublished" class="page-time">2019-02-25</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/study/">study</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap post-toc-shrink" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分析函数接口"><span class="post-toc-number">1.</span> <span class="post-toc-text">分析函数接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源码解析"><span class="post-toc-number">2.</span> <span class="post-toc-text">源码解析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解高斯模糊函数"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">理解高斯模糊函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#查找函数"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">查找函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析函数"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">分析函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CV-INSTRUMENT-REGION"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">CV_INSTRUMENT_REGION()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#if-borderType-BORDER-CONSTANT-amp-amp-borderType-amp-BORDER-ISOLATED-0"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">if( borderType !&#x3D; BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) !&#x3D; 0 )</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CV-OVX-RUN-true-openvx-gaussianBlur-src-dst-ksize-sigma1-sigma2-borderType"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ifdef至endif部分"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">ifdef至endif部分</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#剩下部分"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">剩下部分</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">3.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#借物表"><span class="post-toc-number">4.</span> <span class="post-toc-text">借物表</span></a></li></ol></nav></aside><article id="post-gaussianbulr-analyze" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">opencv中高斯模糊(滤波器)的源码解析(c++版)</h1><div class="post-meta"><time class="post-time" title="2019-02-25 19:40:25" datetime="2019-02-25T11:40:25.000Z" itemprop="datePublished"><i class="icon icon-calendar"></i> 2019-02-25</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/study/">study</a></li></ul><span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none"><i class="icon icon-eye" style="padding:0 .3em"></i><span id="busuanzi_value_page_pv"></span></span></div><div class="post-content" id="post-content" itemprop="postContent"><p><strong>因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码</strong></p><a id="more"></a><h2 id="分析函数接口"><a href="#分析函数接口" class="headerlink" title="分析函数接口"></a>分析函数接口</h2><p>首先，在下用的是vs版本的opencv，是直接编译好给你静态库(.lib)文件的，所以当我按住<code>ctrl</code>寻找<code>GaussianBlur</code>这个函数时 只发现了其在<code>imgproc.hpp</code>里面提供给你的接口。</p><p>大概是下面这个样子的:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/高斯函数接口2.png" alt="高斯模糊函数接口1" title=""></div><div class="image-caption">高斯模糊函数接口1</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/高斯函数.png" alt="高斯模糊函数接口2" title=""></div><div class="image-caption">高斯模糊函数接口2</div></figure><blockquote><p>该函数将源图像与指定的卷积核进行卷积。并且支持原图像直接进行滤波操作。</p></blockquote><p>可以看到这个函数接口主要由四个部分组成:</p><ol><li><p><code>CV_EXPORTS_W</code><br>继续往上找 可以发现这是一个宏定义</p><p><img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%AE%8F%E5%AE%9A%E4%B9%89.png" alt="宏定义1"></p><p>可以发现 这个宏定义是在<strong>编译阶段</strong>将<code>CV_EXPORTS</code>替换为了<code>CV_EXPORTS_W</code>再向上查找 会发现</p><p><img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/%E5%AE%8F%E5%AE%9A%E4%B9%892.png" alt="宏定义2"></p><p>这里又是一个宏组成的用以定义<code>CV_EXPORTS</code>的宏组，这一段其实就是类似于<code>if else</code>的结构，主要的作用机理便是<strong>适配各类环境(操作系统)</strong> 。从中，我们这里又分成了三个部分进行解析:</p><ol><li><p><code>#if (defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__) &amp;&amp; defined CVAPI_EXPORTS</code><br>可以看到，这里判断了两个表达式的逻辑与(<code>(defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__)</code>和<code>defined CVAPI_EXPORTS</code>)</p><ol><li><p>首先，<code>defined</code>的意义在于寻找后面的字段是否已经被宏定义过。</p></li><li><p>其次，观察第一个表达式，发现<code>_WIN32</code> 在之前已经被定义过了，通过查阅<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017" target="_blank" rel="noopener">微软官方宏定义文档</a>发现这个字段作用是基于编译器一个信号，表明是Windows环境下编译及运行的程序。</p><p><img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/WIN32.png" alt="WIN"></p><p>再查找前后未定义过的字段，继而发现<code>WIN32</code>是<strong>只要包含了 Windows.h，那么 WIN32 常量是肯定定义了</strong>的设定，不能用于判断平台环境。<br>而<code>WINCE</code>便是判断是否为WINCE环境的程序<br><code>__CYGWIN__</code>如果事先有了解过cygwin这个程序的话，这个应该不难看懂，也是用以判断环境的定义，而cywin则是在Windows环境下用以模拟Unix环境的软件(P.S.还是蛮好用的)</p></li><li><p>再次，观察第二个表达式，也是查找字段是否定义过，这个查了一下，发现这个宏定义是存在于opencv.dll这个文件里面的。也就是判断是否已经链接了动态库。</p></li><li><p>这样这一行便很容易懂了，目的便是判断程序环境<strong>是否为Windows</strong>且已经链接opencv.dll的库用以进行下一步操作。</p></li><li><p>再提一句，关于这个操作系统(环境)的判定其实还有很多，这里放一个<a href="https://github.com/qt/qt/blob/4.8/src/corelib/global/qglobal.h" target="_blank" rel="noopener">Qt里面关于系统判定的头文件(147行开始)(版本比较老了 可自行再自己qt里查看)</a></p></li></ol></li><li><p><code># define CV_EXPORTS __declspec(dllexport)</code><br>这一句涉及到的主要是dll函数导入，需要和下面最后三行联合起来看<br><code>#define CV_EXPORTS</code><br>第二行需要联合上面这句一同分析，首先，这个头文件内部写的都是接口，都是作者自己编写留给别人用以调用的，并且从第一点分析的结果来看，这些接口的<strong>实现</strong>都是放在opencv.dll文件中的，而第一行的判断便是判断你是否在最需要隐式调用，如果有，那么直接可以利用隐式调用的方法进行<a href="https://blog.csdn.net/W_Y2010/article/details/80428067" target="_blank" rel="noopener"><strong>函数导出(具体__declspec也有在微软文档里写)</strong></a><br>反之，如果判断事先未进行链接，那么使用的时候必然是显式调用(没错，就是配置环境的时候配置的lib文件链接，那就是显式调用了<a href="https://wenku.baidu.com/view/f7a24236b52acfc789ebc999.html" target="_blank" rel="noopener">参考此篇文章</a>)，既然是显式调用，自然便不需要进行函数导出操作。所以将<code>CV_EXPORTS</code>字段设置为空。</p></li><li><p><code>elif defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 4</code><br><code>define CV_EXPORTS __attribute__((visibility(&quot;default&quot;)))</code><br>这两句涉及的主要有两个功能: 1. <a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html" target="_blank" rel="noopener">判断是否为GCC编译环境</a> 2. <a href="https://blog.csdn.net/mutourenzhang/article/details/47803803" target="_blank" rel="noopener">为全局动态库函数设置非隐藏声明</a><br>对于第一点，类似于分析第一条，可以知道这句的意思便是检查gcc并测试是否高于4.0.0版本(猜测与c++标准有关)</p></li></ol></li><li><p><code>void</code><br>函数返回值，这里返回值为空</p></li><li><p><code>GaussianBlur</code><br>函数名，这里因为是声明所以是跟源码的函数一样，可以很快找到源码定义。</p></li><li><p><code>()</code><br>括号里面的是函数参数根据上面的说明注释，便可解读出这个函数所有参数意义:</p><ul><li><code>src</code> 这是输入图像，这个图像可以拥有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。</li><li><code>dst</code> 这是输出图像，大小与类型与src相同。</li><li><code>ksize</code> 这是卷积核的大小参数(是数字desu)。其中ksize.width和ksize.height可以不同，但是它们必须是一个正奇数(或者零)，并且您不用担心卷积核内部参数问题，卷积核会根据sigma来计算。</li><li><code>sigmaX</code> X方向的卷积核标准偏差。</li><li><code>sigmaY</code> Y方向的高斯核标准偏差; 如果sigmaY为零，则设置为等于sigmaX，如果两个sigma都是零，则它们是从ksize.width和ksize.height计算的（详见cv :: getGaussianKernel）; 这些语义未来均有可能修改，建议指定所有ksize，sigmaX和sigmaY。</li><li><code>borderType</code> 像素外推模式，请参阅cv :: BorderTypes</li><li><code>sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur</code>。这里显示了函数的相关函数，是观察源码的重要提示</li></ul></li></ol><p>这样，对于函数接口的解析就算是完成了，从中我们可以得出以下几个结论：</p><ol><li>直接ctrl寻找到底是不能找到原函数代码的。</li><li>找到原函数的同时也需要sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur这一些列函数辅助理解。</li><li>这个函数在cv命名空间中，名称应该为<code>cv::GaussianBlur</code> 。</li></ol><p>所以接下来第一步便是需要在源码中寻找到真正的函数实现。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="理解高斯模糊函数"><a href="#理解高斯模糊函数" class="headerlink" title="理解高斯模糊函数"></a>理解高斯模糊函数</h3><p>高斯模糊函数本质是利用<strong>高斯滤波器</strong>对于给定图像进行<strong>平滑</strong>操作。平滑操作时什么，是减少噪点。噪点的原因又是什么，是单个像素包含的信息过于独立。如何减少噪点，很简单，只需要让每个像素点包含有周围像素的部分信息就行了呗。选用什么方法，最简单的方法便是——卷积(见下图)。利用一个给定的以某种分布函数构建的二维卷积内核，将中心点对准像素点，进行卷积操作，得到的像素点便包含了周围像素的不完全信息，这样子附近的像素点差异性便会越来越小，当整张图像(或选中部分)卷积完成后，每个像素点便不再过于独立，每个便有了附近像素点的信息，这样字图像便不会看上去那么的“扎眼”，会温润平滑许多，这就是高斯模糊的本质了。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/卷积.png" alt="卷积操作" title=""></div><div class="image-caption">卷积操作</div></figure><center>[相信看图大概大家就能明白卷积是个啥东西了 再结合上面语句应该就差不多了]</center><h3 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h3><p>利用grep命令，很容易便能找到这个函数，找到文件并切到这个函数定义，便可以窥见整个函数的全貌了。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/关键字查找1.png" alt="查找" title=""></div><div class="image-caption">查找</div></figure><p>以下是cv::GaussianBlur函数全貌:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/函数1.png" alt="func1" title=""></div><div class="image-caption">func1</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/函数2.png" alt="func2" title=""></div><div class="image-caption">func2</div></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><p>分析这个函数之前，首先先要从内部关联的函数看起。</p><h4 id="CV-INSTRUMENT-REGION"><a href="#CV-INSTRUMENT-REGION" class="headerlink" title="CV_INSTRUMENT_REGION()"></a>CV_INSTRUMENT_REGION()</h4><p>这一行末尾没有分号，这样的类似函数的字符段有很大可能是一个宏定义变量，经查找，在private.hpp文件中有以下定义：</p><blockquote><p> ///// General instrumentation<br> // General OpenCV region instrumentation macro<br> #define CV_INSTRUMENT_REGION() CV_INSTRUMENT_REGION_META(cv::instr::TYPE_GENERAL, cv::instr::IMPL_PLAIN)</p></blockquote><p>经查找，这个字段主要是关于初始化以及边界类型的判断。</p><h4 id="if-borderType-BORDER-CONSTANT-amp-amp-borderType-amp-BORDER-ISOLATED-0"><a href="#if-borderType-BORDER-CONSTANT-amp-amp-borderType-amp-BORDER-ISOLATED-0" class="headerlink" title="if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )"></a>if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> type = _src.type();</span><br><span class="line">Size <span class="built_in">size</span> = _src.<span class="built_in">size</span>();</span><br><span class="line">_dst.create( <span class="built_in">size</span>, type );</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    根据说明文档中所写的</span></span><br><span class="line"><span class="comment">    BORDER_CONSTANT    = 0, //!&lt; `iiiiii|abcdefgh|iiiiiii`with some specified `i`</span></span><br><span class="line"><span class="comment">    BORDER_REPLICATE   = 1, //!&lt; `aaaaaa|abcdefgh|hhhhhhh`</span></span><br><span class="line"><span class="comment">    BORDER_REFLECT     = 2, //!&lt; `fedcba|abcdefgh|hgfedcb`</span></span><br><span class="line"><span class="comment">    BORDER_WRAP        = 3, //!&lt; `cdefgh|abcdefgh|abcdefg`</span></span><br><span class="line"><span class="comment">    BORDER_REFLECT_101 = 4, //!&lt; `gfedcb|abcdefgh|gfedcba`</span></span><br><span class="line"><span class="comment">    BORDER_TRANSPARENT = 5, //!&lt; `uvwxyz|absdefgh|ijklmno`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    BORDER_REFLECT101  = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101</span></span><br><span class="line"><span class="comment">    BORDER_DEFAULT     = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101</span></span><br><span class="line"><span class="comment">    BORDER_ISOLATED    = 16 //!&lt; do not look outside of ROI</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    BORDER_CONSTANT 需要设置borderValue 指定 ' i ' 值（常数）</span></span><br><span class="line"><span class="comment">    BORDER_REPLICATE ，复制边界像素</span></span><br><span class="line"><span class="comment">    BORDER_REFLECT  ，反射复制边界像素   </span></span><br><span class="line"><span class="comment">    BORDER_REFLECT_101，以边界为对称轴反射复制像素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里是说如果边缘扩展不是常数扩展，且在规定图像范围内部，便执行下列操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果输入矩阵是一个行向量，则滤波核的高强制为1</span></span><br><span class="line">    <span class="comment">// 下面同理</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">size</span>.<span class="built_in">height</span> == <span class="number">1</span> )</span><br><span class="line">        ksize.<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">size</span>.<span class="built_in">width</span> == <span class="number">1</span> )</span><br><span class="line">        ksize.<span class="built_in">width</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果核宽跟核高都是一直接复制输出</span></span><br><span class="line"><span class="keyword">if</span>( ksize.<span class="built_in">width</span> == <span class="number">1</span> &amp;&amp; ksize.<span class="built_in">height</span> == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    _src.copyTo(_dst);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CV-OVX-RUN-true-openvx-gaussianBlur-src-dst-ksize-sigma1-sigma2-borderType"><a href="#CV-OVX-RUN-true-openvx-gaussianBlur-src-dst-ksize-sigma1-sigma2-borderType" class="headerlink" title="CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))"></a>CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))</h4><p>这里很明显是一个被宏定义的字段，通过查找，我们能够找到其定位在<code>modules/core/include/opencv2/core/openvx/ovx_defs.hpp</code>当中</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/函数3.png" alt="func3" title=""></div><div class="image-caption">func3</div></figure><p>按每行解析的话就是如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于检测基于OpenVX的实现的实用程序宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_OPENVX</span></span><br><span class="line">	<span class="comment">// 如果检测到OPENVX便执行下列语句</span></span><br><span class="line">	<span class="comment">// 下面这两句主要作用也是标识</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IVX_HIDE_INFO_WARNINGS <span class="comment">// 隐藏警告信息</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> IVX_USE_OPENCV <span class="comment">// 使用opencv的标识</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ivx.hpp"</span> <span class="comment">// 将hpp文件包含进来</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> CV_OVX_RUN(condition, func, ...)          \ <span class="comment">// ...会被替换</span></span></span><br><span class="line">    	<span class="comment">// 这里为了给外界提供OpenVX使用表示 利用宏定义做成了一个接口</span></span><br><span class="line">		<span class="comment">// 而这个接口则是主要为了提供硬件层面加速用的(主要面向对象是嵌入式设计)</span></span><br><span class="line">        <span class="keyword">if</span> (cv::useOpenVX() &amp;&amp; (condition) &amp;&amp; func)   \</span><br><span class="line">        &#123;                                             \</span><br><span class="line">        	<span class="comment">// __VA_ARGS__是可变参数宏定义 用以替换上面...的内容</span></span><br><span class="line">            <span class="keyword">return</span> __VA_ARGS__;                       \</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// 否则便执行下面这条</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> CV_OVX_RUN(condition, func, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_OPENVX</span></span></span><br></pre></td></tr></table></figure><p>其中<code>useOpenVX()</code>函数主要是返回一个bool类型的变量用以判断是否使用openVX用以计算。</p><p>所以<code>CV_OVX_RUN()</code>这句话便是对于嵌入式设计进行尝试性的优化操作。</p><h4 id="ifdef至endif部分"><a href="#ifdef至endif部分" class="headerlink" title="ifdef至endif部分"></a>ifdef至endif部分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若之前有过HAVE_TEGRA_OPTIMIZATION优化选项的定义，则执行宏体中的tegra优化版函数并返回</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_TEGRA_OPTIMIZATION</span></span><br><span class="line">	<span class="comment">// 拷贝到临时变量(暂不知为什么要拷贝到一个临时变量里面去)</span></span><br><span class="line">    Mat src = _src.getMat();</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(sigma1 == <span class="number">0</span> &amp;&amp; sigma2 == <span class="number">0</span> &amp;&amp; tegra::useTegra() &amp;&amp; tegra::gaussian(src, dst, ksize, borderType))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里也显而易见是尝试tegra优化。</p><p>但是为什么拷贝到临时变量里也可以改变原值，这里需要进一步到Mat变量的运算符重载里面进行参考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">Mat&amp; Mat::<span class="keyword">operator</span> = (<span class="keyword">const</span> Mat&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;m )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( m.u )</span><br><span class="line">            CV_XADD(&amp;m.u-&gt;refcount, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">release</span>(); <span class="comment">// 归零初始化</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	归零后进行基本数据共享</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        flags = m.flags;</span><br><span class="line">        <span class="keyword">if</span>( dims &lt;= <span class="number">2</span> &amp;&amp; m.dims &lt;= <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            dims = m.dims;</span><br><span class="line">            rows = m.rows;</span><br><span class="line">            cols = m.cols;</span><br><span class="line">            <span class="built_in">step</span>[<span class="number">0</span>] = m.<span class="built_in">step</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">step</span>[<span class="number">1</span>] = m.<span class="built_in">step</span>[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copySize(m);</span><br><span class="line">        data = m.data;</span><br><span class="line">        datastart = m.datastart; <span class="comment">// 共享数据头</span></span><br><span class="line">        dataend = m.dataend; <span class="comment">// 共享数据尾</span></span><br><span class="line">        datalimit = m.datalimit;</span><br><span class="line">        allocator = m.allocator; <span class="comment">// 内存共享</span></span><br><span class="line">        u = m.u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现在<code>=</code>重载的时候仅是进行的浅拷贝操作，意思是只将数据头数据尾进行复制，而所有数据的内存数据都是相通共享的。固仅需要一方变量更改便会联动所有对其进行过浅拷贝的变量变化。</p><h4 id="剩下部分"><a href="#剩下部分" class="headerlink" title="剩下部分"></a>剩下部分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里主要是针对opencl(GPU加速)无法使用的情况进行CPU版本计算</span></span><br><span class="line"><span class="comment">	这个IPP是一个Intel提供的开源的计算机视觉加速库，可以提供很多算法的Intel专属的多线程优化方案API，这也是为什么下面在opencl的gpu优化代码之后还又添加了利用CPU版本的filter2D的计算方案(因为有部分Intel专属的优化函数，针对APU和老式的Intel CPU(09年之前)无法进行计算，所以只能选取最普通的filter2D计算方案执行)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	官网FAQ(有兴趣可以了解一下): https://software.intel.com/en-us/articles/intel-integrated-performance-primitives-intel-ipp-open-source-computer-vision-library-opencv-faq/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CV_IPP_RUN(!(ocl::useOpenCL() &amp;&amp; _dst.isUMat()), ipp_GaussianBlur( _src,  _dst,  ksize, sigma1,  sigma2, borderType));</span><br><span class="line"></span><br><span class="line">Mat kx, ky;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里是新建一个高斯卷积内核(后面讲)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">createGaussianKernels(kx, ky, type, ksize, sigma1, sigma2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里是针对ksize = 3 or 5的情况做了opencl优化(A卡N卡均可享受opencl优化qwq)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= <span class="number">2</span> &amp;&amp;</span><br><span class="line">           ((ksize.<span class="built_in">width</span> == <span class="number">3</span> &amp;&amp; ksize.<span class="built_in">height</span> == <span class="number">3</span>) ||</span><br><span class="line">            (ksize.<span class="built_in">width</span> == <span class="number">5</span> &amp;&amp; ksize.<span class="built_in">height</span> == <span class="number">5</span>)) &amp;&amp;</span><br><span class="line">           (<span class="keyword">size_t</span>)_src.rows() &gt; ky.total() &amp;&amp; (<span class="keyword">size_t</span>)_src.cols() &gt; kx.total(),</span><br><span class="line">           ocl_GaussianBlur_8UC1(_src, _dst, ksize, CV_MAT_DEPTH(type), kx, ky, borderType));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里便是利用filter2D进行操作了</span></span><br><span class="line"><span class="comment">	传入Point(-1, -1) 是指内核中的锚点(就是后面的anchor)位置。默认值（-1，-1）表示锚点位于内核中心。</span></span><br><span class="line"><span class="comment">	0 则是存储单位 默认是0 后面会通过计算改变并存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sepFilter2D(_src, _dst, CV_MAT_DEPTH(type), kx, ky, Point(<span class="number">-1</span>,<span class="number">-1</span>), <span class="number">0</span>, borderType);</span><br></pre></td></tr></table></figure><p>这里在下主要解析<code>createGaussianKernels</code>与<code>sepFilter2D</code>这两个函数，主要是因为无论是<code>openvx_gaussianBlur</code>还是<code>ipp_GaussianBlur</code>以及<code>ocl_GaussianBlur_8UC1</code>都有着大量未知的API，要读懂这些API还需要大量文档查阅，在下在此就先不解析了。</p><p>所以首先先来看一下<code>createGaussianKernels</code>这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这个函数仅是用于是创建高斯卷积核</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createGaussianKernels</span><span class="params">( Mat &amp; kx, Mat &amp; ky, <span class="keyword">int</span> type, Size ksize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">double</span> sigma1, <span class="keyword">double</span> sigma2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = CV_MAT_DEPTH(type); <span class="comment">// 根据输入图像类型获得位深度</span></span><br><span class="line">    <span class="keyword">if</span>( sigma2 &lt;= <span class="number">0</span> )</span><br><span class="line">        sigma2 = sigma1; <span class="comment">// 非正则与sigma1相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sigma自动检测内核大小(如果用户没有设置ksize的话)</span></span><br><span class="line">    <span class="comment">// 根据CV_8U来计算 大致接近7*sigma 或者 9*sigma</span></span><br><span class="line">    <span class="comment">// cvRound函数还内联了汇编 在下看不懂了</span></span><br><span class="line">    <span class="comment">// |1 的原因是使宽高为奇数</span></span><br><span class="line">    <span class="keyword">if</span>( ksize.<span class="built_in">width</span> &lt;= <span class="number">0</span> &amp;&amp; sigma1 &gt; <span class="number">0</span> )</span><br><span class="line">        ksize.<span class="built_in">width</span> = cvRound(sigma1*(depth == CV_8U ? <span class="number">3</span> : <span class="number">4</span>)*<span class="number">2</span> + <span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( ksize.<span class="built_in">height</span> &lt;= <span class="number">0</span> &amp;&amp; sigma2 &gt; <span class="number">0</span> )</span><br><span class="line">        ksize.<span class="built_in">height</span> = cvRound(sigma2*(depth == CV_8U ? <span class="number">3</span> : <span class="number">4</span>)*<span class="number">2</span> + <span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这句只是为了保证卷积核的宽跟高是正奇数</span></span><br><span class="line">    CV_Assert( ksize.<span class="built_in">width</span> &gt; <span class="number">0</span> &amp;&amp; ksize.<span class="built_in">width</span> % <span class="number">2</span> == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        ksize.<span class="built_in">height</span> &gt; <span class="number">0</span> &amp;&amp; ksize.<span class="built_in">height</span> % <span class="number">2</span> == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取最大</span></span><br><span class="line">    sigma1 = <span class="built_in">std</span>::<span class="built_in">max</span>( sigma1, <span class="number">0.</span> );</span><br><span class="line">    sigma2 = <span class="built_in">std</span>::<span class="built_in">max</span>( sigma2, <span class="number">0.</span> );</span><br><span class="line"></span><br><span class="line">    kx = getGaussianKernel( ksize.<span class="built_in">width</span>, sigma1, <span class="built_in">std</span>::<span class="built_in">max</span>(depth, CV_32F) );</span><br><span class="line">    <span class="keyword">if</span>( ksize.<span class="built_in">height</span> == ksize.<span class="built_in">width</span> &amp;&amp; <span class="built_in">std</span>::<span class="built_in">abs</span>(sigma1 - sigma2) &lt; DBL_EPSILON )</span><br><span class="line">        <span class="comment">// 这里 如果判断核高与核宽相等，且sigma相差很小的情况下</span></span><br><span class="line">        <span class="comment">// 便可以直接进行赋值操作，减少了计算量</span></span><br><span class="line">        ky = kx;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ky = getGaussianKernel( ksize.<span class="built_in">height</span>, sigma2, <span class="built_in">std</span>::<span class="built_in">max</span>(depth, CV_32F) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中我们还需要解析<code>getGaussianKernel</code>这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">cv::getGaussianKernel</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">double</span> sigma, <span class="keyword">int</span> ktype )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里定义了一个常量用以规定大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SMALL_GAUSSIAN_SIZE = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 一个4 * 7的矩阵，用于对奇数长度小内核进行优化计算</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> small_gaussian_tab[][SMALL_GAUSSIAN_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1.f</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.25f</span>, <span class="number">0.5f</span>, <span class="number">0.25f</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.0625f</span>, <span class="number">0.25f</span>, <span class="number">0.375f</span>, <span class="number">0.25f</span>, <span class="number">0.0625f</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.03125f</span>, <span class="number">0.109375f</span>, <span class="number">0.21875f</span>, <span class="number">0.28125f</span>, <span class="number">0.21875f</span>, <span class="number">0.109375f</span>, <span class="number">0.03125f</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	这里计算滤波系数（数组）</span></span><br><span class="line"><span class="comment">    	如果 内核尺寸为奇数 且小于7</span></span><br><span class="line"><span class="comment">    	并且sigma小于等于0</span></span><br><span class="line"><span class="comment">    	那么滤波系数便是根据上面的small_gaussian_tab决定的</span></span><br><span class="line"><span class="comment">    	否则便是0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>* fixed_kernel = n % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; n &lt;= SMALL_GAUSSIAN_SIZE &amp;&amp; sigma &lt;= <span class="number">0</span> ? small_gaussian_tab[n&gt;&gt;<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	检测数据类型是否为float和double</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CV_Assert( ktype == CV_32F || ktype == CV_64F );</span><br><span class="line">    <span class="function">Mat <span class="title">kernel</span><span class="params">(n, <span class="number">1</span>, ktype)</span></span>; <span class="comment">// 建立一维向量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义指针指向数据</span></span><br><span class="line">    <span class="keyword">float</span>* cf = kernel.ptr&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">    <span class="keyword">double</span>* cd = kernel.ptr&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当sigma小于0时，采用公式得到sigma(只与n有关)，大于0就可以直接使用了。</span></span><br><span class="line">    <span class="keyword">double</span> sigmaX = sigma &gt; <span class="number">0</span> ? sigma : ((n<span class="number">-1</span>)*<span class="number">0.5</span> - <span class="number">1</span>)*<span class="number">0.3</span> + <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 表达式中e指数要用到</span></span><br><span class="line">    <span class="keyword">double</span> scale2X = <span class="number">-0.5</span>/(sigmaX*sigmaX);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = i - (n<span class="number">-1</span>)*<span class="number">0.5</span>;</span><br><span class="line">        <span class="comment">// 根据上面计算出来的系数来决定是否重新计算值</span></span><br><span class="line">        <span class="keyword">double</span> t = fixed_kernel ? (<span class="keyword">double</span>)fixed_kernel[i]:<span class="built_in">std</span>::<span class="built_in">exp</span>(scale2X*x*x);</span><br><span class="line">        <span class="comment">//根据精度选择变量</span></span><br><span class="line">        <span class="keyword">if</span>( ktype == CV_32F )</span><br><span class="line">        &#123;</span><br><span class="line">            cf[i] = (<span class="keyword">float</span>)t;</span><br><span class="line">            sum += cf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cd[i] = t;</span><br><span class="line">            sum += cd[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">1.</span>/sum; <span class="comment">// 归一化操作，计算需要除的数值</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( ktype == CV_32F )</span><br><span class="line">            cf[i] = (<span class="keyword">float</span>)(cf[i]*sum);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cd[i] *= sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kernel; <span class="comment">// 返回建立好的一维内核</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数的主要目的就是计算出高斯卷积核，这里选用分离计算，就是先计算水平（x）方向的一维卷积核，再根据sigma判断是否重新计算垂直（y）方向的一维卷积内核，这样子分离计算再针对尺寸较大的滤波器也可以有很高的效率，并且分离计算结合多线程也是很好的选择。</p><p>看完高斯内核的建立，我们知道高斯模糊主要利用了分离计算，那最后<code>sepFilter2D</code>函数也很容易看懂了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::sepFilter2D</span><span class="params">( InputArray _src, OutputArray _dst, <span class="keyword">int</span> ddepth,</span></span></span><br><span class="line"><span class="function"><span class="params">                      InputArray _kernelX, InputArray _kernelY, Point anchor,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_INSTRUMENT_REGION()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		这里考虑如果输入函数是UMat形式且维度小于等于2的情况下</span></span><br><span class="line"><span class="comment">		优先考虑使用opencl优化过的filter2D计算</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= <span class="number">2</span> </span><br><span class="line">               &amp;&amp; (<span class="keyword">size_t</span>)_src.rows() &gt; _kernelY.total() </span><br><span class="line">               &amp;&amp; (<span class="keyword">size_t</span>)_src.cols() &gt; _kernelX.total(),</span><br><span class="line">               ocl_sepFilter2D(_src, _dst, ddepth, _kernelX, _kernelY, anchor, delta, borderType))</span><br><span class="line"></span><br><span class="line">    Mat src = _src.getMat(), </span><br><span class="line">    kernelX = _kernelX.getMat(), </span><br><span class="line">    kernelY = _kernelY.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ddepth &lt; <span class="number">0</span> )</span><br><span class="line">        ddepth = src.depth();</span><br><span class="line"></span><br><span class="line">    _dst.create( src.<span class="built_in">size</span>(), CV_MAKETYPE(ddepth, src.channels()) );</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	找到src的矩阵的矩阵头存入wsz当中，并且将偏移量存入ofs变量中</span></span><br><span class="line"><span class="comment">    	这两个变量用于快速读取全部图像</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Point ofs;</span><br><span class="line">    <span class="function">Size <span class="title">wsz</span><span class="params">(src.cols, src.rows)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>( (borderType &amp; BORDER_ISOLATED) == <span class="number">0</span> )</span><br><span class="line">        src.locateROI( wsz, ofs );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	进行预先检测内核是否有误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CV_Assert( kernelX.type() == kernelY.type() &amp;&amp;</span><br><span class="line">               (kernelX.cols == <span class="number">1</span> || kernelX.rows == <span class="number">1</span>) &amp;&amp;</span><br><span class="line">               (kernelY.cols == <span class="number">1</span> || kernelY.rows == <span class="number">1</span>) );</span><br><span class="line"></span><br><span class="line">    Mat contKernelX = kernelX.isContinuous() ? kernelX : kernelX.clone();</span><br><span class="line">    Mat contKernelY = kernelY.isContinuous() ? kernelY : kernelY.clone();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	生成一个二维滤波(filter2D)引擎</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Ptr&lt;hal::SepFilter2D&gt; c = hal::SepFilter2D::create(</span><br><span class="line">        src.type(), dst.type(), kernelX.type(),</span><br><span class="line">        contKernelX.data, </span><br><span class="line">        kernelX.cols + kernelX.rows - <span class="number">1</span>,</span><br><span class="line">        contKernelY.data, </span><br><span class="line">        kernelY.cols + kernelY.rows - <span class="number">1</span>,</span><br><span class="line">        anchor.x, </span><br><span class="line">        anchor.y, </span><br><span class="line">        delta, </span><br><span class="line">        borderType &amp; ~BORDER_ISOLATED);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	调用这个引擎</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c-&gt;apply(src.data, src.<span class="built_in">step</span>, dst.data, dst.<span class="built_in">step</span>, dst.cols, dst.rows, wsz.<span class="built_in">width</span>, wsz.<span class="built_in">height</span>, ofs.x, ofs.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的便是寻找到这个引擎跟调用函数的实现了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Ptr类似于boost::shared_ptr，它是Boost库的一部分</span></span><br><span class="line"><span class="comment">	(http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm)</span></span><br><span class="line"><span class="comment">	和 std::shared_ptr[C ++ 11标准]（http://en.wikipedia.org/wiki/C++11）</span></span><br><span class="line"><span class="comment">	P.S.其实大部分c++11标准都是boost库里面抄过来的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Ptr&lt;SepFilter2D&gt; <span class="title">SepFilter2D::create</span><span class="params">(<span class="keyword">int</span> stype, <span class="keyword">int</span> dtype, <span class="keyword">int</span> ktype,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     uchar * kernelx_data, <span class="keyword">int</span> kernelx_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     uchar * kernely_data, <span class="keyword">int</span> kernely_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> anchor_x, <span class="keyword">int</span> anchor_y, <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ReplacementSepFilter * impl = <span class="keyword">new</span> ReplacementSepFilter();</span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;init(stype, dtype, ktype,</span><br><span class="line">                       kernelx_data, kernelx_len,</span><br><span class="line">                       kernely_data, kernely_len,</span><br><span class="line">                       anchor_x, anchor_y, delta, borderType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ptr&lt;hal::SepFilter2D&gt;(impl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> impl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        OcvSepFilter * impl = <span class="keyword">new</span> OcvSepFilter();</span><br><span class="line">        impl-&gt;init(stype, dtype, ktype,</span><br><span class="line">                   kernelx_data, kernelx_len,</span><br><span class="line">                   kernely_data, kernely_len,</span><br><span class="line">                   anchor_x, anchor_y, delta, borderType);</span><br><span class="line">        <span class="keyword">return</span> Ptr&lt;hal::SepFilter2D&gt;(impl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经查找，<code>SepFilter2D</code>是一个结构体，内含有上面的create函数以及两个虚函数(apply与析构函数)，这就说明对于不同的impl有着不同的apply跟init。</p><p>然后，从<code>ReplacementSepFilter</code>的函数开始看起:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这个结构体继承自SepFilter2D</span></span><br><span class="line"><span class="comment">	具体作用便是使用hal api进行优化加速计算</span></span><br><span class="line"><span class="comment">	是一个关于移动和嵌入式设计的库</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReplacementSepFilter</span> :</span> <span class="keyword">public</span> hal::SepFilter2D</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		这里的cvhalFilter2D是一个结构体</span></span><br><span class="line"><span class="comment">		其目的就是作为context变量使用(ctx 便是context简写)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    cvhalFilter2D *ctx;</span><br><span class="line">    <span class="keyword">bool</span> isInitialized;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	委托构造函数 委托了两个构造函数进行构造</span></span><br><span class="line"><span class="comment">    	一个是定义了context为0，另一个则是定义了isInitialized为否</span></span><br><span class="line"><span class="comment">    	关于context(上下文)这个概念可以百度一下</span></span><br><span class="line"><span class="comment">    	在下是看的这篇:</span></span><br><span class="line"><span class="comment">    	https://wanderinghorse.net/computing/papers/context_types.html</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ReplacementSepFilter() : ctx(<span class="number">0</span>), isInitialized(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	初始化函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> stype, <span class="keyword">int</span> dtype, <span class="keyword">int</span> ktype,</span></span></span><br><span class="line"><span class="function"><span class="params">              uchar * kernelx_data, <span class="keyword">int</span> kernelx_len,</span></span></span><br><span class="line"><span class="function"><span class="params">              uchar * kernely_data, <span class="keyword">int</span> kernely_len,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> anchor_x, <span class="keyword">int</span> anchor_y, <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里返回的值根据是否初始化成功赋值的</span></span><br><span class="line">        <span class="keyword">int</span> res = cv_hal_sepFilterInit(&amp;ctx, stype, dtype, ktype,</span><br><span class="line">                                       kernelx_data, kernelx_len,</span><br><span class="line">                                       kernely_data, kernely_len,</span><br><span class="line">                                       anchor_x, anchor_y, delta, borderType);</span><br><span class="line">        <span class="comment">// 这里首先判断res是否与CV_HAL_ERROR_OK(0)相等</span></span><br><span class="line">        <span class="comment">// 如果不相等便将0赋值给isInitialized</span></span><br><span class="line">        <span class="comment">// 否则便是将1赋值</span></span><br><span class="line">        isInitialized = (res == CV_HAL_ERROR_OK);</span><br><span class="line">        <span class="keyword">return</span> isInitialized;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	这个是ReplacementSepFilter的执行函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(uchar* src_data, <span class="keyword">size_t</span> src_step, uchar* dst_data, <span class="keyword">size_t</span></span></span></span><br><span class="line"><span class="function"><span class="params">    dst_step, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> full_width, <span class="keyword">int</span> full_height,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> offset_x, <span class="keyword">int</span> offset_y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInitialized)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 这里是调用并返回是否成功的结果</span></span><br><span class="line">            <span class="keyword">int</span> res = cv_hal_sepFilter(ctx, src_data, src_step, dst_data,</span><br><span class="line">            dst_step, <span class="built_in">width</span>, <span class="built_in">height</span>, full_width,</span><br><span class="line">            full_height, offset_x, offset_y);</span><br><span class="line">            <span class="comment">// 判断res是否与CV_HAL_ERROR_OK(0)不等</span></span><br><span class="line">            <span class="comment">// 如果不等便无法调用</span></span><br><span class="line">            <span class="comment">// 进入错误选项跳出滤波器</span></span><br><span class="line">            <span class="keyword">if</span> (res != CV_HAL_ERROR_OK)</span><br><span class="line">                CV_Error(Error::StsNotImplemented, <span class="string">"Failed to run HAL sepFilter implementation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	这里的析构函数在本篇不解析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ~ReplacementSepFilter()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInitialized)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = cv_hal_sepFilterFree(ctx);</span><br><span class="line">            <span class="keyword">if</span> (res != CV_HAL_ERROR_OK)</span><br><span class="line">                CV_Error(Error::StsNotImplemented, <span class="string">"Failed to run HAL sepFilter implementation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在接下来便是<code>OcvSepFilter</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OcvSepFilter</span> :</span> <span class="keyword">public</span> hal::SepFilter2D</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		建立一个滤波引擎 f</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    Ptr&lt;FilterEngine&gt; f;</span><br><span class="line">    <span class="keyword">int</span> src_type;</span><br><span class="line">    <span class="keyword">int</span> dst_type;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> stype, <span class="keyword">int</span> dtype, <span class="keyword">int</span> ktype,</span></span></span><br><span class="line"><span class="function"><span class="params">              uchar * kernelx_data, <span class="keyword">int</span> kernelx_len,</span></span></span><br><span class="line"><span class="function"><span class="params">              uchar * kernely_data, <span class="keyword">int</span> kernely_len,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> anchor_x, <span class="keyword">int</span> anchor_y, <span class="keyword">double</span> delta, <span class="keyword">int</span> borderType)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        src_type = stype;</span><br><span class="line">        dst_type = dtype;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	分离卷积所以建立了X与Y的卷积内核</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function">Mat <span class="title">kernelX</span><span class="params">(Size(kernelx_len, <span class="number">1</span>), ktype, kernelx_data)</span></span>;</span><br><span class="line">        <span class="function">Mat <span class="title">kernelY</span><span class="params">(Size(kernely_len, <span class="number">1</span>), ktype, kernely_data)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	创建一个创建可分离的线性滤波器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        f = createSeparableLinearFilter( stype, dtype, kernelX, kernelY,</span><br><span class="line">                                         Point(anchor_x, anchor_y),</span><br><span class="line">                                         delta, borderType &amp; ~BORDER_ISOLATED );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(uchar* src_data, <span class="keyword">size_t</span> src_step, uchar* dst_data, <span class="keyword">size_t</span> </span></span></span><br><span class="line"><span class="function"><span class="params">    dst_step, nt <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> full_width, <span class="keyword">int</span> full_height,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> offset_x, <span class="keyword">int</span> offset_y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Mat <span class="title">src</span><span class="params">(Size(<span class="built_in">width</span>, <span class="built_in">height</span>), src_type, src_data, src_step)</span></span>;</span><br><span class="line">        <span class="function">Mat <span class="title">dst</span><span class="params">(Size(<span class="built_in">width</span>, <span class="built_in">height</span>), dst_type, dst_data, dst_step)</span></span>;</span><br><span class="line">        <span class="comment">// 因为Ptr将模板设置为了FilterEngine，所以这里apply调用的是FilterEngine的启动函数</span></span><br><span class="line">        f-&gt;apply(src, dst, Size(full_width, full_height), Point(offset_x,</span><br><span class="line">        offset_y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后便是分析<code>createSeparableLinearFilter</code> 这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	可以看到其返回的是是一个引擎，</span></span><br><span class="line"><span class="comment">	所以里面肯定是有横向与纵向线性滤波器了(所以才使用可分离的qwq)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">cv::Ptr&lt;cv::FilterEngine&gt; <span class="title">cv::createSeparableLinearFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> _srcType, <span class="keyword">int</span> _dstType,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray __rowKernel, InputArray __columnKernel,</span></span></span><br><span class="line"><span class="function"><span class="params">    Point _anchor, <span class="keyword">double</span> _delta,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> _rowBorderType, <span class="keyword">int</span> _columnBorderType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Scalar&amp; _borderValue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    Mat _rowKernel = __rowKernel.getMat(), </span><br><span class="line">    _columnKernel = __columnKernel.getMat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求矩阵的数组类型，数据类型包过通道数，深度，和据类型3种</span></span><br><span class="line">    _srcType = CV_MAT_TYPE(_srcType); </span><br><span class="line">    _dstType = CV_MAT_TYPE(_dstType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求深度(输入输出都求)</span></span><br><span class="line">    <span class="keyword">int</span> sdepth = CV_MAT_DEPTH(_srcType),</span><br><span class="line">    ddepth = CV_MAT_DEPTH(_dstType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求输入矩阵的通道数并判断输入矩阵是否与输出矩阵通道数相等</span></span><br><span class="line">    <span class="keyword">int</span> cn = CV_MAT_CN(_srcType);</span><br><span class="line">    CV_Assert( cn == CV_MAT_CN(_dstType) );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rowsize</span></span><br><span class="line">    <span class="keyword">int</span> rsize = _rowKernel.rows + _rowKernel.cols - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// columnsize</span></span><br><span class="line">    <span class="keyword">int</span> csize = _columnKernel.rows + _columnKernel.cols - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果内核锚点是负数，则从中心点开始进行</span></span><br><span class="line">    <span class="keyword">if</span>( _anchor.x &lt; <span class="number">0</span> )</span><br><span class="line">        _anchor.x = rsize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>( _anchor.y &lt; <span class="number">0</span> )</span><br><span class="line">        _anchor.y = csize/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	获得内核的类型</span></span><br><span class="line"><span class="comment">    	大致分为五种：</span></span><br><span class="line"><span class="comment">    	KERNEL_GENERAL 通用内核 无任何对称性或其他属性</span></span><br><span class="line"><span class="comment">    	KERNEL_SYMMETRICAL kernel[i] == kernel[ksize-i-1] (系数对称)，且锚点位于中心</span></span><br><span class="line"><span class="comment">    	KERNEL_ASYMMETRICAL kernel[i] == -kernel[ksize-i-1] (系数相反对称)，锚点同上</span></span><br><span class="line"><span class="comment">    	KERNEL_SMOOTH  所有内核元素都是非负的并且总和为1</span></span><br><span class="line"><span class="comment">    	KERNEL_INTEGER 所有内核系数都是整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> rtype = getKernelType(_rowKernel,</span><br><span class="line">        _rowKernel.rows == <span class="number">1</span> ? Point(_anchor.x, <span class="number">0</span>) : Point(<span class="number">0</span>, _anchor.x));</span><br><span class="line">    <span class="keyword">int</span> ctype = getKernelType(_columnKernel,</span><br><span class="line">        _columnKernel.rows == <span class="number">1</span> ? Point(_anchor.y, <span class="number">0</span>) : Point(<span class="number">0</span>, _anchor.y));</span><br><span class="line">    Mat rowKernel, columnKernel;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	在CV_32F, sdepth, ddepth中找到最大值并赋值给bdepth</span></span><br><span class="line"><span class="comment">    	bdepth: 位深度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> bdepth = <span class="built_in">std</span>::<span class="built_in">max</span>(CV_32F,<span class="built_in">std</span>::<span class="built_in">max</span>(sdepth, ddepth));</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	判断如果</span></span><br><span class="line"><span class="comment">    	输入输出图像都是8位无符号型且内核使用平滑对称核</span></span><br><span class="line"><span class="comment">    	或者</span></span><br><span class="line"><span class="comment">    	输出图像为16位有符号型且使用整形对称或反对称核</span></span><br><span class="line"><span class="comment">    	那么就不需要进行任何转换便可以直接使用，</span></span><br><span class="line"><span class="comment">    	否则便需要转换，因为输入前后的图像格式是完全相等的</span></span><br><span class="line"><span class="comment">    	所以delta就默认是0了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>( sdepth == CV_8U &amp;&amp;</span><br><span class="line">        (</span><br><span class="line">             (rtype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp;</span><br><span class="line">              ctype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp;</span><br><span class="line">              ddepth == CV_8U) </span><br><span class="line">             ||</span><br><span class="line">             (</span><br><span class="line">                  (rtype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp;</span><br><span class="line">                  (ctype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp;</span><br><span class="line">                  (rtype &amp; ctype &amp; KERNEL_INTEGER) &amp;&amp;</span><br><span class="line">                  ddepth == CV_16S</span><br><span class="line">             )</span><br><span class="line">        ) </span><br><span class="line">      )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 重新给bdepth赋值</span></span><br><span class="line">        bdepth = CV_32S;</span><br><span class="line">        <span class="comment">// 此时bits(单位字节)将根据位深度进行计算，如果是8位无符号型则直接赋值为8位</span></span><br><span class="line">        bits = ddepth == CV_8U ? <span class="number">8</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 此时将row内核转换为CV_32S，即32位整数型，并且根据单位字节转换比例因子</span></span><br><span class="line">        <span class="comment">// 如果不加比例因子那么图像会变得很白</span></span><br><span class="line">        <span class="comment">// (可参见这篇提问https://bbs.csdn.net/topics/392411554)</span></span><br><span class="line">        <span class="comment">// 比例因子：将原矩阵的所有元素乘以alpha</span></span><br><span class="line">        _rowKernel.convertTo( rowKernel, CV_32S, <span class="number">1</span> &lt;&lt; bits );</span><br><span class="line">        _columnKernel.convertTo( columnKernel, CV_32S, <span class="number">1</span> &lt;&lt; bits );</span><br><span class="line">        <span class="comment">// 在这里是将单位字节*2</span></span><br><span class="line">        bits *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 根据单位字节计算出了存储单位(偏移量)</span></span><br><span class="line">        _delta *= (<span class="number">1</span> &lt;&lt; bits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	如果不属于上面if里的任何一种情况，那么需要进行转换，用以使数据类型统一</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>( _rowKernel.type() != bdepth )</span><br><span class="line">            _rowKernel.convertTo( rowKernel, bdepth );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rowKernel = _rowKernel;</span><br><span class="line">        <span class="keyword">if</span>( _columnKernel.type() != bdepth )</span><br><span class="line">            _columnKernel.convertTo( columnKernel, bdepth );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            columnKernel = _columnKernel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区存储，用于写入单个色所有素信息(包括多通道与深度信息)</span></span><br><span class="line">    <span class="keyword">int</span> _bufType = CV_MAKETYPE(bdepth, cn);</span><br><span class="line">    <span class="comment">// getLinearRowFilter是根据不同的输入图像类型，输出图像返回不同的线性滤波器</span></span><br><span class="line">    Ptr&lt;BaseRowFilter&gt; _rowFilter = getLinearRowFilter(</span><br><span class="line">        _srcType, _bufType, rowKernel, _anchor.x, rtype);</span><br><span class="line">    Ptr&lt;BaseColumnFilter&gt; _columnFilter = getLinearColumnFilter(</span><br><span class="line">        _bufType, _dstType, columnKernel, _anchor.y, ctype, _delta, bits );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用这两个线性滤波器建立滤波引擎</span></span><br><span class="line">    <span class="keyword">return</span> Ptr&lt;FilterEngine&gt;( <span class="keyword">new</span> FilterEngine(Ptr&lt;BaseFilter&gt;(), _rowFilter,</span><br><span class="line">                                               _columnFilter,_srcType, _dstType,</span><br><span class="line">                                               _bufType, _rowBorderType,</span><br><span class="line">                                               _columnBorderType, _borderValue ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	建立滤波引擎函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">FilterEngine::FilterEngine( <span class="keyword">const</span> Ptr&lt;BaseFilter&gt;&amp; _filter2D,</span><br><span class="line">                            <span class="keyword">const</span> Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter,</span><br><span class="line">                            <span class="keyword">const</span> Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter,</span><br><span class="line">                            <span class="keyword">int</span> _srcType, <span class="keyword">int</span> _dstType, <span class="keyword">int</span> _bufType,</span><br><span class="line">                            <span class="keyword">int</span> _rowBorderType, <span class="keyword">int</span> _columnBorderType,</span><br><span class="line">                            <span class="keyword">const</span> Scalar&amp; _borderValue )</span><br><span class="line">&#123;</span><br><span class="line">    init(_filter2D, _rowFilter, _columnFilter, _srcType, _dstType, _bufType,</span><br><span class="line">         _rowBorderType, _columnBorderType, _borderValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterEngine::init</span><span class="params">( <span class="keyword">const</span> Ptr&lt;BaseFilter&gt;&amp; _filter2D,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> _srcType, <span class="keyword">int</span> _dstType, <span class="keyword">int</span> _bufType,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> _rowBorderType, <span class="keyword">int</span> _columnBorderType,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Scalar&amp; _borderValue )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 依旧是获取类型</span></span><br><span class="line">    _srcType = CV_MAT_TYPE(_srcType);</span><br><span class="line">    _bufType = CV_MAT_TYPE(_bufType);</span><br><span class="line">    _dstType = CV_MAT_TYPE(_dstType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 临时变量</span></span><br><span class="line">    srcType = _srcType;</span><br><span class="line">    <span class="comment">// 计算单个像素大小</span></span><br><span class="line">    <span class="comment">// 下面会降解</span></span><br><span class="line">    <span class="keyword">int</span> srcElemSize = (<span class="keyword">int</span>)getElemSize(srcType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这些全是建立临时变量的</span></span><br><span class="line">    dstType = _dstType;</span><br><span class="line">    bufType = _bufType;</span><br><span class="line"></span><br><span class="line">    filter2D = _filter2D;</span><br><span class="line">    rowFilter = _rowFilter;</span><br><span class="line">    columnFilter = _columnFilter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是判断行列边缘类型是否出问题</span></span><br><span class="line">    <span class="keyword">if</span>( _columnBorderType &lt; <span class="number">0</span> )</span><br><span class="line">        _columnBorderType = _rowBorderType;</span><br><span class="line"></span><br><span class="line">    rowBorderType = _rowBorderType;</span><br><span class="line">    columnBorderType = _columnBorderType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测边界填充类型是否不是wrap(复制元素填充)类型</span></span><br><span class="line">    CV_Assert( columnBorderType != BORDER_WRAP );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测是否为可分离滤波器(因为这个是通用滤波引擎 并不知道是否为可分离滤波器)</span></span><br><span class="line">    <span class="keyword">if</span>( isSeparable() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测横纵滤波器类型是否相等</span></span><br><span class="line">        CV_Assert( rowFilter &amp;&amp; columnFilter );</span><br><span class="line">        <span class="comment">// 并以横纵滤波器定义内核大小</span></span><br><span class="line">        ksize = Size(rowFilter-&gt;ksize, columnFilter-&gt;ksize);</span><br><span class="line">        <span class="comment">// 锚点也根据滤波器锚点定义</span></span><br><span class="line">        anchor = Point(rowFilter-&gt;anchor, columnFilter-&gt;anchor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是  检测缓冲图像类型是否与输入图像类型相等</span></span><br><span class="line">        CV_Assert( bufType == srcType );</span><br><span class="line">        <span class="comment">// 这里跟上面定义差不多，不过是非分离滤波器所以是只有一个(filter2D二维滤波器)</span></span><br><span class="line">        ksize = filter2D-&gt;ksize;</span><br><span class="line">        anchor = filter2D-&gt;anchor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个一看就懂了</span></span><br><span class="line">    CV_Assert( m <span class="number">0</span> &lt;= anchor.x &amp;&amp; anchor.x &lt; ksize.<span class="built_in">width</span> &amp;&amp;</span><br><span class="line">               <span class="number">0</span> &lt;= anchor.y &amp;&amp; anchor.y &lt; ksize.<span class="built_in">height</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据边缘填充类型进行像素计算</span></span><br><span class="line">    borderElemSize = srcElemSize/(CV_MAT_DEPTH(srcType) &gt;= CV_32S ?</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">int</span>) : <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里也很好懂</span></span><br><span class="line">    <span class="keyword">int</span> borderLength = <span class="built_in">std</span>::<span class="built_in">max</span>(ksize.<span class="built_in">width</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重定义边缘向量大小(这里是所占空间大小)</span></span><br><span class="line">    borderTab.resize(borderLength*borderElemSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    maxWidth = bufStep = <span class="number">0</span>;</span><br><span class="line">    constBorderRow.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果行列边界是常数填充的</span></span><br><span class="line">    <span class="keyword">if</span>( rowBorderType == BORDER_CONSTANT || columnBorderType == BORDER_CONSTANT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 则计算图像边长</span></span><br><span class="line">        constBorderValue.resize(srcElemSize*borderLength);</span><br><span class="line">        <span class="keyword">int</span> srcType1 = CV_MAKETYPE(CV_MAT_DEPTH(srcType), </span><br><span class="line">                                   MIN(CV_MAT_CN(srcType),</span><br><span class="line">                                   <span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 根据位深度将边界像素值转换成可直接使用的vector变量</span></span><br><span class="line">        scalarToRawData(_borderValue, &amp;constBorderValue[<span class="number">0</span>], srcType1,</span><br><span class="line">                        borderLength*CV_MAT_CN(srcType));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化size</span></span><br><span class="line">    wholeSize = Size(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这时候来看上面提到的<code>getElemSize</code>:</p><blockquote><p>最终这个其实是个宏定义，返回的就是这个宏定义计算的结果：</p><p><strong>(CV_MAT_CN(type) &lt;&lt; ((((sizeof(size_t)/4+1)*16384|0x3a50) &gt;&gt; CV_MAT_DEPTH(type)*2) &amp; 3))</strong></p><p>首先，针对<code>0x3a50</code>这个奇怪的数值，我们先转换为2进制查看规律，通过查找比对，发现其数值与变量类型有着一一对应的关系，然后16384则是1 &lt;&lt; 14的结果(刚好每个对应两位二进制数值)，这个换成二进制则是</p><p>​ 16384 = 10 00 00 00 00 00 00</p><p>​ 0x3a50 = 11 10 10 01 01 00 00</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/bin.png" alt="1" title=""></div><div class="image-caption">1</div></figure><p>稍微先理解一下，在下先说一下剩下的函数然后一起解析。</p><p>这里先计算无符号整型的长度(在64位系统下是4 desu)然后除以4 再加上1 ，</p><p>就是说这是2 * 16384 | 0x3a50</p><p>就是</p><p>01 00 00 00 00 00 00 00</p><p>00 11 10 10 01 01 00 00</p><hr><p>01 11 10 10 01 01 00 00</p><p>的结果右移2 * 深度，观察上面便会发现最终右移之后便使得最后两位二进制数对应的刚好便是对应变量类型所占的二进制数。</p><p>这样，在跟3(二进制为11)进行 ‘与‘ 操作，便能得到各个变量的对应所占字节数的对数了。</p><p>又因为这里是 通道数 * 2 ^ (所占字节对数)</p><p>所以这样就能够计算的出单个像素点所占用的大小(size)了</p></blockquote><p>因为滤波引擎是一个通用引擎，还可用以驱动其他的滤波器(中值滤波或者其他什么的)所以主要的就只不过是根据一些信息初始化用以后面的操作(就是init函数的意思)。</p><p>返回了滤波引擎之后便是调用了，这个是<code>apply</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterEngine::apply</span><span class="params">(<span class="keyword">const</span> Mat&amp; src, Mat&amp; dst, <span class="keyword">const</span> Size &amp; wsz, <span class="keyword">const</span> Point &amp; ofs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_INSTRUMENT_REGION()</span><br><span class="line"></span><br><span class="line">    CV_Assert( src.type() == srcType &amp;&amp; dst.type() == dstType );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回变化y值</span></span><br><span class="line">    <span class="keyword">int</span> y = start(src, wsz, ofs);</span><br><span class="line">    <span class="comment">// 传参的时候切除第一行与最后一列</span></span><br><span class="line">    proceed(src.ptr() + y*src.<span class="built_in">step</span>,</span><br><span class="line">            (<span class="keyword">int</span>)src.<span class="built_in">step</span>,</span><br><span class="line">            endY - startY,</span><br><span class="line">            dst.ptr(),</span><br><span class="line">            (<span class="keyword">int</span>)dst.<span class="built_in">step</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>start</code>便是开始函数后面的<code>proceed</code>则是持续卷积到整个图像的关键，<code>start</code>函数最终返回了起始的Y值，一句一句写太累了，我就不解释了，只贴出<code>start</code>与<code>proceed</code>函数：</p><p>*<em>这两块其实在下分析的很差，很多函数都没看懂，有很大可能错误，建议先跳过，在下以后c++学透了还会回来改的。 *</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	滤波引擎</span></span><br><span class="line"><span class="comment">	发动！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FilterEngine::start</span><span class="params">(<span class="keyword">const</span> Mat&amp; src, <span class="keyword">const</span> Size &amp;wsz, <span class="keyword">const</span> Point &amp;ofs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start( wsz, src.<span class="built_in">size</span>(), ofs);</span><br><span class="line">    <span class="keyword">return</span> startY - ofs.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FilterEngine::start</span><span class="params">(<span class="keyword">const</span> Size &amp;_wholeSize, <span class="keyword">const</span> Size &amp;sz, <span class="keyword">const</span> Point &amp;ofs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    wholeSize = _wholeSize;</span><br><span class="line">    <span class="comment">// 根据偏移量与矩阵头设置范围</span></span><br><span class="line">    roi = Rect(ofs, sz);</span><br><span class="line">    <span class="comment">// 依旧是错误检测，很好懂</span></span><br><span class="line">    CV_Assert( roi.x &gt;= <span class="number">0</span> &amp;&amp; roi.y &gt;= <span class="number">0</span> &amp;&amp; roi.<span class="built_in">width</span> &gt;= <span class="number">0</span> &amp;&amp; roi.<span class="built_in">height</span> &gt;= <span class="number">0</span> &amp;&amp; roi.x + roi.<span class="built_in">width</span> &lt;= wholeSize.<span class="built_in">width</span> &amp;&amp; roi.y + roi.<span class="built_in">height</span> &lt;= wholeSize.<span class="built_in">height</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这些依旧是初始化</span></span><br><span class="line">    <span class="keyword">int</span> esz = (<span class="keyword">int</span>)getElemSize(srcType);</span><br><span class="line">    <span class="keyword">int</span> bufElemSize = (<span class="keyword">int</span>)getElemSize(bufType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定值检查</span></span><br><span class="line">    <span class="keyword">const</span> uchar* constVal = !constBorderValue.empty() ? &amp;constBorderValue[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> _maxBufRows = <span class="built_in">std</span>::<span class="built_in">max</span>(ksize.<span class="built_in">height</span> + <span class="number">3</span>, <span class="built_in">std</span>::<span class="built_in">max</span>(anchor.y, ksize.<span class="built_in">height</span>-anchor.y<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( maxWidth &lt; roi.<span class="built_in">width</span> || _maxBufRows != (<span class="keyword">int</span>)rows.<span class="built_in">size</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        rows.resize(_maxBufRows);</span><br><span class="line">        maxWidth = <span class="built_in">std</span>::<span class="built_in">max</span>(maxWidth, roi.<span class="built_in">width</span>);</span><br><span class="line">        <span class="keyword">int</span> cn = CV_MAT_CN(srcType);</span><br><span class="line">        srcRow.resize(esz*(maxWidth + ksize.<span class="built_in">width</span> - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( columnBorderType == BORDER_CONSTANT )</span><br><span class="line">        &#123;</span><br><span class="line">            constBorderRow.resize(getElemSize(bufType)</span><br><span class="line">                                  *(maxWidth + ksize.<span class="built_in">width</span> - <span class="number">1</span> + VEC_ALIGN));</span><br><span class="line">            uchar *dst = alignPtr(&amp;constBorderRow[<span class="number">0</span>], VEC_ALIGN), *tdst;</span><br><span class="line">            <span class="keyword">int</span> n = (<span class="keyword">int</span>)constBorderValue.<span class="built_in">size</span>(), N;</span><br><span class="line">            N = (maxWidth + ksize.<span class="built_in">width</span> - <span class="number">1</span>)*esz;</span><br><span class="line">            tdst = isSeparable() ? &amp;srcRow[<span class="number">0</span>] : dst;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i += n )</span><br><span class="line">            &#123;</span><br><span class="line">                n = <span class="built_in">std</span>::<span class="built_in">min</span>( n, N - i );</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    tdst[i+j] = constVal[j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( isSeparable() )</span><br><span class="line">                (*rowFilter)(&amp;srcRow[<span class="number">0</span>], dst, maxWidth, cn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxBufStep = bufElemSize*(<span class="keyword">int</span>)alignSize(maxWidth + (!isSeparable() ? ksize.<span class="built_in">width</span> - <span class="number">1</span> : <span class="number">0</span>),VEC_ALIGN);</span><br><span class="line">        ringBuf.resize(maxBufStep*rows.<span class="built_in">size</span>()+VEC_ALIGN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整bufstep，使环形缓冲区的已使用部分在内存中保持紧凑</span></span><br><span class="line">    bufStep = bufElemSize*(<span class="keyword">int</span>)alignSize(roi.<span class="built_in">width</span> + (!isSeparable() ? ksize.<span class="built_in">width</span> - <span class="number">1</span> : <span class="number">0</span>),<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dx1是检测锚点位置是否与范围边界检测</span></span><br><span class="line">    dx1 = <span class="built_in">std</span>::<span class="built_in">max</span>(anchor.x - roi.x, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检测内核是否存在偏差</span></span><br><span class="line">    dx2 = <span class="built_in">std</span>::<span class="built_in">max</span>(ksize.<span class="built_in">width</span> - anchor.x - <span class="number">1</span> + roi.x + roi.<span class="built_in">width</span> - wholeSize.<span class="built_in">width</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在偏差则重新计算边界表</span></span><br><span class="line">    <span class="keyword">if</span>( dx1 &gt; <span class="number">0</span> || dx2 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( rowBorderType == BORDER_CONSTANT )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nr = isSeparable() ? <span class="number">1</span> : (<span class="keyword">int</span>)rows.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; nr; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                uchar* dst = isSeparable() ? &amp;srcRow[<span class="number">0</span>] : alignPtr(&amp;ringBuf[<span class="number">0</span>],VEC_ALIGN) + bufStep*i;</span><br><span class="line">                <span class="comment">// 在内存中用后者填充前者，最后一个参数是大小</span></span><br><span class="line">                <span class="built_in">memcpy</span>( dst, constVal, dx1*esz );</span><br><span class="line">                <span class="built_in">memcpy</span>( dst + (roi.<span class="built_in">width</span> + ksize.<span class="built_in">width</span> - <span class="number">1</span> - dx2)*esz, constVal, dx2*esz );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xofs1 = <span class="built_in">std</span>::<span class="built_in">min</span>(roi.x, anchor.x) - roi.x;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> btab_esz = borderElemSize, wholeWidth = wholeSize.<span class="built_in">width</span>;</span><br><span class="line">            <span class="keyword">int</span>* btab = (<span class="keyword">int</span>*)&amp;borderTab[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; dx1; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p0 = (borderInterpolate(i-dx1, wholeWidth, rowBorderType) +  xofs1)*btab_esz;</span><br><span class="line">                <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; btab_esz; j++ )</span><br><span class="line">                    btab[i*btab_esz + j] = p0 + j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; dx2; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p0 = (borderInterpolate(wholeWidth + i, wholeWidth,  rowBorderType) + xofs1)*btab_esz;</span><br><span class="line">                <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; btab_esz; j++ )</span><br><span class="line">                    btab[(i + dx1)*btab_esz + j] = p0 + j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rowCount = dstY = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	这整个函数其实最重要的就是这个</span></span><br><span class="line"><span class="comment">    	上面这些都是防止错误进行的调整</span></span><br><span class="line"><span class="comment">    	并用以计算下面这个值的</span></span><br><span class="line"><span class="comment">    	这个startY是另一方向的偏离值，就是说一个像素到另一个像素的偏离量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startY = startY0 = <span class="built_in">std</span>::<span class="built_in">max</span>(roi.y - anchor.y, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    endY = <span class="built_in">std</span>::<span class="built_in">min</span>(roi.y + roi.<span class="built_in">height</span> + ksize.<span class="built_in">height</span> - anchor.y - <span class="number">1</span>, 								wholeSize.<span class="built_in">height</span>);</span><br><span class="line">    <span class="keyword">if</span>( columnFilter )</span><br><span class="line">        columnFilter-&gt;reset();</span><br><span class="line">    <span class="keyword">if</span>( filter2D )</span><br><span class="line">        filter2D-&gt;reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FilterEngine::proceed</span><span class="params">( <span class="keyword">const</span> uchar* src, <span class="keyword">int</span> srcstep, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                           uchar* dst, <span class="keyword">int</span> dststep )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_Assert( wholeSize.<span class="built_in">width</span> &gt; <span class="number">0</span> &amp;&amp; wholeSize.<span class="built_in">height</span> &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *btab = &amp;borderTab[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> esz = (<span class="keyword">int</span>)getElemSize(srcType), btab_esz = borderElemSize;</span><br><span class="line">    uchar** brows = &amp;rows[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> bufRows = (<span class="keyword">int</span>)rows.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cn = CV_MAT_CN(bufType);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span> = roi.<span class="built_in">width</span>, kwidth = ksize.<span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> kheight = ksize.<span class="built_in">height</span>, ay = anchor.y;</span><br><span class="line">    <span class="keyword">int</span> _dx1 = dx1, _dx2 = dx2;</span><br><span class="line">    <span class="keyword">int</span> width1 = roi.<span class="built_in">width</span> + kwidth - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> xofs1 = <span class="built_in">std</span>::<span class="built_in">min</span>(roi.x, anchor.x);</span><br><span class="line">    <span class="keyword">bool</span> isSep = isSeparable();</span><br><span class="line">    <span class="keyword">bool</span> makeBorder = (_dx1 &gt; <span class="number">0</span> || _dx2 &gt; <span class="number">0</span>) &amp;&amp; rowBorderType != BORDER_CONSTANT;</span><br><span class="line">    <span class="keyword">int</span> dy = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    src -= xofs1*esz;</span><br><span class="line">    count = <span class="built_in">std</span>::<span class="built_in">min</span>(count, remainingInputRows());</span><br><span class="line"></span><br><span class="line">    CV_Assert( src &amp;&amp; dst &amp;&amp; count &gt; <span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	这里就是卷积的主函数了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(;; dst += dststep*i, dy += i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dcount = bufRows - ay - startY - rowCount + roi.y;</span><br><span class="line">        dcount = dcount &gt; <span class="number">0</span> ? dcount : bufRows - kheight + <span class="number">1</span>;</span><br><span class="line">        dcount = <span class="built_in">std</span>::<span class="built_in">min</span>(dcount, count);</span><br><span class="line">        count -= dcount;</span><br><span class="line">        <span class="keyword">for</span>( ; dcount-- &gt; <span class="number">0</span>; src += srcstep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bi = (startY - startY0 + rowCount) % bufRows;</span><br><span class="line">            uchar* brow = alignPtr(&amp;ringBuf[<span class="number">0</span>], VEC_ALIGN) + bi*bufStep;</span><br><span class="line">            uchar* row = isSep ? &amp;srcRow[<span class="number">0</span>] : brow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( ++rowCount &gt; bufRows )</span><br><span class="line">            &#123;</span><br><span class="line">                --rowCount;</span><br><span class="line">                ++startY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( row + _dx1*esz, src, (width1 - _dx2 - _dx1)*esz );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( makeBorder )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( btab_esz*(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == esz )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span>* isrc = (<span class="keyword">const</span> <span class="keyword">int</span>*)src;</span><br><span class="line">                    <span class="keyword">int</span>* irow = (<span class="keyword">int</span>*)row;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; _dx1*btab_esz; i++ )</span><br><span class="line">                        irow[i] = isrc[btab[i]];</span><br><span class="line">                    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; _dx2*btab_esz; i++ )</span><br><span class="line">                        irow[i + (width1 - _dx2)*btab_esz] =  isrc[btab[i+_dx1*btab_esz]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; _dx1*esz; i++ )</span><br><span class="line">                        row[i] = src[btab[i]];</span><br><span class="line">                    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; _dx2*esz; i++ )</span><br><span class="line">                        row[i + (width1 - _dx2)*esz] = src[btab[i+_dx1*esz]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( isSep )</span><br><span class="line">                (*rowFilter)(row, brow, <span class="built_in">width</span>, CV_MAT_CN(srcType));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_i = <span class="built_in">std</span>::<span class="built_in">min</span>(bufRows, roi.<span class="built_in">height</span> - (dstY + dy) + (kheight - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; max_i; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> srcY = borderInterpolate(dstY + dy + i + roi.y - ay, wholeSize.<span class="built_in">height</span>, columnBorderType);</span><br><span class="line">            <span class="keyword">if</span>( srcY &lt; <span class="number">0</span> ) <span class="comment">// can happen only with constant border type</span></span><br><span class="line">                brows[i] = alignPtr(&amp;constBorderRow[<span class="number">0</span>], VEC_ALIGN);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CV_Assert( srcY &gt;= startY );</span><br><span class="line">                <span class="keyword">if</span>( srcY &gt;= startY + rowCount )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> bi = (srcY - startY0) % bufRows;</span><br><span class="line">                brows[i] = alignPtr(&amp;ringBuf[<span class="number">0</span>], VEC_ALIGN) + bi*bufStep;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; kheight )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        i -= kheight - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( isSeparable() )</span><br><span class="line">            (*columnFilter)((<span class="keyword">const</span> uchar**)brows, dst, dststep, i, roi.<span class="built_in">width</span>*cn);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (*filter2D)((<span class="keyword">const</span> uchar**)brows, dst, dststep, i, roi.<span class="built_in">width</span>, cn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dstY += dy;</span><br><span class="line">    CV_Assert( dstY &lt;= roi.<span class="built_in">height</span> );</span><br><span class="line">    <span class="keyword">return</span> dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>C++语法复杂度感觉世界上排的了前十</li><li>复杂但却也是少有的可以直接操作内存的语言之一，内联汇编效率不要太高</li><li>用轮子很简单，但是造轮子很难，造出普适性的轮子更难，自己用感觉有些算法还是很容易写的，但是要照顾到大量的其他语法或者平台那就很困难了</li><li>优化不一定是自己算法的优化，还有使用平台的优化，用别人的轮子真的很爽</li><li>大型项目里面代码风格各异，变量命名方案比较混乱，并且简写的比较多，看起来真的头大。。。。</li><li>在下的代码逻辑思维还是太低了，希望能够在毕业的时候看上20000行代码用以提升自己</li><li>相比之下python源码看起来真的舒服死了55555</li></ul><h2 id="借物表"><a href="#借物表" class="headerlink" title="借物表"></a>借物表</h2><ul><li><a href="https://www.cnblogs.com/marvin-notes/p/4482805.html" target="_blank" rel="noopener"><strong>attribute</strong> 机制详解(一)</a></li><li><a href="https://stackoverflow.com/questions/19908922/what-is-this-ifdef-gnuc-about" target="_blank" rel="noopener">What is this #ifdef <strong>GNUC</strong> about?</a></li><li><a href="https://www.cnblogs.com/testlife007/p/8134702.html" target="_blank" rel="noopener">关于VC预定义常量_WIN32，WIN32，_WIN64等预定义宏的介绍（整理、转载）</a></li><li><a href="http://www.voidcn.com/article/p-uolrpafg-bcx.html" target="_blank" rel="noopener">opencv的CV_EXPORT</a></li><li><a href="https://www.cnblogs.com/wangguchangqing/p/6407717.html" target="_blank" rel="noopener">图像处理基础(4)：高斯滤波器详解</a></li><li><a href="https://blog.csdn.net/u012707739/article/details/80170671" target="_blank" rel="noopener">C/C++ 可变参数宏与<strong>VA_ARGS</strong> 宏</a></li><li><a href="https://blog.csdn.net/q2519008/article/details/80934815" target="_blank" rel="noopener">#、##、<strong>VA_ARGS</strong>和##<strong>VA_ARGS</strong>的作用</a></li><li><a href="https://blog.csdn.net/sx1503198/article/details/51764367" target="_blank" rel="noopener">OpenVX嵌入式图像处理（一）硬件平台及软件介绍</a></li><li><a href="https://blog.csdn.net/jia20003/article/details/69802932" target="_blank" rel="noopener">OpenCV3.x中UMat对象介绍与使用</a></li><li><a href="https://blog.csdn.net/qq_26460507/article/details/60154061" target="_blank" rel="noopener">opencv学习之GaussianBlur()源码解析</a></li><li><a href="https://blog.csdn.net/u011028771/article/details/80556457" target="_blank" rel="noopener">手撕OpenCV源码之GaussianBlur</a></li><li><a href="https://www.xuebuyuan.com/1054789.html" target="_blank" rel="noopener">OpenCV的一些宏</a></li></ul><p><strong>感谢以上各位大佬给在下提供的各类知识</strong></p></div><blockquote class="post-copyright"><div class="content"> <span class="post-time">最后更新时间：<time datetime="2020-08-04T06:06:25.039Z" itemprop="dateUpdated">2020-08-04 14:06:25</time></span><br> 如非注明转载，均为本文原创或编译，转载请注明出处。<br>本文链接：<a href="/2019/02/25/gaussianbulr-analyze/" target="_blank" rel="external">http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/</a><br>本文遵循<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div><footer> <a href="http://blog.fivezha.cn"><img src="/img/avatar.png" alt="xmmmmmovo"> xmmmmmovo</a></footer></blockquote><div class="page-reward"> <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cv/" rel="tag">cv</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&title=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&pic=http://blog.fivezha.cn/img/avatar.png" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&title=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&source=因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&via=http://blog.fivezha.cn" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/2019/09/04/play-study-f/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">playframework初涉-1.环境配置</h4></a></div><div class="waves-block waves-effect next"><a href="/2018/10/15/nazo-io-answer/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">nazo.io攻略(完)</h4></a></div></nav><div class="comments vcomment" id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="昵称,邮箱,网址(https://)".split(",").filter(function(a){return-1<GUEST_INFO.indexOf(a)});new Valine({el:"#comments",notify:!0,verify:!1,appId:"55ujxYDQhAADDjyqYIwt1e1e-gzGzoHsz",appKey:"F1sOiWvmQ6AJvItQoKMKFFEd",avatar:"mp",placeholder:"有什么想法都可以写昂~",guest_info:0==guest_info.length?GUEST_INFO:guest_info,pageSize:"15",emojiCDN:"//cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/",emojiMaps:{alu2:"alu/不出所料.png",alu3:"alu/不说话.png",alu4:"alu/不高兴.png",alu5:"alu/中刀.png",alu6:"alu/中指.png",alu7:"alu/中枪.png",alu8:"alu/亲亲.png",alu9:"alu/便便.png",alu10:"alu/内伤.png",alu11:"alu/击掌.png",alu12:"alu/口水.png",alu13:"alu/吐.png",alu14:"alu/吐舌.png",alu15:"alu/吐血倒地.png",alu16:"alu/呲牙.png",alu17:"alu/咽气.png",alu18:"alu/哭泣.png",alu19:"alu/喜极而泣.png",alu20:"alu/喷水.png",alu21:"alu/喷血.png",alu22:"alu/坐等.png",alu23:"alu/害羞.png",alu24:"alu/小眼睛.png",alu25:"alu/尴尬.png",alu26:"alu/得意.png",alu27:"alu/惊喜.png",alu28:"alu/想一想.png",alu29:"alu/愤怒.png",alu30:"alu/扇耳光.png",alu31:"alu/投降.png",alu32:"alu/抠鼻.png",alu33:"alu/抽烟.png",alu34:"alu/无奈.png",alu35:"alu/无所谓.png",alu36:"alu/无语.png",alu37:"alu/暗地观察.png",alu38:"alu/期待.png",alu39:"alu/欢呼.png",alu40:"alu/汗.png",alu41:"alu/深思.png",alu42:"alu/狂汗.png",alu43:"alu/献花.png",alu44:"alu/献黄瓜.png",alu45:"alu/皱眉.png",alu46:"alu/看不见.png",alu47:"alu/看热闹.png",alu48:"alu/瞅你.png",alu49:"alu/肿包.png",alu50:"alu/脸红.png",alu51:"alu/蜡烛.png",alu52:"alu/装大款.png",alu53:"alu/观察.png",alu54:"alu/赞一个.png",alu55:"alu/邪恶.png",alu56:"alu/锁眉.png",alu57:"alu/长草.png",alu58:"alu/阴暗.png",alu59:"alu/高兴.png",alu60:"alu/黑线.png",alu61:"alu/鼓掌.png"}})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 感恩亲人~<i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"> <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码"></div> <label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.png" data-alipay="/img/alipay.png"><div class="reward-toggle-ctrol"> <span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-item switch" id="switvh">切换</span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script src="//unpkg.com/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/clipboard.min.js"></script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/copy.min.js"></script></div><footer class="footer"><div class="top"><p> <span id="busuanzi_container_site_uv" style="display:none">站点总访客数：<span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv" style="display:none">站点总访问量：<span id="busuanzi_value_site_pv"></span></span></p><p> <span>xmmmmmovo &copy; 2017 - 2020</span> <span><a href="http://beian.miit.gov.cn/" target="_blank">鲁ICP备20025683号-1</a><br> Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/xmmmmmovo/indigomod" target="_blank">Indigo</a></span></p></div><div class="bottom"><p><span><a href="/atom.xml" target="_blank" class="rss" title="RSS"><i class="icon icon-lg icon-rss"></i></a></span> <span>内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 协议</a></span></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&title=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&pic=http://blog.fivezha.cn/img/avatar.png" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&title=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&source=因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《opencv中高斯模糊(滤波器)的源码解析(c++版)》 — 异国迷宫的十字路口&url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/&via=http://blog.fivezha.cn" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p> <img src="//api.qrserver.com/v1/create-qr-code/?data=http://blog.fivezha.cn/2019/02/25/gaussianbulr-analyze/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis"> {tags}</div> <time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/xmmmmmovo/indigomod/dist/js/search.min.js" async></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>