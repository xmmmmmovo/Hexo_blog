[{"title":"算法(第四版)笔记(5)---约瑟夫环问题","date":"2020-07-17T09:24:23.000Z","path":"2020/07/17/algorithm4-Josephus/","text":"","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"}]},{"title":"算法(第四版)笔记(4)---Deque,Buffer,4-sum,3-sumfast","date":"2020-07-17T01:36:36.000Z","path":"2020/07/17/algorithm4-1-4/","text":"双向队列和双栈缓冲区的实现 双向队列API image-20200717093114582 实现12345678910111213141516171819202122232425package dsclass Deque&lt;T&gt; : Iterable&lt;T&gt; &#123; private val list = LinkedList&lt;T&gt;() fun isEmpty() = list.size == 0 fun size() = list.size fun pushLeft(element: T) = list.addFirst(element) fun pushRight(element: T) = list.addLast(element) fun popLeft(): T = list.removeFirst() fun popRight(): T = list.removeLast() override fun toString(): String &#123; return list.toString() &#125; override fun iterator(): Iterator&lt;T&gt; &#123; return list.iterator() &#125;&#125; 关于双向链表的实现见这篇博客: 算法(第四版)笔记(3)—双向链表(LinkedList)实现 缓冲区BufferAPI image-20200717093315081 实现12345678910111213141516171819202122232425262728293031323334353637383940package dsclass Buffer &#123; private val ls = Stack&lt;Char&gt;() private val rs = Stack&lt;Char&gt;() fun insert(c: Char) &#123; ls.push(c) &#125; fun delete(): Char = if (ls.size() == 0) throw NoSuchElementException(\"无法删除\") else ls.pop() fun left(k: Int) &#123; if (k &gt; ls.size()) throw IllegalArgumentException(\"无法到达\") for (i in 1..k) &#123; rs.push(ls.pop()) &#125; &#125; fun right(k: Int) &#123; if (k &gt; rs.size()) throw IllegalArgumentException(\"无法到达\") for (i in 1..k) &#123; ls.push(rs.pop()) &#125; &#125; val size: Int get() = ls.size() + rs.size() override fun toString(): String &#123; return StringBuilder().also &#123; it.append(ls) it.reverse() it.append(\" | \") it.append(rs) &#125;.toString() &#125;&#125; 关于栈的实现见这篇博客:算法(第四版)笔记(1)—简单类的实现 测试 image-20200717095951864 image-20200717095958140 四数之和实现123456789101112131415/** * 蛮力法求数字之和 * */fun fourSumForce(list: List&lt;Int&gt;, num: Int): Int &#123; var cnt = 0 for (a in list.indices) for (b in a until list.size) for (c in b until list.size) for (d in c until list.size) if (list[a] + list[b] + list[c] + list[d] == num) &#123; cnt++ &#125; return cnt&#125; 三数之和实现12","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"}]},{"title":"算法(第四版)笔记(3)---双向链表(LinkedList)实现","date":"2020-07-13T11:59:21.000Z","path":"2020/07/13/algorithm4-linkedlist/","text":"根据算法第四版和源码进行的链表实现，主要实现MutableList&lt;T&gt;接口和MutableListIterator&lt;T&gt;迭代器 思路主要是实现MutableList&lt;T&gt;接口，迭代器实现MutableListIterator&lt;T&gt;接口。 说明链表，就是一个一个节点连接起来的数据结构，这种数据结构优点是使用过的空间大小和元素数量成正比且增删时间复杂度低，缺点则是查找困难，需要通过引用访问任意元素。 API增删在这一部分主要需要特别考虑的几种情况： 在表头插入节点 image-20200715151744188 删除表头结点 image-20200715151824396 在表尾插入节点 image-20200715151838973 迭代迭代方面，主要是实现MutableListIterator&lt;T&gt;，当要遍历的时候仅需要 1234val numbers = LinkedList&lt;String&gt;()for (n in numbers) &#123; ......&#125; 或者 12345val numbers = LinkedList&lt;String&gt;()val mutableListIterator = numbers.listIterator()while (mutableListIterator.hasNext()) &#123; mutableListIterator.next()&#125; 便可。 迭代过程的remove()和add()则是实现当前节点的删除和在当前节点之前添加的功能。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651package dsimport kotlin.NoSuchElementException/** * 双向链表 * */class LinkedList&lt;T&gt; : MutableList&lt;T&gt; &#123; private var first: Node&lt;T&gt;? = null private var last: Node&lt;T&gt;? = null private var _size: Int = 0 /** * 在尾部插入[element] * */ override fun add(element: T): Boolean &#123; linkedLast(element) return true &#125; /** * 让[element]成为[index]位置的节点 * */ override fun add(index: Int, element: T) &#123; checkPositionIndex(index, size) if (index == _size) &#123; linkedLast(element) &#125; else &#123; linkedBefore(element, getNode(index)) &#125; &#125; /** * 让[index]位置成为[elements]的第一个节点位置 * */ override fun addAll(index: Int, elements: Collection&lt;T&gt;): Boolean &#123; checkPositionIndex(index, size) if (elements.isEmpty()) &#123; return false &#125; // 这里的两个节点代表着插入节点的前后节点 var pred: Node&lt;T&gt;? var succ: Node&lt;T&gt;? // 判断是否是最尾部插入 if (index == _size) &#123; succ = null pred = last &#125; else &#123; succ = getNode(index) pred = succ.prev &#125; for (e in elements) &#123; val nNode = Node(e, pred, null) if (pred == null) &#123; // 说明是在首节点插入的 first = nNode &#125; else &#123; // 一直往后插入 pred.next = nNode &#125; pred = nNode &#125; if (succ == null) &#123; last = pred &#125; else &#123; pred!!.next = succ succ.prev = pred &#125; _size += elements.size return true &#125; /** * 在尾部添加[elements] * */ override fun addAll(elements: Collection&lt;T&gt;): Boolean = addAll(_size, elements) /** * 清除所有节点 * */ override fun clear() &#123; var n = first while (n != null) &#123; val next = n.next // 快速gc n.item = null n.next = null n.prev = null n = next &#125; first = null last = null _size = 0 &#125; /** * 删除为[element]的节点 * */ override fun remove(element: T): Boolean &#123; var node = first while (node != null) &#123; if (node.item == element) &#123; unlink(node) return true &#125; node = node.next &#125; return false &#125; /** * 删除 * */ override fun removeAll(elements: Collection&lt;T&gt;): Boolean = if (containsAll(elements)) elements.all &#123; remove(it) &#125; else false /** * 删除[index]位置的节点 * */ override fun removeAt(index: Int): T &#123; checkElementIndex(index, size) val node = getNode(index) val item = node.item unlink(node) return item ?: throw NoSuchElementException() &#125; override fun retainAll(elements: Collection&lt;T&gt;): Boolean = if (containsAll(elements)) &#123; clear() addAll(elements) &#125; else false /** * 设定[index]为[element]并返回旧值 * */ override fun set(index: Int, element: T): T &#123; checkElementIndex(index, size) return getNode(index).run &#123; item!!.also &#123; item = element &#125; &#125; &#125; /** * 是否包含[element] * */ override fun contains(element: T): Boolean &#123; return indexOf(element) != -1 &#125; /** * 是否包含所有[elements] * */ override fun containsAll(elements: Collection&lt;T&gt;): Boolean = if (elements.isEmpty()) false else elements.all &#123; contains(it) &#125; /** * 获取[index]节点数据 * */ override fun get(index: Int): T &#123; checkElementIndex(index, size) return getNode(index).item ?: throw NoSuchElementException() &#125; override fun indexOf(element: T): Int &#123; var index = 0 this.forEach &#123; if (it == element) &#123; return index &#125; index++ &#125; return -1 &#125; /** * 链表是否为空 * */ override fun isEmpty(): Boolean = _size == 0 /** * 可以查到的最后一个元素 * */ override fun lastIndexOf(element: T): Int &#123; var index = _size - 1 var node = last while (node != null) &#123; if (node.item == element) &#123; return index &#125; index-- node = node.prev &#125; return index &#125; /** * 返回迭代器 * */ override fun iterator(): MutableIterator&lt;T&gt; &#123; return LinkedIterator(0) &#125; /** * 返回列表迭代器 * */ override fun listIterator(): MutableListIterator&lt;T&gt; &#123; return LinkedListIterator(0) &#125; /** * 返回从某个index开始的迭代器 * */ override fun listIterator(index: Int): MutableListIterator&lt;T&gt; &#123; checkElementIndex(index, size) return LinkedListIterator(index) &#125; /** * 返回子列表 * */ override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;T&gt; &#123; checkRangeIndexes(fromIndex, toIndex, size) val res = LinkedList&lt;T&gt;() var i = fromIndex var n = getNode(fromIndex) while (i &lt; toIndex) &#123; res.add(n.item!!) i++ n = n.next!! &#125; return res &#125; /** * 获取链表长度 * */ override val size: Int get() = _size /** * 获取首节点数据 * */ fun getFirst(): T = first?.item ?: throw NoSuchElementException() /** * 获取尾节点数据 * */ fun getLast(): T = last?.item ?: throw NoSuchElementException() /** * 反转链表 * */ fun reverse() &#123; if (first == null) &#123; return &#125; first = last.also &#123; last = first &#125; var n = first while (n != null) &#123; n.prev = n.next.also &#123; n!!.next = n!!.prev &#125; n = n.next &#125; &#125; /** * 添加首节点 * */ fun addFirst(element: T) &#123; linkedFirst(element) &#125; /** * 添加尾节点 * */ fun addLast(element: T) &#123; linkedLast(element) &#125; /** * 删除首节点 * */ fun removeFirst(): T = unlinkFirst() /** * 删除尾节点 * */ fun removeLast(): T = unlinkLast() /** * 获取某个节点 * 判断1/2的size然后从左往右或者从右往左查找 * */ private fun getNode(index: Int): Node&lt;T&gt; = if (index &lt; (_size shr 1)) &#123; var node = first for (i in 0 until index) &#123; node = node?.next &#125; node!! &#125; else &#123; var node = last for (i in _size - 2 downTo index) &#123; node = node?.prev &#125; node!! &#125; /** * 连接首节点 * */ private fun linkedFirst(item: T) &#123; val f = first val nNode = Node(item, null, f) first = nNode if (f == null) &#123; last = nNode &#125; else &#123; f.prev = nNode &#125; _size++ &#125; /** * 连接到[node]节点前面 * */ private fun linkedBefore(item: T, node: Node&lt;T&gt;) &#123; val prev = node.prev val nNode = Node(item, prev, node) node.prev = nNode if (prev == null) &#123; first = nNode &#125; else &#123; prev.next = nNode &#125; _size++ &#125; /** * 连接尾节点 * */ private fun linkedLast(item: T) &#123; val l = last val nNode = Node(item, l, null) last = nNode if (l == null) &#123; first = last &#125; else &#123; l.next = nNode &#125; _size++ &#125; /** * 解除首部连接 * */ private fun unlinkFirst(): T &#123; val f = first ?: throw NoSuchElementException() val item = f.item val next = f.next // 快速GC f.next = null f.item = null first = next if (next == null) &#123; last = null &#125; else &#123; next.prev = null &#125; _size-- return item!! &#125; /** * 解除尾部连接 * */ private fun unlinkLast(): T &#123; val l = last ?: throw NoSuchElementException() val item = l.item val prev = l.prev // 快速GC l.item = null l.prev = null last = prev if (prev == null) &#123; first = null &#125; else &#123; prev.next = null &#125; _size-- return item!! &#125; /** * 解连接 * */ private fun unlink(node: Node&lt;T&gt;): T &#123; val np = node.prev val nn = node.next val ne = node.item if (np == null) &#123; first = nn &#125; else &#123; np.next = nn node.prev = null &#125; if (nn == null) &#123; last = np &#125; else &#123; nn.prev = np node.next = null &#125; node.item = null _size-- return ne!! &#125; /** * \" == \" 方法 * */ override fun equals(other: Any?): Boolean &#123; if (other === this) return true if (other !is List&lt;*&gt;) return false return orderedEquals(this, other) &#125; /** * hash计算 * */ override fun hashCode(): Int = orderedHashCode(this) /** * 转字符串方法 * */ override fun toString(): String = StringBuilder().also &#123; it.append(\"[ \") this.forEach &#123; item -&gt; it.append(\"$item \") &#125; it.append(\"]\") &#125;.toString() internal companion object &#123; /** * 节点类 * */ private data class Node&lt;T&gt;( var item: T?, var prev: Node&lt;T&gt;? = null, var next: Node&lt;T&gt;? = null ) /** * 查看element是否合法 * */ internal fun checkElementIndex(index: Int, size: Int) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw IndexOutOfBoundsException(\"index: $index, size: $size\") &#125; &#125; /** * 查看位置是否合法 * */ internal fun checkPositionIndex(index: Int, size: Int) &#123; if (index &lt; 0 || index &gt; size) &#123; throw IndexOutOfBoundsException(\"index: $index, size: $size\") &#125; &#125; /** * 查看范围是否合法 * */ internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) &#123; if (fromIndex &lt; 0 || toIndex &gt; size) &#123; throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\") &#125; if (fromIndex &gt; toIndex) &#123; throw IllegalArgumentException(\"fromIndex: $fromIndex &gt; toIndex: $toIndex\") &#125; &#125; /** * 查看边界是否合法 * */ internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) &#123; if (startIndex &lt; 0 || endIndex &gt; size) &#123; throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\") &#125; if (startIndex &gt; endIndex) &#123; throw IllegalArgumentException(\"startIndex: $startIndex &gt; endIndex: $endIndex\") &#125; &#125; /** * 哈希函数 * */ internal fun orderedHashCode(c: Collection&lt;*&gt;): Int &#123; var hashCode = 1 for (e in c) &#123; hashCode = 31 * hashCode + (e?.hashCode() ?: 0) &#125; return hashCode &#125; /** * 查看是否相等 * */ internal fun orderedEquals(c: Collection&lt;*&gt;, other: Collection&lt;*&gt;): Boolean &#123; if (c.size != other.size) return false val otherIterator = other.iterator() for (elem in c) &#123; val elemOther = otherIterator.next() if (elem != elemOther) &#123; return false &#125; &#125; return true &#125; &#125; /** * 迭代器类 * */ private open inner class LinkedIterator( protected var index: Int = 0 ) : MutableIterator&lt;T&gt; &#123; protected var lastReturned: Node&lt;T&gt;? = null protected var current: Node&lt;T&gt;? = null init &#123; checkPositionIndex(index, _size) current = if (index == _size) null else getNode(index) &#125; /** * 是否存在下一个节点 * */ override fun hasNext(): Boolean = index &lt; _size /** * 下一节点数据 * */ override fun next(): T &#123; if (!hasNext()) &#123; throw NoSuchElementException() &#125; lastReturned = current current = current?.next index++ return lastReturned?.item ?: throw NoSuchElementException() &#125; /** * 删除当前节点 * */ override fun remove() &#123; val lastNext = lastReturned?.next unlink(lastReturned ?: throw IllegalStateException()) index-- &#125; &#125; /** * 列表迭代器类 * */ private open inner class LinkedListIterator( index: Int = 0 ) : LinkedIterator( index ), MutableListIterator&lt;T&gt; &#123; /** * 是否有上一节点 * */ override fun hasPrevious(): Boolean = index &gt; 0 /** * 下一节点游标 * */ override fun nextIndex(): Int = index /** * 返回上一节点 * */ override fun previous(): T &#123; if (!hasPrevious()) &#123; throw NoSuchElementException() &#125; current = if (current == null) last else current!!.prev lastReturned = current index-- return lastReturned?.item ?: throw NoSuchElementException() &#125; /** * 下一节点游标 * */ override fun previousIndex(): Int = index - 1 /** * 添加节点 * */ override fun add(element: T) &#123; lastReturned = null if (current == null) &#123; linkedLast(element) &#125; else &#123; linkedBefore(element, current!!) &#125; index++ &#125; /** * 设置节点 * */ override fun set(element: T) &#123; if (lastReturned == null) throw IllegalStateException() current!!.item = element &#125; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546fun main() &#123; val ll = LinkedList&lt;Int&gt;() for (i in 1..10) ll.add(i) println(ll) ll.reverse() println(ll) val it = ll.listIterator() while (it.hasNext()) &#123; print(\"$&#123;it.next()&#125; \") &#125; println() while (it.hasPrevious()) &#123; print(\"$&#123;it.previous()&#125; \") &#125; println() ll.addFirst(111) ll.addLast(222) println(ll) ll.removeFirst() ll.removeLast() println(ll) ll.removeAt(1) println(ll) ll.add(9, 114514) println(ll) println(ll.size) ll.clear() println(ll) ll.addAll(listOf(1111, 2222, 3333, 4444)) println(ll) ll.clear() ll.addAll(0, listOf(121, 222, 3445)) println(ll) println(ll.getFirst()) println(ll.getLast()) ll.set(2, 1000000) println(ll) ll.remove(121) println(ll) ll.removeAll(listOf(222, 1000000)) println(ll) ll.addAll(listOf(1123, 1122, 2234)) ll.retainAll(listOf(1123)) println(ll)&#125; 结果 image-20200717090421490","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"}]},{"title":"算法(第四版)笔记(2)---简单计算器(加减乘除括号)","date":"2020-07-12T07:51:45.000Z","path":"2020/07/12/algorithm4-eval-int-arithmetic/","text":"中缀表达式转后缀表达式，计算后缀表达式实现的加减乘除括号计算器。 思路中缀表达式转后缀表达式，计算后缀表达式。 中缀转后缀 数字 直接添加到结果 非数字 ” ）“，依次弹栈添加到结果直到“（ ”(左括号也弹栈) “（ “直接压栈，不用管 判断是否低于栈顶符号，大于直接入栈，等于先弹栈再入栈，低于直接弹栈到字符优先级高于栈顶符号或者左括号或空栈 后缀计算 数字 入栈 非数字 根据字符进行两次出栈操作然后计算完再入栈 实现中缀转后缀1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 优先级 * 加减优先级最低 * 然后就是乘除 * 括号优先级最高 * */val priority = HashMap&lt;String, Int&gt;().apply &#123; put(\"+\", 0) put(\"-\", 0) put(\"*\", 1) put(\"/\", 1) put(\"(\", 2) put(\")\", 2)&#125;/** * 中缀转后缀 * */private fun infixToPostfix(expr: String): String &#123; val sb = StringBuilder() val s = Stack&lt;Char&gt;() expr.forEach &#123; c: Char -&gt; when (c) &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -&gt; sb.append(c) '+', '-', '*', '/' -&gt; &#123; while (!s.isEmpty() &amp;&amp; s.peek() != '(' &amp;&amp; priority[c.toString()]!! &lt;= priority[s.peek().toString()]!! ) &#123; sb.append(s.pop()) &#125; s.push(c) &#125; '(' -&gt; s.push(c) ')' -&gt; &#123; while (!s.isEmpty()) &#123; if (s.peek() == '(') &#123; s.pop() break &#125; else &#123; sb.append(s.pop()) &#125; &#125; &#125; else -&gt; throw UnsupportedOperationException(\"未知字符!\") &#125; &#125; while (!s.isEmpty()) &#123; sb.append(s.pop()) &#125; return sb.toString()&#125; 计算后缀12345678910111213141516/** * 计算后缀表达式 * */private fun evalPostfix(expr: String): Double &#123; val s = Stack&lt;Double&gt;() expr.forEach &#123; c: Char -&gt; when (c) &#123; '+' -&gt; s.pop().plus(s.pop()).let &#123; s.push(it) &#125; '-' -&gt; s.pop().minus(s.pop()).let &#123; s.push(it) &#125; '*' -&gt; s.pop().times(s.pop()).let &#123; s.push(it) &#125; '/' -&gt; s.pop().div(s.pop()).let &#123; s.push(it) &#125; else -&gt; s.push(Character.getNumericValue(c).toDouble()) &#125; &#125; return if (s.isEmpty()) 0.0 else s.pop()&#125; 主函数12345/** * 四则运算(带括号) * */fun evalIntArithmetic(expr: String): Double = evalPostfix(infixToPostfix(expr.trim().replace(\" \", \"\"))) 测试123456789package fundamentalsimport utils.evalIntArithmeticfun main() &#123; println(evalIntArithmetic(\"\")) println(evalIntArithmetic(\" 1 + 2\")) println(evalIntArithmetic(\"1+2*3+(4*5+6)*7\"))&#125; 输出： image-20200712185745469 验算： image-20200712185812495","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"}]},{"title":"算法(第四版)笔记(1)---简单类的实现","date":"2020-07-11T14:40:50.000Z","path":"2020/07/11/algorithm4th-1/","text":"算法第四版第一章节 累加器API image-20200711224750298 实现123456789101112131415161718192021222324252627282930313233343536package dsimport kotlin.math.sqrt/** * 累加器 防抖动版本 * */class Accumulator constructor( private var total: Double = 0.0) &#123; private var times: Int = 0 private var mean: Double = 0.0 private var s: Double = 0.0 fun &lt;T : Number&gt; addDataValue(value: T) &#123; times += 1 val dv = value.toDouble() total += dv s += 1.0 * (times - 1) / times * (dv - mean) * (dv - mean) mean += (dv - mean) / times &#125; fun mean(): Double = mean fun variance(): Double = if (times &lt;= 1) Double.NaN else s / (times - 1) fun stddev(): Double = sqrt(variance()) fun total(): Double = total override fun toString(): String &#123; return \"Mean ($times times, $&#123;String.format(\"%.2f\", total)&#125; values): \" + \"$&#123;String.format(\"%7.5f\", mean())&#125;\" &#125;&#125; 可视化累加器API image-20200711224928831 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package dsimport edu.princeton.cs.algs4.StdDrawimport kotlin.math.sqrtclass VisualAccumulator constructor( private val xMax: Int = 100, private val yMax: Double = 100.0) &#123; private var times: Int = 0 private var total: Double = 0.0 private var mean: Double = 0.0 private var s: Double = 0.0 init &#123; StdDraw.setXscale(0.0, xMax.toDouble()) StdDraw.setYscale(0.0, yMax) StdDraw.setPenRadius(.01) &#125; fun &lt;T : Number&gt; addDataValue(value: T) &#123; times += 1 val dv = value.toDouble() total += dv mean += (dv - mean) / times s += 1.0 * (times - 1) / times * (dv - mean) * (dv - mean) StdDraw.setPenColor(StdDraw.DARK_GRAY) StdDraw.point(times.toDouble(), value.toDouble()) StdDraw.setPenColor(StdDraw.RED) StdDraw.point(times.toDouble(), mean()) StdDraw.setPenColor(StdDraw.BLUE) StdDraw.point(times.toDouble(), stddev()) &#125; fun mean(): Double = mean fun variance(): Double = if (times &lt;= 1) 0.0 else s / (times - 1) fun stddev(): Double = sqrt(variance()) fun total(): Double = total override fun toString(): String &#123; return \"Mean ($times times, $&#123;String.format(\"%.2f\", total)&#125; values): \" + \"$&#123;String.format(\"%7.5f\", mean())&#125;\" &#125;&#125; 可视化结果 image-20200711225013771 有理数API image-20200711225149973 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package dsimport utils.qgcdimport kotlin.reflect.typeOfclass Rational constructor( private var numerator: Long, private var denominator: Long = 1L) : Comparable&lt;Rational&gt; &#123; init &#123; if (denominator == 0L) &#123; throw IllegalAccessError(\"分母不能为0!\") &#125; simplify() &#125; fun numerator(): Long &#123; return numerator &#125; fun denominator(): Long &#123; return denominator &#125; private fun simplify() &#123; val g = qgcd(numerator, denominator) numerator /= g denominator /= g if (denominator &lt; 0) &#123; denominator = -denominator numerator = -numerator &#125; &#125; public operator fun plus(other: Rational): Rational &#123; if (this.numerator == 0L) return other if (other.numerator == 0L) return this val g = qgcd(this.denominator, other.denominator) return Rational( this.numerator * (other.denominator / g) + other.numerator * (this.denominator / g), this.denominator * (other.denominator / g) ) &#125; public operator fun minus(other: Rational): Rational &#123; if (this.numerator == 0L) return other if (other.numerator == 0L) return this val g = qgcd(this.denominator, other.denominator) return Rational( this.numerator * (other.denominator / g) - other.numerator * (this.denominator / g), this.denominator * (other.denominator / g) ) &#125; public operator fun times(other: Rational): Rational &#123; return Rational( this.numerator * other.numerator, this.denominator * other.denominator ) &#125; public operator fun div(other: Rational): Rational &#123; return Rational( this.numerator * other.denominator, this.denominator * other.numerator ) &#125; override fun equals(other: Any?): Boolean &#123; if (other == null) return false if (this::class != other::class) return false return this.compareTo(other as Rational) == 0 &#125; override fun toString(): String &#123; if (denominator == 1L) &#123; return \"$numerator\" &#125; return \"$numerator/$denominator\" &#125; override fun compareTo(other: Rational): Int &#123; // 除法判断大小于 val num = this.numerator * other.denominator val den = this.denominator * other.numerator if (num &gt; den) // 说明分子大 当前数大 return 1 if (num &lt; den) return -1 return 0 &#125;&#125; 日期类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package dsclass Date : Comparable&lt;Date&gt; &#123; private val year: Int private val month: Int private val day: Int constructor( y: Int = 0, m: Int = 0, d: Int = 0 ) &#123; if (!isDateValid(d, m, y)) throw IllegalArgumentException(\"输入日期错误!\") year = y month = m day = d &#125; constructor( parseString: String ) &#123; parseString.split(\"/\").run &#123; if (size &lt; 3) &#123; throw IllegalArgumentException(\"输入日期错误！\") &#125; year = get(0).toInt() month = get(1).toInt() day = get(2).toInt() if (!isDateValid(day, month, year)) throw IllegalArgumentException(\"输入日期错误！\") &#125; &#125; companion object &#123; val monthDayList = listOf(0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) &#125; private fun isDateValid(d: Int, m: Int, y: Int): Boolean &#123; if (m &gt; 12 || m &lt; 1) &#123; return false &#125; if (d &gt; monthDayList[m] || d &lt; 1) &#123; return false &#125; if (m == 2 &amp;&amp; d == 29 &amp;&amp; !isLeapYear(y)) &#123; return false &#125; return true &#125; // is y a leap year? fun isLeapYear(y: Int): Boolean &#123; if (y % 400 == 0) return true if (y % 100 == 0) return false return y % 4 == 0 &#125; fun year() = year fun month() = month fun day() = day override fun compareTo(other: Date): Int &#123; if (this.year &lt; other.year) return -1 if (this.year &gt; other.year) return 1 if (this.month &lt; other.month) return -1 if (this.month &gt; other.month) return 1 if (this.day &lt; other.day) return -1 if (this.day &gt; other.day) return 1 return 0 &#125; override fun toString(): String &#123; return \"$year/$month/$day\" &#125; override fun hashCode(): Int &#123; return day + 31 * month + 31 * 12 * year &#125;&#125; 账单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package dsclass Transaction : Comparable&lt;Transaction&gt; &#123; private val who: String private val time: Date private val amount: Double constructor( w: String, t: Date, a: Double ) &#123; if (!isAmountValid(a)) throw IllegalArgumentException(\"输入金额格式错误!\") who = w time = t amount = a &#125; constructor( parseString: String ) &#123; parseString.split(\" \").run &#123; if (size &lt; 3) &#123; throw IllegalArgumentException(\"输入格式错误！\") &#125; who = get(0) time = Date(get(1)) amount = get(2).toDouble() if (!isAmountValid(amount)) throw IllegalArgumentException(\"输入金额错误！\") &#125; &#125; fun who() = who fun time() = time fun amount() = amount private fun isAmountValid(amount: Double): Boolean &#123; if ( Double.NaN == amount || Double.NEGATIVE_INFINITY == amount || Double.POSITIVE_INFINITY == amount ) &#123; return false &#125; return true &#125; override fun compareTo(other: Transaction): Int &#123; return compareValues(this.amount, other.amount) &#125; override fun toString(): String &#123; return String.format(\"%-10s %10s %8.2f\", who, time, amount) &#125;&#125; 二分查找实现123456789101112131415161718fun &lt;T : Comparable&lt;T&gt;&gt; binarySearch(list: List&lt;T&gt;, key: T): Int &#123; var lo = 0 var hi = list.size - 1 while (lo &lt;= hi) &#123; val mid = lo + (hi - lo) / 2 if (key &lt; list[mid]) &#123; hi = mid - 1 &#125; else if (key &gt; list[mid]) &#123; lo = mid + 1 &#125; else &#123; return mid &#125; &#125; return -1&#125; GCD普通GCD123456789101112131415/** * 普通gcd模板 * */fun &lt;T : Number&gt; gcd(a: T, b: T): Long &#123; if (a == 0) return b.toLong() if (b == 0) return a.toLong() var ta = abs(a.toLong()) var tb = abs(b.toLong()) while (tb != 0L) &#123; ta = tb.also &#123; tb = ta % tb &#125; &#125; return ta&#125; 快速GCD123456789101112131415161718192021222324/** * 快速gcd模板 * */private fun qgcd_(a: Long, b: Long): Long &#123; if (a == 0L) return b if (b == 0L) return a if ((a and 1) == 0L &amp;&amp; (b and 1) == 0L) return qgcd_(a shr 1, b shr 1) shl 1 else if ((b and 1) == 0L) return qgcd_(a, b shr 1) else if ((a and 1) == 0L) return qgcd_(a shr 1, b) else return qgcd_(abs(a - b), min(a, b))&#125;fun &lt;T : Number&gt; qgcd(a: T, b: T): Long &#123; if (a == 0) return b.toLong() if (b == 0) return a.toLong() var ta = a.toLong() var tb = b.toLong() return qgcd_(abs(ta), abs(tb))&#125; 背包API image-20200711225738407 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package dsimport kotlin.NoSuchElementExceptionclass Bag&lt;T&gt; : Iterable&lt;T&gt; &#123; private var first: Node&lt;T&gt;? = null private var n: Int = 0 fun isEmpty(): Boolean = first == null fun size(): Int = n fun add(item: T) &#123; val oi = first first = Node( item, oi ) n++ &#125; override fun iterator(): Iterator&lt;T&gt; &#123; return LinkedIterator&lt;T&gt;(first) &#125; private data class Node&lt;T&gt;( val item: T, var next: Node&lt;T&gt;? = null ) private class LinkedIterator&lt;T&gt;( private var current: Node&lt;T&gt;? ) : Iterator&lt;T&gt; &#123; override fun hasNext(): Boolean &#123; return current != null &#125; fun remove() &#123; throw UnsupportedOperationException() &#125; override fun next(): T &#123; if (!hasNext()) &#123; throw NoSuchElementException() &#125; val item = current?.item current = current?.next return item!! &#125; &#125;&#125; 栈API image-20200711225952602 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package dsclass Stack&lt;T&gt; : Iterable&lt;T&gt; &#123; private var first: Node&lt;T&gt;? = null private var n: Int = 0 fun isEmpty(): Boolean = first == null fun size(): Int = n fun push(item: T) &#123; val oi = first first = Node( item, oi ) n++ &#125; fun pop(): T? &#123; if (isEmpty()) &#123; throw NoSuchElementException(\"Stack underflow\") &#125; return first?.item.also &#123; first = first?.next n-- &#125; &#125; fun peek(): T? &#123; if (isEmpty()) &#123; throw NoSuchElementException(\"Stack underflow\") &#125; return first?.item &#125; override fun toString(): String &#123; return StringBuilder().also &#123; this.forEach &#123; item -&gt; it.append(\"$item \") &#125; &#125;.toString() &#125; override fun iterator(): Iterator&lt;T&gt; &#123; return LinkedIterator(first) &#125; private data class Node&lt;T&gt;( val item: T, var next: Node&lt;T&gt;? = null ) private class LinkedIterator&lt;T&gt;( private var current: Node&lt;T&gt;? ) : Iterator&lt;T&gt; &#123; override fun hasNext(): Boolean &#123; return current != null &#125; fun remove() &#123; throw UnsupportedOperationException() &#125; override fun next(): T &#123; if (!hasNext()) &#123; throw NoSuchElementException() &#125; val item = current?.item current = current?.next return item!! &#125; &#125;&#125; 队列API image-20200711230035937 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package dsclass Queue&lt;T&gt; : Iterable&lt;T&gt; &#123; private var first: Node&lt;T&gt;? = null private var last: Node&lt;T&gt;? = null private var n: Int = 0 fun isEmpty(): Boolean = first == null fun size(): Int = n fun enqueue(item: T) &#123; val ol = last last = Node( item, null ) if (isEmpty()) &#123; first = last &#125; else &#123; ol?.next = last &#125; n++ &#125; fun dequeue(): T? &#123; if (isEmpty()) &#123; throw NoSuchElementException(\"Stack underflow\") &#125; return first?.item.also &#123; first = first?.next n-- if (isEmpty()) &#123; last = null &#125; &#125; &#125; fun peek(): T? &#123; if (isEmpty()) &#123; throw NoSuchElementException(\"Stack underflow\") &#125; return first?.item &#125; override fun toString(): String &#123; return StringBuilder().also &#123; this.forEach &#123; item -&gt; it.append(\"$item \") &#125; &#125;.toString() &#125; override fun iterator(): Iterator&lt;T&gt; &#123; return LinkedIterator(first) &#125; private data class Node&lt;T&gt;( val item: T, var next: Node&lt;T&gt;? = null ) private class LinkedIterator&lt;T&gt;( private var current: Node&lt;T&gt;? ) : Iterator&lt;T&gt; &#123; override fun hasNext(): Boolean &#123; return current != null &#125; fun remove() &#123; throw UnsupportedOperationException() &#125; override fun next(): T &#123; if (!hasNext()) &#123; throw NoSuchElementException() &#125; val item = current?.item current = current?.next return item!! &#125; &#125;&#125; 括号匹配实现1234567891011121314151617/** * 括号是否匹配 * */fun isBanlanced(expr: String): Boolean &#123; val s = Stack&lt;Char&gt;() expr.forEach &#123; c: Char -&gt; when (c) &#123; '(', '&#123;', '[' -&gt; s.push(c) ')' -&gt; if (s.isEmpty() || s.pop() != '(') return false ']' -&gt; if (s.isEmpty() || s.pop() != '[') return false '&#125;' -&gt; if (s.isEmpty() || s.pop() != '&#123;') return false &#125; &#125; return true&#125;","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"}]},{"title":"线性动画/非线性动画","date":"2020-05-01T13:34:56.000Z","path":"2020/05/01/linear-anime/","text":"起因是因为今天看到b站上有自媒体评测 MIUI12 , 说到了动画流畅度那方面弹幕都说线性动画非线性动画什么的, 其实很早之前 MUI 就是全线采用非线性动画了, 但这个线性与非线性又是什么, 有什么区别呢, 我今天就稍微来讲一下.其实这个高中就学习过了, 不过因为最近学习了js, 可以更加明确的展示出来了. 什么是线性动画/非线性动画要理解这个, 首先需要理解一个问题: *什么是动画? * 什么是动画?根据 维基百科 所叙述的: 动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 可以了解到, 动画, 其实就是很多静止的画面利用视觉残留现象做出来的可动的效果, 所以说如果想要模仿动画的效果, 只需要在1s内对一张图片更替一定的量的次数, 人眼就不会看出是否对这张图片进行了更替, 这, 其实就是 帧 .同时,并不是所有的 帧 都是会更改的, 有些帧完全就是不会变化的, 这就引出了 关键帧 的概念, 我们只需要着重关注于关键更改了图象的 帧 即可, 并不需要关注其他状态的 静止帧 .本次编程实践也是只针对于关键帧处理的. 什么是非线性动画在 Maya 用户指南上有这么一句话: 在 Maya 中，有两种类型的片段：源片段和常规剪辑。Maya 通过将角色的原始动画曲线保存在源片段中，来保留及保存角色原始动画曲线。请勿使用源片段为角色设置动画。但是，您可以使用源片段（称为_常规片段_）的副本或_实例_以非线性方式为角色设置动画。请参见动画片段。 __非线性动画的基础是，移动、操纵和混合常规片段，从而为角色生成一系列平滑的动作。_&gt; 看上去很高级, 说白了其实就是动画的关键帧停留位置(时段), 也就是说, 非线性的关键帧所停留的并不是处于常见规律中的, 他可能是遵循二次函数, 遵循震荡函数, 总之, 其规律一定不是线性规律(一次函数). 什么是线性动画所以, 线性动画就很容易理解了, 所有关键帧停留位置其实都是处在一条线中的, 其导数永远是常数. 线性动画/非线性动画有什么用那么, 非线性动画又有着什么样的特殊用途呢?很简单的, 应用在手机上, 这会让你的动画感觉更有动感, 更加精致, 不会像是线性动画那样, 一板一眼.比如 IOS 一直都是非线性动画, 给人的感受就非常的丝滑.而早年间的 Android 动画都是线性动画, 给人的感觉就像是机械一般的精密但刻板. 简单的线性动画(点击图片看动画): img See the Pen 线性动画 by !输认不永DGL (@xmmmmmovo) on CodePen. 简单的非线性(点击图片看动画):圆弧非线性 img See the Pen 加速非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 加减速非线性先加速再减速, 二次函数 See the Pen 二次非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 碰撞反弹 img 如果在开始时有动画效果，比如弹跳 —— 那么它将在最后显示。上图中常规弹跳为红色，easeOut 弹跳为蓝色。 常规弹跳 —— 物体在底部弹跳，然后突然跳到顶部。 easeOut 变换之后 —— 物体跳到顶部之后，在那里弹跳。 See the Pen 碰撞非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 总结如果理论看不懂, 那大概看例子也能领会了, 有些东西, 不知道是不是我语文太差的缘故, 理论实在是难以形容, 但是当实际例子展示出来了之后, 就会发现, 其实这个还是很容易理解/看出来的嘛.","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"animation","slug":"animation","permalink":"http://blog.fivezha.cn/tags/animation/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.fivezha.cn/tags/javascript/"}]},{"title":"网络编程笔记(2)---UDP与分包协议","date":"2020-04-29T12:39:32.000Z","path":"2020/04/29/socket-program-2/","text":"本文主要是在Linux环境下编写socket程序，本次实现简单UDPecho server和echo client，包含简单分包操作和协议设计 笔记UDP用户数据报协议, 不会存在ACK应答消息, 类似于广播的无连接传输层协议.就是说UDP仅需要一个套接字便可以与多台主机通信. img 基于UDP的I/O函数 img img 实现基于UDP的Echo服务器需求 img Server12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by xmmmmmovo on 2020/4/29.//#include &lt;arpa/inet.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;//constexpr int BUF_SIZE = 256;constexpr int BUF_SIZE = 10;void error_handler(char *message);int main(int argc, char *argv[]) &#123; if (argc != 2) &#123; printf(\"Usage: %s &lt;port&gt; \\n\", argv[ 0 ]); exit(1); &#125; int sock = socket(PF_INET, SOCK_DGRAM, 0); sockaddr_in sockAddr&#123;&#125;; memset(&amp;sockAddr, 0, sizeof(sockAddr)); sockAddr.sin_family = AF_INET; sockAddr.sin_addr.s_addr = htonl(INADDR_ANY); sockAddr.sin_port = htons(atoi(argv[ 1 ])); if (-1 == bind(sock, (struct sockaddr *) &amp;sockAddr, sizeof(sockAddr))) &#123; error_handler(\"bind() error!\"); &#125; sockaddr_in clntAddr&#123;&#125;; socklen_t clntAddrLen = sizeof(clntAddr); char buf[ 512 ]; while (true) &#123; int recv_len = recvfrom(sock, buf, BUF_SIZE, 0, (struct sockaddr *) &amp;clntAddr, &amp;clntAddrLen); printf(\"recv len = %d\\n\", recv_len); sendto(sock, buf, recv_len, 0, (struct sockaddr *) &amp;clntAddr, sizeof(clntAddr)); &#125; close(sock); return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//// Created by xmmmmmovo on 2020/4/29.//#include &lt;arpa/inet.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;//constexpr int BUF_SIZE = 256;constexpr int BUF_SIZE = 10;void error_handler(char *message);class InetAddress &#123;public: explicit InetAddress(std::string port, const std::string ip = \"\") &#123; memset(&amp;addr_, 0, sizeof(addr_)); addr_.sin_family = AF_INET; addr_.sin_port = htons(atoi(port.c_str())); if (ip == \"\") addr_.sin_addr.s_addr = htonl(INADDR_ANY); else addr_.sin_addr.s_addr = inet_addr(ip.c_str()); &#125; ~InetAddress() = default; sockaddr_in &amp;getAddr() &#123; return addr_; &#125;private: struct sockaddr_in addr_ &#123;&#125;;&#125;;class Socket &#123;public: explicit Socket(int type) &#123; fd_ = socket(PF_INET, type, 0); &#125; ~Socket() &#123; close(fd_); &#125; ssize_t sendto(InetAddress &amp;addr, void *pData, size_t nBytes) const &#123; sockaddr *toAddr = (sockaddr *) &amp;(addr.getAddr()); socklen_t addrLen = sizeof(addr.getAddr()); return ::sendto(fd_, pData, nBytes, 0, toAddr, addrLen); &#125; ssize_t recvfrom(InetAddress &amp;addr, void *buf, size_t nBytes) const &#123; return ::recvfrom(fd_, buf, nBytes, 0, 0, 0); &#125;private: int fd_;&#125;;int main(int argc, char *argv[]) &#123; if (argc != 3) &#123; printf(\"Usage: %s &lt;ip&gt; &lt;port&gt; \\n\", argv[ 0 ]); exit(1); &#125; Socket sock(SOCK_DGRAM); InetAddress addr(argv[ 2 ], argv[ 1 ]); char buf[ 1024 ]; int sl = 0; while (true) &#123; fgets(buf + 3, sizeof(buf) - 3, stdin); sl = strlen(buf + 3) - 1; printf(\"str len = %d\\n\", sl); if (sl &lt; BUF_SIZE - 3) &#123; buf[ 1 ] = (char) 1; buf[ 2 ] = (char) sl; int send_len = sock.sendto(addr, buf + 1, sl + 2); printf(\"send len = %d\\n\", send_len); &#125; else &#123; int pack_num = ceil((double) sl / (BUF_SIZE - 3)); buf[ 0 ] = (char) 0; buf[ 1 ] = (char) pack_num; sock.sendto(addr, buf, 2); int st = 0; for (int i = 0; i &lt; pack_num; ++i) &#123; st = i * (BUF_SIZE - 3); buf[ st ] = (char) 2; buf[ st + 1 ] = (char) (i + 1); buf[ st + 2 ] = i == pack_num - 1 ? strlen(buf + st + 3) : BUF_SIZE - 3; sock.sendto(addr, buf + st, BUF_SIZE); &#125; &#125; int recv_len = sock.recvfrom(addr, buf, BUF_SIZE); buf[ recv_len ] = 0; if (buf[ 0 ] == 1) &#123; printf(\"Message from server: %s\\n\", buf + 2); &#125; else if (buf[ 0 ] == 0) &#123; // 数据包获取 int pack_num = (int) buf[ 1 ]; int cnt = 0; char pc_buf[ BUF_SIZE ]; for (int i = 0; i &lt; pack_num; ++i) &#123; recv_len = sock.recvfrom(addr, pc_buf, BUF_SIZE); std::copy(pc_buf + 3, pc_buf + recv_len, buf + cnt); cnt += (int) pc_buf[ 2 ]; &#125; printf(\"Message from server: %s\\n\", buf); &#125; &#125; return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; 结果client img server img","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"},{"name":"socket","slug":"socket","permalink":"http://blog.fivezha.cn/tags/socket/"}]},{"title":"网络编程笔记(1)---TCP与ECHO服务器","date":"2020-04-28T12:39:26.000Z","path":"2020/04/28/socket-program-1/","text":"本文主要是在Linux环境下编写socket程序，本次实现简单TCPserver和client以及echo server和echo client 什么是SocketSocket中文译名套接字, 是一个当时没有在计网中讲到的知识, 但确实是极其重要的一个知识点, 他是基于TCP/IP协议的封装抽象层, 它对于TCP协议进行了封装, 使得其现在已经成为了最为通用的网络通信接口/应用程序接口.关于TCP协议可以看下面这篇文章 https://tools.ietf.org/html/rfc793 为什么会有Socket我们知道, 服务/服务器其实是有很大可能不存在于一个计算机上的, 这就有了客户端与服务端, 在服务器之间, 也是需要存在连接通信的, 所以需要有一个用于进行通信的通用 可编程 接口, 这就是socket, 他对于 server 和 client 之间架起了一道桥, 让 server 与 port 绑定, 让 client 与 ip:port 连接, 这样就相当于 client 进程与 server 进程之间有了像是管道一样的通信, 不过这个通信是全双工的. 我们回顾TCP状态转换图 在这里能够找到许多socket封装的影子, 从客户端来看 则更加明显 学习Linux 下的网络编程(socket编程)创建套接字 int socket(int domain, int type, int protocol)return : 文件描述符 / or not -1domain: 套接字所使用的协议簇type: 套接字数据传输类型protocol: 套接字所使用的协议 文件描述符(windows下称之为句柄):系统分配给文件或套接字的一个整数: img https://segmentfault.com/a/1190000009724931 img 协议簇: img 套接字类型: SOCK_STREAM(流式)(面向连接) image.png SOCK_DGRAM(包式)(面向消息) img 协议 img sockaddr_in img img 网络字节序 img IntelCPU默认都是小端序, 而网络连接统一都是大端序 img img TCPserver/clien img img 所以又回到了最最上面的第一个图: img accept() img sock: 利用socket()函数建立的sockaddr: 地址变量addlen: 结构体长度 connect() img 实现简单的server/clientServer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// Created by xmmmmmovo on 2020/4/16.//#include &lt;arpa/inet.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;using std::string;using std::to_string;void error_handler(char *message);int main(int argc, char *argv[]) &#123; int serv_sock, clnt_sock; struct sockaddr_in serv_addr &#123;&#125;; struct sockaddr_in clnt_addr &#123;&#125;; socklen_t clnt_addr_size; string message = \"Hello World!\"; if (argc != 2) &#123; printf(\"Usage : %s &lt;port&gt;\\n\", argv[0]); exit(1); &#125; serv_sock = socket(PF_INET, SOCK_STREAM, 0); if (serv_sock == -1) &#123; error_handler(\"socket() error\"); &#125; memset(&amp;serv_addr, 0, sizeof(serv_addr));// 初始化内存 serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);// 当前主机ip serv_addr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) == -1) &#123; error_handler(\"bind() error\"); &#125; if (listen(serv_sock, 5) == -1) &#123; error_handler(\"listen() error\"); &#125; clnt_addr_size = sizeof(clnt_addr); clnt_sock = accept(serv_sock, (struct sockaddr *) &amp;clnt_addr, &amp;clnt_addr_size); if (clnt_sock == -1) &#123; error_handler(\"accept() error\"); &#125; for (int i = 1; i &lt; 4; ++i) &#123; sleep(rand() % 2); string tmp = message + to_string(i); write(clnt_sock, tmp.c_str(), tmp.size()); &#125; // write(clnt_sock, message.c_str(), message.size());// 连接之后直接向client写入数据 close(clnt_sock); close(serv_sock); return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; client1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by xmmmmmovo on 2020/4/16.//#include &lt;arpa/inet.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;using std::string;void error_handler(char *messgae);int main(int argc, char *argv[]) &#123; int sock; sockaddr_in serv_addr&#123;&#125;; int str_len = 0; int idx = 0, read_len = 0; string message;// 信息流 message.resize(100, '\\0'); if (argc != 3) &#123; printf(\"Usage : %s &lt;IP&gt; &lt;port&gt;\\n\", argv[0]); exit(1); &#125; sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) &#123; error_handler(\"socket() error\"); &#125; memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; // 这里会自动将ip字符串转换为uint32_t类型IP数字 serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (sockaddr *) &amp;serv_addr, sizeof(serv_addr)) == -1) &#123; error_handler(\"connect() error!\"); &#125; bool check = false; // 每次只读出一个字节 while (read_len = read(sock, &amp;message[idx++], 1)) &#123; if (str_len == -1) &#123; if (check) error_handler(\"read() error!\"); else sleep(3); &#125; str_len += read_len; &#125; printf(\"Message from server is : %s \\n\", message.c_str()); printf(\"Function read call count : %d \\n\", str_len); close(sock); return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; 结果可以看到 client 成功接受到了流字符: img 同时 server 也发送成功结束了程序: img 实现echo服务器Server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// Created by xmmmmmovo on 2020/4/16.//#include &lt;arpa/inet.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;using std::stoi;using std::string;using std::to_string;constexpr int BUF_SIZE = 1024;void error_handler(char *message);int main(int argc, char *argv[]) &#123; int serv_sock, clnt_sock; char message[BUF_SIZE]; int size_len = 4; char size_buf[size_len]; sockaddr_in serv_addr&#123;&#125;, clnt_addr&#123;&#125;; socklen_t clnt_addr_size; int str_len = 0; if (argc != 2) &#123; printf(\"Usage : %s &lt;port&gt;\\n\", argv[0]); exit(1); &#125; serv_sock = socket(PF_INET, SOCK_STREAM, 0); if (serv_sock == -1) &#123; error_handler(\"socket() error\"); &#125; memset(&amp;serv_addr, 0, sizeof(serv_addr));// 初始化内存 serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);// 当前主机ip serv_addr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) == -1) &#123; error_handler(\"bind() error\"); &#125; if (listen(serv_sock, 5) == -1) &#123; error_handler(\"listen() error\"); &#125; clnt_addr_size = sizeof(clnt_addr);// 算长度 ///主体 for (int i = 0; i &lt; 5; ++i) &#123; clnt_sock = accept(serv_sock, (sockaddr *) &amp;clnt_addr, &amp;clnt_addr_size); if (clnt_sock == 1) &#123; error_handler(\"accept() error!\"); &#125; else &#123; printf(\"Connected client %d \\n\", i + 1); &#125; while (true) &#123; if ((str_len = read(clnt_sock, size_buf, size_len)) != 0) &#123; if ((str_len = read(clnt_sock, message, stoi(size_buf))) != 0) &#123; write(clnt_sock, size_buf, size_len); write(clnt_sock, message, str_len); &#125; else &#123; break; &#125; &#125; else &#123; break; &#125; &#125; close(clnt_sock); &#125; /// close(serv_sock); return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; Client12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//// Created by xmmmmmovo on 2020/4/16.//#include &lt;arpa/inet.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;using std::stoi;using std::string;using std::to_string;constexpr int BUF_SIZE = 1024;void error_handler(char *messgae);int main(int argc, char *argv[]) &#123; int sock; sockaddr_in serv_addr&#123;&#125;; int str_len = 0; char message[BUF_SIZE]; if (argc != 3) &#123; printf(\"Usage : %s &lt;IP&gt; &lt;port&gt;\\n\", argv[0]); exit(1); &#125; sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) &#123; error_handler(\"socket() error\"); &#125; memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; // 这里会自动将ip字符串转换为uint32_t类型IP数字 serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (sockaddr *) &amp;serv_addr, sizeof(serv_addr)) == -1) &#123; error_handler(\"connect() error!\"); &#125; else &#123; puts(\"Connected......\"); &#125; while (true) &#123; fputs(\"Input message(Q/q to quit): \", stdout); std::fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) &#123; break; &#125; int l = strlen(message); printf(\"len = %d\\n\", l); string s = to_string(l); s.resize(4); write(sock, s.c_str(), 4); write(sock, message, strlen(message)); char buf[4]; str_len = read(sock, buf, 4); str_len = read(sock, message, stoi(buf)); message[str_len] = 0; printf(\"Message from server: %s\\n\", message); &#125; close(sock); return 0;&#125;void error_handler(char *message) &#123; fputs(message, stderr); fputc('\\n', stderr); exit(0);&#125; 结果client: img server: img","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"},{"name":"socket","slug":"socket","permalink":"http://blog.fivezha.cn/tags/socket/"}]},{"title":"docker笔记","date":"2020-04-24T13:31:13.000Z","path":"2020/04/24/docker-note/","text":"一点点docker笔记 安装docker12345678910111213141516171819curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyunsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\", \"https://dockerhub.azk8s.cn\" ], \"insecure-registries\" : [ \"hub-mirror.c.163.com\", \"mirror.baidubce.com\", \"dockerhub.azk8s.cn\" ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 安装docker-compose12sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 利用Dockerfile定制镜像1234567891011# flask部署FROM python:3.7COPY . /codeWORKDIR /codeRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; pip install -r /code/requirements.txt# 如果太慢了再加上这句 不然镜像站有可能同步不全导致包安装失败# -i https://pypi.tuna.tsinghua.edu.cn/CMD gunicorn app:app -c gunicorn.conf.py --error-logfile /log/gunicorn.log 123docker build -t 'name' .docker run -it 'name'docker run -d 'name' COPY 复制文件 CMD 容器启动命令 ENV 设置环境变量 WORKDIR 指定工作目录 常用指令 docker image/container ls 列出所有镜像/容器 docker rm … 删除镜像 docker attach … 进入容器 docker ps -a 列出所有的container包括没有运行的 docker-compose1234567891011121314151617181920212223242526272829303132# flask redis nginx mysql部署version: '3.6'services: web: build: . container_name: web volumes: - ../logs:/log depends_on: - db - redis db: image: mysql:5.7 environment: - MYSQL_ROOT_PASSWORD=mx/58MFuLJ6^%.q volumes: - ./config/mysql:/docker-entrypoint-initdb.d nginx: image: nginx:1.17 volumes: - ./config/nginx/default.conf:/etc/nginx/conf.d/default.conf depends_on: - web ports: - 8888:80 redis: image: redis:5.0.8 volumes: - ./config/redis/redis.conf:/etc/redis/redis.conf command: redis-server privileged: true build 利用Dockerfile编译的目录 image 镜像 volumes 目录映射关系 depend_on 依赖于 当依赖启动后本service才能启动 port 开放的端口映射 environment 环境变量 privileged 权限 command 自带命令行 常用指令 docker-compose start docker-compose stop docker-compose top 奇技淫巧列出所有的容器 ID1docker ps -aq 停止所有的容器1docker stop $(docker ps -aq) 删除所有的容器1docker rm $(docker ps -aq) 删除所有的镜像1docker rmi $(docker images -q) docker1.3之后的资源清理12docker image prune --force --all # 删除所有不使用的镜像docker container prune -f # 删除所有停止的容器","categories":[{"name":"docker","slug":"docker","permalink":"http://blog.fivezha.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.fivezha.cn/tags/docker/"}]},{"title":"页面置换算法之LRU算法(C++实现)","date":"2019-12-10T01:55:45.000Z","path":"2019/12/10/page-LRU/","text":"因为操作系统实验要写 所以写了 ?LRU(Least Recently Used)置换算法的描述 选择最后一次访问时间距离当前时间最长**的一页并淘汰之。 即淘汰没有使用的时间最长的页。实现代价很高(时间戳或硬件方法) !详见: GIthub Q0XctI.png 下面是测试数据, 根据的是上课的ppt: Q0jAgK.jpg Q0Xr0H.png 可以看到, 9次页面置换跟缺页率都是正确的","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"},{"name":"os","slug":"os","permalink":"http://blog.fivezha.cn/tags/os/"}]},{"title":"页面置换算法之FIFO算法(C++实现)","date":"2019-12-09T14:09:16.000Z","path":"2019/12/09/page-fifo/","text":"因为操作系统实验要写 所以写了 ?先进先出(FIFO)页面置换算法 选择在内存中驻留时间最长的页并淘汰之 !详见: GIthub Q0tuB6.png 下面是测试数据, 根据的是上课的ppt: testdata.jpg Q0tKHK.png","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"},{"name":"os","slug":"os","permalink":"http://blog.fivezha.cn/tags/os/"}]},{"title":"银行家算法的C++实现","date":"2019-12-05T12:12:48.000Z","path":"2019/12/05/bank-algorithm/","text":"因为操作系统实验要写 所以写了 银行家算法是一种避免死锁的方法在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。 银行家算法思想很简单这个算法中, 主要是维护其中的 available向量 max矩阵 allocation矩阵 每一次分配, 都会轮询一遍可分配矩阵, 寻求可以分配的process, 如果没有可以分配的process, 则跳出循环进行是否进入死锁的判断. 具体维基百科讲的其实比我好 银行家算法代码好写下面两张图一张是源码 一张是结果 其中数据来源于文件 可以方便自定义 具体可以见我的GitHub仓库 代码内容 内容","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"},{"name":"os","slug":"os","permalink":"http://blog.fivezha.cn/tags/os/"}]},{"title":"playframework初涉-2.配置MySQL并测试","date":"2019-10-10T16:14:27.000Z","path":"2019/10/11/play-study-s/","text":"悲伤的play framework + MySQL配置过程 因为playframework版本太低卸载mysql8首先有一件很悲伤的消息，下面这个版本 mysql8 ，因为play版本过低，无法完全兼容，需要降级到mysql5的版本，如果已经安装，那么可以以管理员启动命令行 cmd 然后先输入(前提是已经配置过mysql到环境变量 否则请到mysql文件夹中再执行) net stop mysql mysqld --remove real remove 之后整个删除整个mysql-8.0.12-winx64版本 然后安装MySQL5.7版本(地下群群文件里有)基本是一路next就可以了 这里也给个安装的教程 下面几项注意下 这里选custom安装 complete 这里选添加到环境变量 main 设定登录密码 login 这里务必选择utf8编码 utf-8 大概就是这些，最后一路next到底就行了，经过漫长的等待，可能会让你重启，重启就可以了 注：如果无响应，那就直接关了然后再打开安装文件，选择repair选项，完成之后重启 repair 重启之后再以管理员打开命令提示行，执行下面两行语句 mysqld -install net start mysql start 此时，便可以输入mysql -u root进入数据库了 不过这个开始时没有密码的，你需要输入以下两行更新密码 set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;123456&#39;);注：password()里面的就是你设定的密码 flush privileges;这一步是更新权限 change password 好了 这样你的数据库便配置完成了 然后新建一个database(mysql里的database等同于于scheme) create database test;(test是你新建数据库的名字 随便写) database 此时回到play你新建的app中在application.conf中设置mysql setting 如果你跟我做的一样，那么应该是下面这样: setting2 随后编写测试程序 user test 运行app，访问网址后，看到有正常输出 success 且数据库中有东西 sql 那么则说明配置成功了。","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"play","slug":"play","permalink":"http://blog.fivezha.cn/tags/play/"},{"name":"java","slug":"java","permalink":"http://blog.fivezha.cn/tags/java/"}]},{"title":"水题五道","date":"2019-09-12T12:10:14.000Z","path":"2019/09/12/lab-summer-question/","text":"实验室暑假考核题目 随便写写解题思路来着 824.山羊拉丁文 给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。 我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。 山羊拉丁文的规则如下： 如果单词以元音开头（a, e, i, o, u），在单词后添加”ma”。例如，单词”apple”变为”applema”。 如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加”ma”。例如，单词”goat”变为”oatgma”。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母’a’，索引从1开始。例如，在第一个单词后添加”a”，在第二个单词后添加”aa”，以此类推。返回将 S 转换为山羊拉丁文后的句子。 来源： leetcode 824 123456789101112class Solution: def toGoatLatin(self, S: str) -&gt; str: vowel = \"aeiouAEIOU\" spllit_str = S.split(\" \") for k, s in enumerate(spllit_str): if s[0] not in vowel: s = s[1:] + s[0] s += \"ma\" + \"a\" * (k + 1) spllit_str[k] = s return ' '.join(spllit_str) 很简单得暴力题目 直接搞定 1 1078.Bigram 分词 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 “first second third” 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。 示例 1： 输入：text = “alice is a good girl she is a good student”, first = “a”, second = “good”输出：[“girl”,”student”]示例 2： 输入：text = “we will we will rock you”, first = “we”, second = “will”输出：[“we”,”rock”] 提示： 1 &lt;= text.length &lt;= 1000text 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成1 &lt;= first.length, second.length &lt;= 10first 和 second 由小写英文字母组成 来源： leetcode 1078 12345678910111213class Solution: def findOcurrences(self, text: str, first: str, second: str) -&gt; List[str]: ans = [] split_str = text.split() length = len(split_str) for k, s in enumerate(split_str): if s == first and k + 1 &lt; length and k + 2 &lt; length: if split_str[k + 1] == second: ans.append(split_str[k + 2]) return ans 暴力完事儿，这里顺便优化一下，可以把60ms提到40ms左右 123456789101112class Solution: def findOcurrences(self, text: str, first: str, second: str) -&gt; List[str]: ans = [] split_str = text.split() length = len(split_str) for k, s in enumerate(split_str[:-2]): if s == first and split_str[k + 1] == second: ans.append(split_str[k + 2]) return ans 搞定 2 120. 三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源： leetcode 120 dp 说是空间复杂度O(N)，但其实这个题目空间复杂度可以到O(1) 先尝试用DFS 1234567891011121314151617181920class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: # DFS floors = len(triangle) def dfs(floor, left, right): # 判断是否最下层也计算过了 if floor == floors: return 0 # 最低端再往下权重就是0 ans = 0 # 初始为0 if left &lt; floor + 1: tl = dfs(floor + 1, left, left + 1) + triangle[floor][left] if right &lt; floor + 1: tr = dfs(floor + 1, right, right + 1) + triangle[floor][right] return ans + min(tl, tr) return dfs(1, 0, 1) + triangle[0][0] 结果果然华丽丽的超时了，打眼一看过了42个，卡在了最后一个，可能改改就能过了吧(可能性比较小，因为用C++试了下也超时，应该是卡的时间)，不过也是很极限了，所以改用dp写。 1234567891011class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: # dp floors = len(triangle) if floors == 0: return 0 for i in range(floors - 2, -1, -1): for j in range(i + 1): triangle[i][j] += min(triangle[i + 1][j + 1], triangle[i + 1][j]) return triangle[0][0] 这里可以不用开新的dp数组(无论是二维还是一维)，因为是从下往上的，只需要最终结果，所以可以直接利用原三角形数组当作dp数组，所以空间就变成了O(1)了。 不过这个才只打败了50%的人，甚至空间只打败了5% 3 下面这个是最快用时的答案： 123456789class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if not triangle: return res = triangle[-1] for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): res[j] = min(res[j], res[j + 1]) + triangle[i][j] return res[0] 从中，可以看到： 其实定义过多变量会减缓速度并且增加空间用量，编译器会给优化的。 尽量用一维list索引，速度会快很多 尽量使用相同的list进行索引，编译器会优化 872. 叶子相似的树 请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。 举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。 如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。 如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。 提示： 给定的两颗树可能会有 1 到 100 个结点。 来源： leetcode 872 treepic 直接前序遍历加判断，暴力就完事儿 1234567891011121314151617181920212223# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def leafSimilar(self, root1: TreeNode, root2: TreeNode) -&gt; bool: # 前序遍历 def tree_leaf_sim_calcu(root: TreeNode): stack, ans = [], [] # 用list while len(stack) or root: if root: if root.left is root.right is None: ans.append(root.val) stack.append(root) root = root.left else: root = stack.pop().right return ans return tree_leaf_sim_calcu(root1) == tree_leaf_sim_calcu(root2) 但其实这样只击败了44%的用户，看了一下用时快的回答，发现基本上都是用的递归，递归占用资源太大，所以就不改了，思想都是一样的。 4 为什么递归用时会短呢，这是因为python里的while循环是用纯python编写的，所以效率远不及简单函数堆栈的效率，所以会出现非递归比递归用时长的现象，如果用别的语言(没错就是C++)是不会出现这种问题的！ 863. 二叉树中所有距离为 K 的结点 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 输出：[7,4,1] 解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1 注意，输入的 “root” 和 “target” 实际上是树上的结点。上面的输入仅仅是对这些对象进行了序列化描述。 提示： 给定的树是非空的，且最多有 K 个结点。树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。目标结点 target 是树上的结点。0 &lt;= K &lt;= 1000. 来源： leetcode 863 dfs加父节点转成图问题再利用bfs寻找target为中心的节点。这里代码参考了标准答案，想看的去题解看第一个就ok了。 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def distanceK(self, root, target, K): \"\"\" :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] \"\"\" from collections import deque # 判断是否是本身 if not K: return [target.val] # dfs标记父节点 def dfs(node: TreeNode, father_node: TreeNode): if node: node.father = father_node dfs(node.left, node) dfs(node.right, node) dfs(root, None) # 这一步过后其实就变成了图问题，每个都有三个节点的图 # 下面对于target进行bfs def bfs(): search = &#123;target&#125; queue = deque([(target, 0)]) # 存0 即原点 while queue: if queue[0][1] == K: return [node.val for node, N in queue] node, N = queue.popleft() for n in (node.left, node.right, node.father): if n and n not in search: queue.append((n, N + 1)) search.add(n) return [] return bfs() 看了一下速度最快的回答，也是dfs建图+bfs搜索，除了一些骚操作，应该大部分都是优化这个思路的代码实现。 5","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.fivezha.cn/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"}]},{"title":"playframework初涉-1.环境配置","date":"2019-09-04T09:24:50.000Z","path":"2019/09/04/play-study-f/","text":"因为Javaee课要用这个框架 所以稍微学了下 1.运行环境配置1.1确保拥有Java环境检查环境： 可能之前有人配置过Java环境，所以首先先判断你是否有安装过Java，按下win + R键，出现运行界面 run 输入cmd会出现熟悉的命令提示框，此时输入Java然后按回车如果显示下面类似的便可以跳过到1.2去 cmd 如果是下图情况 wrong_env 请配置环境： 安装Java(请看群文件javaee文件夹或者自己去官网下载) 在此电脑右键点属性 env1](env1.png)![env1 双击点进去，如下配置 env3 一路点确定下去，最后再重复最上面的检查环境操作进行判断。 1.2 配置play framework环境这里选取的是1.5.1版本，可以在官网或者群文件中下载，然后找到你的play-1.5.1的下载的本地文件夹，解压缩后把play-1.5.1文件夹放到环境变量里 env_4 此时在命令框中输入play则会出现如下 play_env2 则说明环境已经配置好了 1.3 新建web项目这里只需要到你想要创建项目的文件夹中，按住shift + 右键 rc 然后输入play new 项目名 new 然后输入cd 项目名，在输入play idealize(用eclipse的话就是play eclipsify) succ 2. IDE环境配置配置好了运行环境，那么就应该开始配置我们使用的IDE环境了，这里有两个选择 IDEA eclipse 这这两个ide个人推荐使用IDEA，但是eclipse配置简单，这个只能说是见仁见智了。 2.1 配置IDEA找到idea安装文件(官网或者QQ群里有)，安装一直next到最后，出现选项选下面这几个 ch1 然后首次启动IDEA跟着下面的配置来就可以， ch2 ch2 这里是选择你的颜色主题 你可以选择暗色或者亮色 ch2 ch2 ch2 2.2 项目配置流程这里如果你按照上面的操作进行了play idealize操作之后，你项目的文件夹里面应该会出现一个项目名.ipr的文件，双击打开便可以直接打开idea并加载项目了。 首先先把下面的tips关掉(因为太烦人了) ch2 点开，左面的project出现文件结构，如果不一样请寻找是否有漏掉的步骤，然后打开controllers/Application.java可能会提示你填SDK，选择其中一个jdk就可以了 ch2 ch2 然后我们会发现因为docviewer导包问题会有一堆麻烦，所以我们直接删了就可以。 delete 然后我们配置启动程序 add add2 其中VM options是-Dapplication.path=. run3 然后我们开始运行，如果出现models不存在的bug，这个是因为你models文件夹里面没有存在文件，添加一个就可以了。 file 然后就可以运行了，当你看到 的时候打开浏览器，输入http://localhost:9000/回车 如果看见下面这个就说明配置成功了 succ","categories":[{"name":"assignment","slug":"assignment","permalink":"http://blog.fivezha.cn/categories/assignment/"}],"tags":[{"name":"play","slug":"play","permalink":"http://blog.fivezha.cn/tags/play/"},{"name":"java","slug":"java","permalink":"http://blog.fivezha.cn/tags/java/"}]},{"title":"opencv中高斯模糊(滤波器)的源码解析(c++版)","date":"2019-02-25T11:40:25.000Z","path":"2019/02/25/gaussianbulr-analyze/","text":"因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码 分析函数接口首先，在下用的是vs版本的opencv，是直接编译好给你静态库(.lib)文件的，所以当我按住ctrl寻找GaussianBlur这个函数时 只发现了其在imgproc.hpp里面提供给你的接口。 大概是下面这个样子的: 高斯模糊函数接口1 高斯模糊函数接口2 该函数将源图像与指定的卷积核进行卷积。并且支持原图像直接进行滤波操作。 可以看到这个函数接口主要由四个部分组成: CV_EXPORTS_W继续往上找 可以发现这是一个宏定义 else`的结构，主要的作用机理便是**适配各类环境(操作系统 ** 。从中，我们这里又分成了三个部分进行解析: #if (defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__) &amp;&amp; defined CVAPI_EXPORTS可以看到，这里判断了两个表达式的逻辑与((defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__)和defined CVAPI_EXPORTS) 首先，defined的意义在于寻找后面的字段是否已经被宏定义过。 其次，观察第一个表达式，发现_WIN32 在之前已经被定义过了，通过查阅微软官方宏定义文档发现这个字段作用是基于编译器一个信号，表明是Windows环境下编译及运行的程序。 Windows.h，那么 再次，观察第二个表达式，也是查找字段是否定义过，这个查了一下，发现这个宏定义是存在于opencv.dll这个文件里面的。也就是判断是否已经链接了动态库。 这样这一行便很容易懂了，目的便是判断程序环境是否为Windows且已经链接opencv.dll的库用以进行下一步操作。 再提一句，关于这个操作系统(环境)的判定其实还有很多，这里放一个Qt里面关于系统判定的头文件(147行开始)(版本比较老了 可自行再自己qt里查看) # define CV_EXPORTS __declspec(dllexport)这一句涉及到的主要是dll函数导入，需要和下面最后三行联合起来看#define CV_EXPORTS第二行需要联合上面这句一同分析，首先，这个头文件内部写的都是接口，都是作者自己编写留给别人用以调用的，并且从第一点分析的结果来看，这些接口的实现都是放在opencv.dll文件中的，而第一行的判断便是判断你是否在最需要隐式调用，如果有，那么直接可以利用隐式调用的方法进行函数导出(具体__declspec也有在微软文档里写)反之，如果判断事先未进行链接，那么使用的时候必然是显式调用(没错，就是配置环境的时候配置的lib文件链接，那就是显式调用了参考此篇文章)，既然是显式调用，自然便不需要进行函数导出操作。所以将CV_EXPORTS字段设置为空。 elif defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 4define CV_EXPORTS __attribute__((visibility(&quot;default&quot;)))这两句涉及的主要有两个功能: 1. 判断是否为GCC编译环境 2. 为全局动态库函数设置非隐藏声明对于第一点，类似于分析第一条，可以知道这句的意思便是检查gcc并测试是否高于4.0.0版本(猜测与c++标准有关) void函数返回值，这里返回值为空 GaussianBlur函数名，这里因为是声明所以是跟源码的函数一样，可以很快找到源码定义。 ()括号里面的是函数参数根据上面的说明注释，便可解读出这个函数所有参数意义: src 这是输入图像，这个图像可以拥有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。 dst 这是输出图像，大小与类型与src相同。 ksize 这是卷积核的大小参数(是数字desu)。其中ksize.width和ksize.height可以不同，但是它们必须是一个正奇数(或者零)，并且您不用担心卷积核内部参数问题，卷积核会根据sigma来计算。 sigmaX X方向的卷积核标准偏差。 sigmaY Y方向的高斯核标准偏差; 如果sigmaY为零，则设置为等于sigmaX，如果两个sigma都是零，则它们是从ksize.width和ksize.height计算的（详见cv :: getGaussianKernel）; 这些语义未来均有可能修改，建议指定所有ksize，sigmaX和sigmaY。 borderType 像素外推模式，请参阅cv :: BorderTypes sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur。这里显示了函数的相关函数，是观察源码的重要提示 这样，对于函数接口的解析就算是完成了，从中我们可以得出以下几个结论： 直接ctrl寻找到底是不能找到原函数代码的。 找到原函数的同时也需要sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur这一些列函数辅助理解。 这个函数在cv命名空间中，名称应该为cv::GaussianBlur 。 所以接下来第一步便是需要在源码中寻找到真正的函数实现。 源码解析理解高斯模糊函数高斯模糊函数本质是利用高斯滤波器对于给定图像进行平滑操作。平滑操作时什么，是减少噪点。噪点的原因又是什么，是单个像素包含的信息过于独立。如何减少噪点，很简单，只需要让每个像素点包含有周围像素的部分信息就行了呗。选用什么方法，最简单的方法便是——卷积(见下图)。利用一个给定的以某种分布函数构建的二维卷积内核，将中心点对准像素点，进行卷积操作，得到的像素点便包含了周围像素的不完全信息，这样子附近的像素点差异性便会越来越小，当整张图像(或选中部分)卷积完成后，每个像素点便不再过于独立，每个便有了附近像素点的信息，这样字图像便不会看上去那么的“扎眼”，会温润平滑许多，这就是高斯模糊的本质了。 卷积操作 [相信看图大概大家就能明白卷积是个啥东西了 再结合上面语句应该就差不多了] 查找函数利用grep命令，很容易便能找到这个函数，找到文件并切到这个函数定义，便可以窥见整个函数的全貌了。 查找 以下是cv::GaussianBlur函数全貌: func1 func2 分析函数分析这个函数之前，首先先要从内部关联的函数看起。 CV_INSTRUMENT_REGION()这一行末尾没有分号，这样的类似函数的字符段有很大可能是一个宏定义变量，经查找，在private.hpp文件中有以下定义： ///// General instrumentation // General OpenCV region instrumentation macro #define CV_INSTRUMENT_REGION() CV_INSTRUMENT_REGION_META(cv::instr::TYPE_GENERAL, cv::instr::IMPL_PLAIN) 经查找，这个字段主要是关于初始化以及边界类型的判断。 if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )1234567891011121314151617181920212223242526272829303132333435363738394041int type = _src.type();Size size = _src.size();_dst.create( size, type );/** 根据说明文档中所写的 BORDER_CONSTANT = 0, //!&lt; `iiiiii|abcdefgh|iiiiiii`with some specified `i` BORDER_REPLICATE = 1, //!&lt; `aaaaaa|abcdefgh|hhhhhhh` BORDER_REFLECT = 2, //!&lt; `fedcba|abcdefgh|hgfedcb` BORDER_WRAP = 3, //!&lt; `cdefgh|abcdefgh|abcdefg` BORDER_REFLECT_101 = 4, //!&lt; `gfedcb|abcdefgh|gfedcba` BORDER_TRANSPARENT = 5, //!&lt; `uvwxyz|absdefgh|ijklmno` BORDER_REFLECT101 = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_DEFAULT = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_ISOLATED = 16 //!&lt; do not look outside of ROI BORDER_CONSTANT 需要设置borderValue 指定 ' i ' 值（常数） BORDER_REPLICATE ，复制边界像素 BORDER_REFLECT ，反射复制边界像素 BORDER_REFLECT_101，以边界为对称轴反射复制像素*//* 这里是说如果边缘扩展不是常数扩展，且在规定图像范围内部，便执行下列操作*/if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )&#123; // 如果输入矩阵是一个行向量，则滤波核的高强制为1 // 下面同理 if( size.height == 1 ) ksize.height = 1; if( size.width == 1 ) ksize.width = 1;&#125;// 如果核宽跟核高都是一直接复制输出if( ksize.width == 1 &amp;&amp; ksize.height == 1 )&#123; _src.copyTo(_dst); return;&#125; CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))这里很明显是一个被宏定义的字段，通过查找，我们能够找到其定位在modules/core/include/opencv2/core/openvx/ovx_defs.hpp当中 func3 按每行解析的话就是如下: 123456789101112131415161718192021// 用于检测基于OpenVX的实现的实用程序宏#ifdef HAVE_OPENVX // 如果检测到OPENVX便执行下列语句 // 下面这两句主要作用也是标识 #define IVX_HIDE_INFO_WARNINGS // 隐藏警告信息 #define IVX_USE_OPENCV // 使用opencv的标识 #include \"ivx.hpp\" // 将hpp文件包含进来 #define CV_OVX_RUN(condition, func, ...) \\ // ...会被替换 // 这里为了给外界提供OpenVX使用表示 利用宏定义做成了一个接口 // 而这个接口则是主要为了提供硬件层面加速用的(主要面向对象是嵌入式设计) if (cv::useOpenVX() &amp;&amp; (condition) &amp;&amp; func) \\ &#123; \\ // __VA_ARGS__是可变参数宏定义 用以替换上面...的内容 return __VA_ARGS__; \\ &#125;#else // 否则便执行下面这条 #define CV_OVX_RUN(condition, func, ...)#endif // HAVE_OPENVX 其中useOpenVX()函数主要是返回一个bool类型的变量用以判断是否使用openVX用以计算。 所以CV_OVX_RUN()这句话便是对于嵌入式设计进行尝试性的优化操作。 ifdef至endif部分123456789//若之前有过HAVE_TEGRA_OPTIMIZATION优化选项的定义，则执行宏体中的tegra优化版函数并返回#ifdef HAVE_TEGRA_OPTIMIZATION // 拷贝到临时变量(暂不知为什么要拷贝到一个临时变量里面去) Mat src = _src.getMat(); Mat dst = _dst.getMat(); if(sigma1 == 0 &amp;&amp; sigma2 == 0 &amp;&amp; tegra::useTegra() &amp;&amp; tegra::gaussian(src, dst, ksize, borderType)) return;#endif 这里也显而易见是尝试tegra优化。 但是为什么拷贝到临时变量里也可以改变原值，这里需要进一步到Mat变量的运算符重载里面进行参考。 12345678910111213141516171819202122232425262728293031inlineMat&amp; Mat::operator = (const Mat&amp; m)&#123; if( this != &amp;m ) &#123; if( m.u ) CV_XADD(&amp;m.u-&gt;refcount, 1); release(); // 归零初始化 /** 归零后进行基本数据共享 */ flags = m.flags; if( dims &lt;= 2 &amp;&amp; m.dims &lt;= 2 ) &#123; dims = m.dims; rows = m.rows; cols = m.cols; step[0] = m.step[0]; step[1] = m.step[1]; &#125; else copySize(m); data = m.data; datastart = m.datastart; // 共享数据头 dataend = m.dataend; // 共享数据尾 datalimit = m.datalimit; allocator = m.allocator; // 内存共享 u = m.u; &#125; return *this; // 返回当前对象的引用&#125; 我们可以发现在=重载的时候仅是进行的浅拷贝操作，意思是只将数据头数据尾进行复制，而所有数据的内存数据都是相通共享的。固仅需要一方变量更改便会联动所有对其进行过浅拷贝的变量变化。 剩下部分1234567891011121314151617181920212223242526272829/** 这里主要是针对opencl(GPU加速)无法使用的情况进行CPU版本计算 这个IPP是一个Intel提供的开源的计算机视觉加速库，可以提供很多算法的Intel专属的多线程优化方案API，这也是为什么下面在opencl的gpu优化代码之后还又添加了利用CPU版本的filter2D的计算方案(因为有部分Intel专属的优化函数，针对APU和老式的Intel CPU(09年之前)无法进行计算，所以只能选取最普通的filter2D计算方案执行) 官网FAQ(有兴趣可以了解一下): https://software.intel.com/en-us/articles/intel-integrated-performance-primitives-intel-ipp-open-source-computer-vision-library-opencv-faq/*/CV_IPP_RUN(!(ocl::useOpenCL() &amp;&amp; _dst.isUMat()), ipp_GaussianBlur( _src, _dst, ksize, sigma1, sigma2, borderType));Mat kx, ky;/** 这里是新建一个高斯卷积内核(后面讲)*/createGaussianKernels(kx, ky, type, ksize, sigma1, sigma2);/** 这里是针对ksize = 3 or 5的情况做了opencl优化(A卡N卡均可享受opencl优化qwq)*/CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= 2 &amp;&amp; ((ksize.width == 3 &amp;&amp; ksize.height == 3) || (ksize.width == 5 &amp;&amp; ksize.height == 5)) &amp;&amp; (size_t)_src.rows() &gt; ky.total() &amp;&amp; (size_t)_src.cols() &gt; kx.total(), ocl_GaussianBlur_8UC1(_src, _dst, ksize, CV_MAT_DEPTH(type), kx, ky, borderType));/** 这里便是利用filter2D进行操作了 传入Point(-1, -1) 是指内核中的锚点(就是后面的anchor)位置。默认值（-1，-1）表示锚点位于内核中心。 0 则是存储单位 默认是0 后面会通过计算改变并存储*/sepFilter2D(_src, _dst, CV_MAT_DEPTH(type), kx, ky, Point(-1,-1), 0, borderType); 这里在下主要解析createGaussianKernels与sepFilter2D这两个函数，主要是因为无论是openvx_gaussianBlur还是ipp_GaussianBlur以及ocl_GaussianBlur_8UC1都有着大量未知的API，要读懂这些API还需要大量文档查阅，在下在此就先不解析了。 所以首先先来看一下createGaussianKernels这个函数： 1234567891011121314151617181920212223242526272829303132333435/** 这个函数仅是用于是创建高斯卷积核*/static void createGaussianKernels( Mat &amp; kx, Mat &amp; ky, int type, Size ksize, double sigma1, double sigma2 )&#123; int depth = CV_MAT_DEPTH(type); // 根据输入图像类型获得位深度 if( sigma2 &lt;= 0 ) sigma2 = sigma1; // 非正则与sigma1相同 // 从sigma自动检测内核大小(如果用户没有设置ksize的话) // 根据CV_8U来计算 大致接近7*sigma 或者 9*sigma // cvRound函数还内联了汇编 在下看不懂了 // |1 的原因是使宽高为奇数 if( ksize.width &lt;= 0 &amp;&amp; sigma1 &gt; 0 ) ksize.width = cvRound(sigma1*(depth == CV_8U ? 3 : 4)*2 + 1)|1; if( ksize.height &lt;= 0 &amp;&amp; sigma2 &gt; 0 ) ksize.height = cvRound(sigma2*(depth == CV_8U ? 3 : 4)*2 + 1)|1; // 这句只是为了保证卷积核的宽跟高是正奇数 CV_Assert( ksize.width &gt; 0 &amp;&amp; ksize.width % 2 == 1 &amp;&amp; ksize.height &gt; 0 &amp;&amp; ksize.height % 2 == 1 ); // 取最大 sigma1 = std::max( sigma1, 0. ); sigma2 = std::max( sigma2, 0. ); kx = getGaussianKernel( ksize.width, sigma1, std::max(depth, CV_32F) ); if( ksize.height == ksize.width &amp;&amp; std::abs(sigma1 - sigma2) &lt; DBL_EPSILON ) // 这里 如果判断核高与核宽相等，且sigma相差很小的情况下 // 便可以直接进行赋值操作，减少了计算量 ky = kx; else ky = getGaussianKernel( ksize.height, sigma2, std::max(depth, CV_32F) );&#125; 从中我们还需要解析getGaussianKernel这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768cv::Mat cv::getGaussianKernel( int n, double sigma, int ktype )&#123; // 这里定义了一个常量用以规定大小 const int SMALL_GAUSSIAN_SIZE = 7; // 一个4 * 7的矩阵，用于对奇数长度小内核进行优化计算 static const float small_gaussian_tab[][SMALL_GAUSSIAN_SIZE] = &#123; &#123;1.f&#125;, &#123;0.25f, 0.5f, 0.25f&#125;, &#123;0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f&#125;, &#123;0.03125f, 0.109375f, 0.21875f, 0.28125f, 0.21875f, 0.109375f, 0.03125f&#125; &#125;; /** 这里计算滤波系数（数组） 如果 内核尺寸为奇数 且小于7 并且sigma小于等于0 那么滤波系数便是根据上面的small_gaussian_tab决定的 否则便是0 */ const float* fixed_kernel = n % 2 == 1 &amp;&amp; n &lt;= SMALL_GAUSSIAN_SIZE &amp;&amp; sigma &lt;= 0 ? small_gaussian_tab[n&gt;&gt;1] : 0; /** 检测数据类型是否为float和double */ CV_Assert( ktype == CV_32F || ktype == CV_64F ); Mat kernel(n, 1, ktype); // 建立一维向量 // 定义指针指向数据 float* cf = kernel.ptr&lt;float&gt;(); double* cd = kernel.ptr&lt;double&gt;(); // 当sigma小于0时，采用公式得到sigma(只与n有关)，大于0就可以直接使用了。 double sigmaX = sigma &gt; 0 ? sigma : ((n-1)*0.5 - 1)*0.3 + 0.8; // 表达式中e指数要用到 double scale2X = -0.5/(sigmaX*sigmaX); double sum = 0; int i; for( i = 0; i &lt; n; i++ ) &#123; double x = i - (n-1)*0.5; // 根据上面计算出来的系数来决定是否重新计算值 double t = fixed_kernel ? (double)fixed_kernel[i]:std::exp(scale2X*x*x); //根据精度选择变量 if( ktype == CV_32F ) &#123; cf[i] = (float)t; sum += cf[i]; &#125; else &#123; cd[i] = t; sum += cd[i]; &#125; &#125; sum = 1./sum; // 归一化操作，计算需要除的数值 for( i = 0; i &lt; n; i++ ) &#123; if( ktype == CV_32F ) cf[i] = (float)(cf[i]*sum); else cd[i] *= sum; &#125; return kernel; // 返回建立好的一维内核&#125; 这两个函数的主要目的就是计算出高斯卷积核，这里选用分离计算，就是先计算水平（x）方向的一维卷积核，再根据sigma判断是否重新计算垂直（y）方向的一维卷积内核，这样子分离计算再针对尺寸较大的滤波器也可以有很高的效率，并且分离计算结合多线程也是很好的选择。 看完高斯内核的建立，我们知道高斯模糊主要利用了分离计算，那最后sepFilter2D函数也很容易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void cv::sepFilter2D( InputArray _src, OutputArray _dst, int ddepth, InputArray _kernelX, InputArray _kernelY, Point anchor, double delta, int borderType )&#123; CV_INSTRUMENT_REGION() /* 这里考虑如果输入函数是UMat形式且维度小于等于2的情况下 优先考虑使用opencl优化过的filter2D计算 */ CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= 2 &amp;&amp; (size_t)_src.rows() &gt; _kernelY.total() &amp;&amp; (size_t)_src.cols() &gt; _kernelX.total(), ocl_sepFilter2D(_src, _dst, ddepth, _kernelX, _kernelY, anchor, delta, borderType)) Mat src = _src.getMat(), kernelX = _kernelX.getMat(), kernelY = _kernelY.getMat(); if( ddepth &lt; 0 ) ddepth = src.depth(); _dst.create( src.size(), CV_MAKETYPE(ddepth, src.channels()) ); Mat dst = _dst.getMat(); /* 找到src的矩阵的矩阵头存入wsz当中，并且将偏移量存入ofs变量中 这两个变量用于快速读取全部图像 */ Point ofs; Size wsz(src.cols, src.rows); if( (borderType &amp; BORDER_ISOLATED) == 0 ) src.locateROI( wsz, ofs ); /* 进行预先检测内核是否有误 */ CV_Assert( kernelX.type() == kernelY.type() &amp;&amp; (kernelX.cols == 1 || kernelX.rows == 1) &amp;&amp; (kernelY.cols == 1 || kernelY.rows == 1) ); Mat contKernelX = kernelX.isContinuous() ? kernelX : kernelX.clone(); Mat contKernelY = kernelY.isContinuous() ? kernelY : kernelY.clone(); /* 生成一个二维滤波(filter2D)引擎 */ Ptr&lt;hal::SepFilter2D&gt; c = hal::SepFilter2D::create( src.type(), dst.type(), kernelX.type(), contKernelX.data, kernelX.cols + kernelX.rows - 1, contKernelY.data, kernelY.cols + kernelY.rows - 1, anchor.x, anchor.y, delta, borderType &amp; ~BORDER_ISOLATED); /* 调用这个引擎 */ c-&gt;apply(src.data, src.step, dst.data, dst.step, dst.cols, dst.rows, wsz.width, wsz.height, ofs.x, ofs.y);&#125; 剩下的便是寻找到这个引擎跟调用函数的实现了。 12345678910111213141516171819202122232425262728293031/* Ptr类似于boost::shared_ptr，它是Boost库的一部分 (http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm) 和 std::shared_ptr[C ++ 11标准]（http://en.wikipedia.org/wiki/C++11） P.S.其实大部分c++11标准都是boost库里面抄过来的*/Ptr&lt;SepFilter2D&gt; SepFilter2D::create(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType)&#123; &#123; ReplacementSepFilter * impl = new ReplacementSepFilter(); if (impl-&gt;init(stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType)) &#123; return Ptr&lt;hal::SepFilter2D&gt;(impl); &#125; delete impl; &#125; &#123; OcvSepFilter * impl = new OcvSepFilter(); impl-&gt;init(stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType); return Ptr&lt;hal::SepFilter2D&gt;(impl); &#125;&#125; 经查找，SepFilter2D是一个结构体，内含有上面的create函数以及两个虚函数(apply与析构函数)，这就说明对于不同的impl有着不同的apply跟init。 然后，从ReplacementSepFilter的函数开始看起: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** 这个结构体继承自SepFilter2D 具体作用便是使用hal api进行优化加速计算 是一个关于移动和嵌入式设计的库*/struct ReplacementSepFilter : public hal::SepFilter2D&#123; /** 这里的cvhalFilter2D是一个结构体 其目的就是作为context变量使用(ctx 便是context简写) */ cvhalFilter2D *ctx; bool isInitialized; /** 委托构造函数 委托了两个构造函数进行构造 一个是定义了context为0，另一个则是定义了isInitialized为否 关于context(上下文)这个概念可以百度一下 在下是看的这篇: https://wanderinghorse.net/computing/papers/context_types.html */ ReplacementSepFilter() : ctx(0), isInitialized(false) &#123;&#125; /** 初始化函数 */ bool init(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType) &#123; // 这里返回的值根据是否初始化成功赋值的 int res = cv_hal_sepFilterInit(&amp;ctx, stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType); // 这里首先判断res是否与CV_HAL_ERROR_OK(0)相等 // 如果不相等便将0赋值给isInitialized // 否则便是将1赋值 isInitialized = (res == CV_HAL_ERROR_OK); return isInitialized; &#125; /** 这个是ReplacementSepFilter的执行函数 */ void apply(uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int full_width, int full_height, int offset_x, int offset_y) &#123; if (isInitialized) &#123; // 这里是调用并返回是否成功的结果 int res = cv_hal_sepFilter(ctx, src_data, src_step, dst_data, dst_step, width, height, full_width, full_height, offset_x, offset_y); // 判断res是否与CV_HAL_ERROR_OK(0)不等 // 如果不等便无法调用 // 进入错误选项跳出滤波器 if (res != CV_HAL_ERROR_OK) CV_Error(Error::StsNotImplemented, \"Failed to run HAL sepFilter implementation\"); &#125; &#125; /** 这里的析构函数在本篇不解析 */ ~ReplacementSepFilter() &#123; if (isInitialized) &#123; int res = cv_hal_sepFilterFree(ctx); if (res != CV_HAL_ERROR_OK) CV_Error(Error::StsNotImplemented, \"Failed to run HAL sepFilter implementation\"); &#125; &#125;&#125;; 在接下来便是OcvSepFilter函数: 12345678910111213141516171819202122232425262728293031323334353637383940struct OcvSepFilter : public hal::SepFilter2D&#123; /** 建立一个滤波引擎 f */ Ptr&lt;FilterEngine&gt; f; int src_type; int dst_type; bool init(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType) &#123; src_type = stype; dst_type = dtype; /** 分离卷积所以建立了X与Y的卷积内核 */ Mat kernelX(Size(kernelx_len, 1), ktype, kernelx_data); Mat kernelY(Size(kernely_len, 1), ktype, kernely_data); /** 创建一个创建可分离的线性滤波器 */ f = createSeparableLinearFilter( stype, dtype, kernelX, kernelY, Point(anchor_x, anchor_y), delta, borderType &amp; ~BORDER_ISOLATED ); return true; &#125; void apply(uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, nt width, int height, int full_width, int full_height, int offset_x, int offset_y) &#123; Mat src(Size(width, height), src_type, src_data, src_step); Mat dst(Size(width, height), dst_type, dst_data, dst_step); // 因为Ptr将模板设置为了FilterEngine，所以这里apply调用的是FilterEngine的启动函数 f-&gt;apply(src, dst, Size(full_width, full_height), Point(offset_x, offset_y)); &#125;&#125;; 然后便是分析createSeparableLinearFilter 这个函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230/** 可以看到其返回的是是一个引擎， 所以里面肯定是有横向与纵向线性滤波器了(所以才使用可分离的qwq)*/cv::Ptr&lt;cv::FilterEngine&gt; cv::createSeparableLinearFilter( int _srcType, int _dstType, InputArray __rowKernel, InputArray __columnKernel, Point _anchor, double _delta, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; // 定义变量 Mat _rowKernel = __rowKernel.getMat(), _columnKernel = __columnKernel.getMat(); // 求矩阵的数组类型，数据类型包过通道数，深度，和据类型3种 _srcType = CV_MAT_TYPE(_srcType); _dstType = CV_MAT_TYPE(_dstType); // 求深度(输入输出都求) int sdepth = CV_MAT_DEPTH(_srcType), ddepth = CV_MAT_DEPTH(_dstType); // 求输入矩阵的通道数并判断输入矩阵是否与输出矩阵通道数相等 int cn = CV_MAT_CN(_srcType); CV_Assert( cn == CV_MAT_CN(_dstType) ); // rowsize int rsize = _rowKernel.rows + _rowKernel.cols - 1; // columnsize int csize = _columnKernel.rows + _columnKernel.cols - 1; // 如果内核锚点是负数，则从中心点开始进行 if( _anchor.x &lt; 0 ) _anchor.x = rsize/2; if( _anchor.y &lt; 0 ) _anchor.y = csize/2; /** 获得内核的类型 大致分为五种： KERNEL_GENERAL 通用内核 无任何对称性或其他属性 KERNEL_SYMMETRICAL kernel[i] == kernel[ksize-i-1] (系数对称)，且锚点位于中心 KERNEL_ASYMMETRICAL kernel[i] == -kernel[ksize-i-1] (系数相反对称)，锚点同上 KERNEL_SMOOTH 所有内核元素都是非负的并且总和为1 KERNEL_INTEGER 所有内核系数都是整数 */ int rtype = getKernelType(_rowKernel, _rowKernel.rows == 1 ? Point(_anchor.x, 0) : Point(0, _anchor.x)); int ctype = getKernelType(_columnKernel, _columnKernel.rows == 1 ? Point(_anchor.y, 0) : Point(0, _anchor.y)); Mat rowKernel, columnKernel; /** 在CV_32F, sdepth, ddepth中找到最大值并赋值给bdepth bdepth: 位深度 */ int bdepth = std::max(CV_32F,std::max(sdepth, ddepth)); int bits = 0; /** 判断如果 输入输出图像都是8位无符号型且内核使用平滑对称核 或者 输出图像为16位有符号型且使用整形对称或反对称核 那么就不需要进行任何转换便可以直接使用， 否则便需要转换，因为输入前后的图像格式是完全相等的 所以delta就默认是0了 */ if( sdepth == CV_8U &amp;&amp; ( (rtype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp; ctype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp; ddepth == CV_8U) || ( (rtype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp; (ctype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp; (rtype &amp; ctype &amp; KERNEL_INTEGER) &amp;&amp; ddepth == CV_16S ) ) ) &#123; // 重新给bdepth赋值 bdepth = CV_32S; // 此时bits(单位字节)将根据位深度进行计算，如果是8位无符号型则直接赋值为8位 bits = ddepth == CV_8U ? 8 : 0; // 此时将row内核转换为CV_32S，即32位整数型，并且根据单位字节转换比例因子 // 如果不加比例因子那么图像会变得很白 // (可参见这篇提问https://bbs.csdn.net/topics/392411554) // 比例因子：将原矩阵的所有元素乘以alpha _rowKernel.convertTo( rowKernel, CV_32S, 1 &lt;&lt; bits ); _columnKernel.convertTo( columnKernel, CV_32S, 1 &lt;&lt; bits ); // 在这里是将单位字节*2 bits *= 2; // 根据单位字节计算出了存储单位(偏移量) _delta *= (1 &lt;&lt; bits); &#125; else &#123; /** 如果不属于上面if里的任何一种情况，那么需要进行转换，用以使数据类型统一 */ if( _rowKernel.type() != bdepth ) _rowKernel.convertTo( rowKernel, bdepth ); else rowKernel = _rowKernel; if( _columnKernel.type() != bdepth ) _columnKernel.convertTo( columnKernel, bdepth ); else columnKernel = _columnKernel; &#125; // 缓冲区存储，用于写入单个色所有素信息(包括多通道与深度信息) int _bufType = CV_MAKETYPE(bdepth, cn); // getLinearRowFilter是根据不同的输入图像类型，输出图像返回不同的线性滤波器 Ptr&lt;BaseRowFilter&gt; _rowFilter = getLinearRowFilter( _srcType, _bufType, rowKernel, _anchor.x, rtype); Ptr&lt;BaseColumnFilter&gt; _columnFilter = getLinearColumnFilter( _bufType, _dstType, columnKernel, _anchor.y, ctype, _delta, bits ); // 利用这两个线性滤波器建立滤波引擎 return Ptr&lt;FilterEngine&gt;( new FilterEngine(Ptr&lt;BaseFilter&gt;(), _rowFilter, _columnFilter,_srcType, _dstType, _bufType, _rowBorderType, _columnBorderType, _borderValue ));&#125;/** 建立滤波引擎函数*/FilterEngine::FilterEngine( const Ptr&lt;BaseFilter&gt;&amp; _filter2D, const Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter, const Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter, int _srcType, int _dstType, int _bufType, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; init(_filter2D, _rowFilter, _columnFilter, _srcType, _dstType, _bufType, _rowBorderType, _columnBorderType, _borderValue);&#125;void FilterEngine::init( const Ptr&lt;BaseFilter&gt;&amp; _filter2D, const Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter, const Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter, int _srcType, int _dstType, int _bufType, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; // 依旧是获取类型 _srcType = CV_MAT_TYPE(_srcType); _bufType = CV_MAT_TYPE(_bufType); _dstType = CV_MAT_TYPE(_dstType); // 临时变量 srcType = _srcType; // 计算单个像素大小 // 下面会降解 int srcElemSize = (int)getElemSize(srcType); // 下面这些全是建立临时变量的 dstType = _dstType; bufType = _bufType; filter2D = _filter2D; rowFilter = _rowFilter; columnFilter = _columnFilter; // 这里是判断行列边缘类型是否出问题 if( _columnBorderType &lt; 0 ) _columnBorderType = _rowBorderType; rowBorderType = _rowBorderType; columnBorderType = _columnBorderType; // 检测边界填充类型是否不是wrap(复制元素填充)类型 CV_Assert( columnBorderType != BORDER_WRAP ); // 检测是否为可分离滤波器(因为这个是通用滤波引擎 并不知道是否为可分离滤波器) if( isSeparable() ) &#123; // 检测横纵滤波器类型是否相等 CV_Assert( rowFilter &amp;&amp; columnFilter ); // 并以横纵滤波器定义内核大小 ksize = Size(rowFilter-&gt;ksize, columnFilter-&gt;ksize); // 锚点也根据滤波器锚点定义 anchor = Point(rowFilter-&gt;anchor, columnFilter-&gt;anchor); &#125; else &#123; // 如果不是 检测缓冲图像类型是否与输入图像类型相等 CV_Assert( bufType == srcType ); // 这里跟上面定义差不多，不过是非分离滤波器所以是只有一个(filter2D二维滤波器) ksize = filter2D-&gt;ksize; anchor = filter2D-&gt;anchor; &#125; // 这个一看就懂了 CV_Assert( m 0 &lt;= anchor.x &amp;&amp; anchor.x &lt; ksize.width &amp;&amp; 0 &lt;= anchor.y &amp;&amp; anchor.y &lt; ksize.height ); // 根据边缘填充类型进行像素计算 borderElemSize = srcElemSize/(CV_MAT_DEPTH(srcType) &gt;= CV_32S ? sizeof(int) : 1); // 这里也很好懂 int borderLength = std::max(ksize.width - 1, 1); // 重定义边缘向量大小(这里是所占空间大小) borderTab.resize(borderLength*borderElemSize); // 初始化 maxWidth = bufStep = 0; constBorderRow.clear(); // 如果行列边界是常数填充的 if( rowBorderType == BORDER_CONSTANT || columnBorderType == BORDER_CONSTANT ) &#123; // 则计算图像边长 constBorderValue.resize(srcElemSize*borderLength); int srcType1 = CV_MAKETYPE(CV_MAT_DEPTH(srcType), MIN(CV_MAT_CN(srcType), 4)); // 根据位深度将边界像素值转换成可直接使用的vector变量 scalarToRawData(_borderValue, &amp;constBorderValue[0], srcType1, borderLength*CV_MAT_CN(srcType)); &#125; // 初始化size wholeSize = Size(-1,-1);&#125; 我们这时候来看上面提到的getElemSize: 最终这个其实是个宏定义，返回的就是这个宏定义计算的结果： (CV_MAT_CN(type) &lt;&lt; ((((sizeof(size_t)/4+1)*16384|0x3a50) &gt;&gt; CV_MAT_DEPTH(type)*2) &amp; 3)) 首先，针对0x3a50这个奇怪的数值，我们先转换为2进制查看规律，通过查找比对，发现其数值与变量类型有着一一对应的关系，然后16384则是1 &lt;&lt; 14的结果(刚好每个对应两位二进制数值)，这个换成二进制则是 ​ 16384 = 10 00 00 00 00 00 00 ​ 0x3a50 = 11 10 10 01 01 00 00 1 稍微先理解一下，在下先说一下剩下的函数然后一起解析。 这里先计算无符号整型的长度(在64位系统下是4 desu)然后除以4 再加上1 ， 就是说这是2 * 16384 | 0x3a50 就是 01 00 00 00 00 00 00 00 00 11 10 10 01 01 00 00 01 11 10 10 01 01 00 00 的结果右移2 * 深度，观察上面便会发现最终右移之后便使得最后两位二进制数对应的刚好便是对应变量类型所占的二进制数。 这样，在跟3(二进制为11)进行 ‘与‘ 操作，便能得到各个变量的对应所占字节数的对数了。 又因为这里是 通道数 * 2 ^ (所占字节对数) 所以这样就能够计算的出单个像素点所占用的大小(size)了 因为滤波引擎是一个通用引擎，还可用以驱动其他的滤波器(中值滤波或者其他什么的)所以主要的就只不过是根据一些信息初始化用以后面的操作(就是init函数的意思)。 返回了滤波引擎之后便是调用了，这个是apply函数: 123456789101112131415void FilterEngine::apply(const Mat&amp; src, Mat&amp; dst, const Size &amp; wsz, const Point &amp; ofs)&#123; CV_INSTRUMENT_REGION() CV_Assert( src.type() == srcType &amp;&amp; dst.type() == dstType ); // 返回变化y值 int y = start(src, wsz, ofs); // 传参的时候切除第一行与最后一列 proceed(src.ptr() + y*src.step, (int)src.step, endY - startY, dst.ptr(), (int)dst.step );&#125; 其中start便是开始函数后面的proceed则是持续卷积到整个图像的关键，start函数最终返回了起始的Y值，一句一句写太累了，我就不解释了，只贴出start与proceed函数： *这两块其实在下分析的很差，很多函数都没看懂，有很大可能错误，建议先跳过，在下以后c++学透了还会回来改的。 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225/** 滤波引擎 发动！*/int FilterEngine::start(const Mat&amp; src, const Size &amp;wsz, const Point &amp;ofs)&#123; start( wsz, src.size(), ofs); return startY - ofs.y;&#125;int FilterEngine::start(const Size &amp;_wholeSize, const Size &amp;sz, const Point &amp;ofs)&#123; int i, j; wholeSize = _wholeSize; // 根据偏移量与矩阵头设置范围 roi = Rect(ofs, sz); // 依旧是错误检测，很好懂 CV_Assert( roi.x &gt;= 0 &amp;&amp; roi.y &gt;= 0 &amp;&amp; roi.width &gt;= 0 &amp;&amp; roi.height &gt;= 0 &amp;&amp; roi.x + roi.width &lt;= wholeSize.width &amp;&amp; roi.y + roi.height &lt;= wholeSize.height ); // 下面这些依旧是初始化 int esz = (int)getElemSize(srcType); int bufElemSize = (int)getElemSize(bufType); // 定值检查 const uchar* constVal = !constBorderValue.empty() ? &amp;constBorderValue[0] : 0; int _maxBufRows = std::max(ksize.height + 3, std::max(anchor.y, ksize.height-anchor.y-1)*2+1); if( maxWidth &lt; roi.width || _maxBufRows != (int)rows.size() ) &#123; rows.resize(_maxBufRows); maxWidth = std::max(maxWidth, roi.width); int cn = CV_MAT_CN(srcType); srcRow.resize(esz*(maxWidth + ksize.width - 1)); if( columnBorderType == BORDER_CONSTANT ) &#123; constBorderRow.resize(getElemSize(bufType) *(maxWidth + ksize.width - 1 + VEC_ALIGN)); uchar *dst = alignPtr(&amp;constBorderRow[0], VEC_ALIGN), *tdst; int n = (int)constBorderValue.size(), N; N = (maxWidth + ksize.width - 1)*esz; tdst = isSeparable() ? &amp;srcRow[0] : dst; for( i = 0; i &lt; N; i += n ) &#123; n = std::min( n, N - i ); for(j = 0; j &lt; n; j++) tdst[i+j] = constVal[j]; &#125; if( isSeparable() ) (*rowFilter)(&amp;srcRow[0], dst, maxWidth, cn); &#125; int maxBufStep = bufElemSize*(int)alignSize(maxWidth + (!isSeparable() ? ksize.width - 1 : 0),VEC_ALIGN); ringBuf.resize(maxBufStep*rows.size()+VEC_ALIGN); &#125; // 调整bufstep，使环形缓冲区的已使用部分在内存中保持紧凑 bufStep = bufElemSize*(int)alignSize(roi.width + (!isSeparable() ? ksize.width - 1 : 0),16); // dx1是检测锚点位置是否与范围边界检测 dx1 = std::max(anchor.x - roi.x, 0); // 检测内核是否存在偏差 dx2 = std::max(ksize.width - anchor.x - 1 + roi.x + roi.width - wholeSize.width, 0); // 如果存在偏差则重新计算边界表 if( dx1 &gt; 0 || dx2 &gt; 0 ) &#123; if( rowBorderType == BORDER_CONSTANT ) &#123; int nr = isSeparable() ? 1 : (int)rows.size(); for( i = 0; i &lt; nr; i++ ) &#123; uchar* dst = isSeparable() ? &amp;srcRow[0] : alignPtr(&amp;ringBuf[0],VEC_ALIGN) + bufStep*i; // 在内存中用后者填充前者，最后一个参数是大小 memcpy( dst, constVal, dx1*esz ); memcpy( dst + (roi.width + ksize.width - 1 - dx2)*esz, constVal, dx2*esz ); &#125; &#125; else &#123; int xofs1 = std::min(roi.x, anchor.x) - roi.x; int btab_esz = borderElemSize, wholeWidth = wholeSize.width; int* btab = (int*)&amp;borderTab[0]; for( i = 0; i &lt; dx1; i++ ) &#123; int p0 = (borderInterpolate(i-dx1, wholeWidth, rowBorderType) + xofs1)*btab_esz; for( j = 0; j &lt; btab_esz; j++ ) btab[i*btab_esz + j] = p0 + j; &#125; for( i = 0; i &lt; dx2; i++ ) &#123; int p0 = (borderInterpolate(wholeWidth + i, wholeWidth, rowBorderType) + xofs1)*btab_esz; for( j = 0; j &lt; btab_esz; j++ ) btab[(i + dx1)*btab_esz + j] = p0 + j; &#125; &#125; &#125; rowCount = dstY = 0; /** 这整个函数其实最终要的就是这个 上面这些都是防止错误进行的调整 并用以计算下面这个值的 这个startY是另一方向的偏离值，就是说一个像素到另一个像素的偏离量 */ startY = startY0 = std::max(roi.y - anchor.y, 0); endY = std::min(roi.y + roi.height + ksize.height - anchor.y - 1, wholeSize.height); if( columnFilter ) columnFilter-&gt;reset(); if( filter2D ) filter2D-&gt;reset(); return startY;&#125;int FilterEngine::proceed( const uchar* src, int srcstep, int count, uchar* dst, int dststep )&#123; CV_Assert( wholeSize.width &gt; 0 &amp;&amp; wholeSize.height &gt; 0 ); const int *btab = &amp;borderTab[0]; int esz = (int)getElemSize(srcType), btab_esz = borderElemSize; uchar** brows = &amp;rows[0]; int bufRows = (int)rows.size(); int cn = CV_MAT_CN(bufType); int width = roi.width, kwidth = ksize.width; int kheight = ksize.height, ay = anchor.y; int _dx1 = dx1, _dx2 = dx2; int width1 = roi.width + kwidth - 1; int xofs1 = std::min(roi.x, anchor.x); bool isSep = isSeparable(); bool makeBorder = (_dx1 &gt; 0 || _dx2 &gt; 0) &amp;&amp; rowBorderType != BORDER_CONSTANT; int dy = 0, i = 0; src -= xofs1*esz; count = std::min(count, remainingInputRows()); CV_Assert( src &amp;&amp; dst &amp;&amp; count &gt; 0 ); /** 这里就是卷积的主函数了 */ for(;; dst += dststep*i, dy += i) &#123; int dcount = bufRows - ay - startY - rowCount + roi.y; dcount = dcount &gt; 0 ? dcount : bufRows - kheight + 1; dcount = std::min(dcount, count); count -= dcount; for( ; dcount-- &gt; 0; src += srcstep ) &#123; int bi = (startY - startY0 + rowCount) % bufRows; uchar* brow = alignPtr(&amp;ringBuf[0], VEC_ALIGN) + bi*bufStep; uchar* row = isSep ? &amp;srcRow[0] : brow; if( ++rowCount &gt; bufRows ) &#123; --rowCount; ++startY; &#125; memcpy( row + _dx1*esz, src, (width1 - _dx2 - _dx1)*esz ); if( makeBorder ) &#123; if( btab_esz*(int)sizeof(int) == esz ) &#123; const int* isrc = (const int*)src; int* irow = (int*)row; for( i = 0; i &lt; _dx1*btab_esz; i++ ) irow[i] = isrc[btab[i]]; for( i = 0; i &lt; _dx2*btab_esz; i++ ) irow[i + (width1 - _dx2)*btab_esz] = isrc[btab[i+_dx1*btab_esz]]; &#125; else &#123; for( i = 0; i &lt; _dx1*esz; i++ ) row[i] = src[btab[i]]; for( i = 0; i &lt; _dx2*esz; i++ ) row[i + (width1 - _dx2)*esz] = src[btab[i+_dx1*esz]]; &#125; &#125; if( isSep ) (*rowFilter)(row, brow, width, CV_MAT_CN(srcType)); &#125; int max_i = std::min(bufRows, roi.height - (dstY + dy) + (kheight - 1)); for( i = 0; i &lt; max_i; i++ ) &#123; int srcY = borderInterpolate(dstY + dy + i + roi.y - ay, wholeSize.height, columnBorderType); if( srcY &lt; 0 ) // can happen only with constant border type brows[i] = alignPtr(&amp;constBorderRow[0], VEC_ALIGN); else &#123; CV_Assert( srcY &gt;= startY ); if( srcY &gt;= startY + rowCount ) break; int bi = (srcY - startY0) % bufRows; brows[i] = alignPtr(&amp;ringBuf[0], VEC_ALIGN) + bi*bufStep; &#125; &#125; if( i &lt; kheight ) break; i -= kheight - 1; if( isSeparable() ) (*columnFilter)((const uchar**)brows, dst, dststep, i, roi.width*cn); else (*filter2D)((const uchar**)brows, dst, dststep, i, roi.width, cn); &#125; dstY += dy; CV_Assert( dstY &lt;= roi.height ); return dy;&#125; 总结 C++语法复杂度感觉世界上排的了前十 复杂但却也是少有的可以直接操作内存的语言之一，内联汇编效率不要太高 用轮子很简单，但是造轮子很难，造出普适性的轮子更难，自己用感觉有些算法还是很容易写的，但是要照顾到大量的其他语法或者平台那就很困难了 优化不一定是自己算法的优化，还有使用平台的优化，用别人的轮子真的很爽 大型项目里面代码风格各异，变量命名方案比较混乱，并且简写的比较多，看起来真的头大。。。。 在下的代码逻辑思维还是太低了，希望能够在毕业的时候看上20000行代码用以提升自己 相比之下python源码看起来真的舒服死了55555 借物表 attribute 机制详解(一) What is this #ifdef GNUC about? 关于VC预定义常量_WIN32，WIN32，_WIN64等预定义宏的介绍（整理、转载） opencv的CV_EXPORT 图像处理基础(4)：高斯滤波器详解 C/C++ 可变参数宏与VA_ARGS 宏 #、##、VA_ARGS和##VA_ARGS的作用 OpenVX嵌入式图像处理（一）硬件平台及软件介绍 OpenCV3.x中UMat对象介绍与使用 opencv学习之GaussianBlur()源码解析 手撕OpenCV源码之GaussianBlur OpenCV的一些宏 感谢以上各位大佬给在下提供的各类知识","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"cv","slug":"cv","permalink":"http://blog.fivezha.cn/tags/cv/"},{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"}]},{"title":"nazo.io攻略(完)","date":"2018-10-15T11:22:26.000Z","path":"2018/10/15/nazo-io-answer/","text":"一个小学玩过类似的解密游戏 最近发现竟然又发现了这种类型的游戏 鄙人玩了2个小时 写了点攻略 希望能够帮到你 顺便附上网址(其实就是nazo.io)1.欢迎 1 直接输入:welcome即可 2.规则 2 点击：key即可出现答案——gotcha 3.从右往左念 3 顾名思义，从右往左念：key is where 答案便是：where 4.完形填空 4 这关便是教你使用搜索引擎搜索答案（其实大多数时间搜不到。。。。 百度 答案便是：survival 5.Morse 5 摩尔斯电码，没什么好说的 答案：sos 6.Base64 6 就是base64解码 随便找个网站就行了 解密 答案：1029174037 6.Base64(新) image-20200712000900198 答案：bytealigned 7.OICQ 7 这个标题是qq的前身名称 这里有个提示：你刚输入了什么？/以及联系作者 很清楚 ，上一题的答案就是作者的QQ号 qq搜索 看 果不其然 答案：macintosh 7.RCNB.app(新) image-20200712001003985 编码随便百度一下就出来了 答案：unprintable 8.IDNs 8 这个题也是那种没有知识前提就不会的那种 正巧前两天刚买域名的时候看见了中文域名，所以这题小case😄 直接访问：错的是.世界便可知道答案 直接访问 答案：saionjisekai 9.角度 9 这张图片是斜角图片，就是字都向内偏向了45° 用画图打开拉长一下就知道答案了：pineapple 10.回到上世纪 10 典型的百度搜图题目 答案：mouse 11.Unicode 11 可能部分手机字库支持不全看不了 答案：neweroslesstofu 11.Unicode(新) image-20200712001517859 答案：oopscode 12.1A2B 12 小时候的猜数题目 大意是：有一个未知数需要猜测 下面0A0B代表不仅数字没猜对位置也没猜对 0A2B代表数字猜对了两个但是位置没猜对 3A0B代表着数字跟位置都猜对的有三位有一位数字跟位置都没猜对 答案：9506 13.虚无 13 中间有图片，新窗口打开便可知 新页面打开 答案：thealpha 14.我爱记歌词 14 hint是里的歌词是种子，歌名又是小苹果，图片名字叫apple 不用多说了吧 ——图种 图种 答案：greendam 15.声音的轨迹 15 音波解析 随便找个能看音波的软件就行了 妹子挺好看 答案：koenokiseki 16.虚掩 16 打开隐藏图片之后发现是多层结构 直接将遮罩层大小改为0 key显现 key 密码：secretvg 17.虚空 17 空格切换 这里的字符由全角跟半角的空格组成 替换任意一种便可知道答案 答案 答案：entropy 18.Twitter科学上网 18 打开发现居然作者是位打ctf的大佬 作者推特 答案：th4nky0u 18.Twitter(新)访问一下url就可以知道了 image-20200712001718333 答案：shortweet 19.最后感谢语 hit3 我是20位通关的(正儿八经的第20位 ←.hit1)，你呢？ 20.强迫症与总结(↑.hit2) 花了我2个多小时的游戏终于完美落下了帷幕 期初我只是想分享一下在群里，没想到大家兴致如此之高，以至于最后都为找到一个个key而兴致高涨😄 这种游戏果然需要跟大家一起玩才有意思嘛 总之，游戏体验良好，5⭐️ 好评！","categories":[{"name":"games","slug":"games","permalink":"http://blog.fivezha.cn/categories/games/"}],"tags":[{"name":"game","slug":"game","permalink":"http://blog.fivezha.cn/tags/game/"}]},{"title":"LaTeX数学符号","date":"2018-09-08T14:02:03.000Z","path":"2018/09/08/LaTeX-math-symbols/","text":"自己的LaTeX笔记 先贴教程总览！！公式常用字符 $$ + enter便可进入LaTeX编辑模式 ^ 上标 _ 下标 {} 块/分组 常用环境 \\begin{equation} 自动编号 \\label(eq: ```)标签 \\end{equation} \\ref{eq:} 引用 符号希腊字母 \\alpha \\beta \\gamma \\epsilon \\pi \\omerga \\Gamma \\Delta \\Theta \\Pi \\Omega 常用函数 \\log \\sin \\cos \\arcsin \\arccos \\ln \\sqrt[]{} 根式 \\frac{}{} 分式 矩阵 \\begin{matrix} 1 &amp; 1 \\\\\\ 1 &amp; 1\\end{matrix} 其中： &amp; 分割列 \\ 分割行 p小括号 b中括号 B大括号 v单竖线 V双竖线 \\dots 横向省略号 \\vdots 竖向省略号 \\ddots 斜向省略号 {n \\times n} n x n 分块矩阵(矩阵嵌套)其他命令 \\multicolumn{}{}{} 合并多列 \\raisebox{}[]{} 调整高度 \\hdotsfor{列数} 整列省略号 \\left ( 左括号 \\begin{smallmatrix} \\end{smallmatrix} \\right ) 右括号 行内小矩阵 \\begin{array}{c|c} \\hline 分割线 \\end{array} 多行公式 \\begin{gather} ==== \\notag 不自动编号 \\ *换行* ==== \\ \\ \\end{gather} {align} {split} {cases} 分段函数","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://blog.fivezha.cn/tags/latex/"}]},{"title":"git超简单教程","date":"2018-04-20T12:34:09.000Z","path":"2018/04/20/git-guide/","text":"git的超简单用法（以test-repository为例） 初始化1.初始化git的email与name首先先打开git(这个随便在哪个文件夹都可以) 12$ git config --global user.name \"这里写你的名字\"$ git config --global user.email \"这里写你的邮箱\" 2.设置ssh连接PS：这一步主要是防止他人盗用你的github账号所设置的双重保护，仅是为了安全，不设置这步也可运行 1$ ssh-keygen -t rsa -C \"这里是你的邮箱\" 然后你能在你c://用户//13256(这里是你的用户名)//.ssh里面找到以下三个文件 文件列表 然后登陆github网站 在setting里面找到ssh设置 然后新建ssh填入你id_rsa.pub里面的东西就ok了(title随便填) setting add key 然后点add key就完事儿了 连接仓库1.获取项目URL首先找到你想要clone（类似下载）到本地的项目页面按照箭头复制项目地址 enter image description here 2.在本地clone项目首先找到你想要在本地硬盘clone（下载）的地址 右键点击Git Bash Here enter image description here 然后输入以下指令（就只有第一行） git clone 你刚刚复制的网址 enter image description here 完成后关闭这个命令提示框！完成后关闭这个命令提示框！完成后关闭这个命令提示框！Then你就会发现在目录下有一个你clone的仓库的名字的文件夹了（如下图） enter image description here 3.进入clone后的仓库（文件夹）进行修改和push进入刚刚clone的那个文件夹，此时你可以随意修改文件内容 增加内容 修改完成后，在clone的文件夹里 右键然后点击Git Bash Here 然后输入下面三行指令 git add .git commit -m ‘随便上传点东西’git push origin master（主分支一般为master,如果你没别的分支就写master）注：第二行 ‘ ‘ 里面的东西随便写 这里主要写你push的东西主要修改了什么（会在项目上显示）push时可能会让你输入邮箱密码 填上就行 enter image description here 在项目中显示的修改信息 enter image description here 4.更新自己修改后的文件如果你后来修改了文件想要同步到github上面去的话，那么: 重复步骤 3中的 三个指令便可以了5. 分支开发这个有点大就直接放地址了菜鸟教程的教程 简单介绍的 还有廖雪峰老师的教程 ！推荐！讲的很详细！","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.fivezha.cn/tags/git/"}]}]