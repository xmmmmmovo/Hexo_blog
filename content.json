[{"title":"记录一次修复我的赛睿鼠标的过程","date":"2021-02-23T11:35:36.000Z","path":"2021/02/23/steelseries-mouse-change-microchip/","text":"我的鼠标坏了，一是左键单击变成双击了，二是滚轮一点也不灵敏了，总是滑半天页面才上下移动非常小的距离。 前言鼠标坏了，无缘无故的坏了，还是两处一起坏。首先是我的左键，我的左键现在点击一下变成了两下，导致我经常b站无法暂停视频，标签页连续关掉两个……其次则是我的滚轮，这个比我的左键更加的恶劣，基本上滚半天页面才移动非常小的距离，并且这个距离也非常的不定，经常时好时坏，有时一下滚很多，有时一点也不滚动，非常难受，像一滩淤泥一样，让我非常的恶心。所以我打算买点材料修理一下这个淤泥一样的鼠标。 左键问题经过查阅发现这个是微动芯片的问题。淘宝搜了一下，大概都在3~8元钱，所以果断下单了一个比较好的，只用了8元还包邮qwq。 IMG_20210223_212013 到货之后就是拆鼠标了，翻到后面拆下橡胶垫，下面有总共四颗螺丝，拧下来之后就可以直接把后盖拆下来了。 IMG_20210223_183638 IMG_20210223_184124 之后就是先断开彩色电源线，注意要拆下来主板的话要拧下来主板上的两颗固定的螺丝，然后把两边的卡扣往外一扣，直接就可以把主板整块的拆下。看见原装的微动芯片正是OMRON（都拆过一遍了你这不是废话吗），所以直接把淘宝的换上去就好了。 IMG_20210223_184313 P.S.：这个微动芯片旁边甚至写着大大的CHINA IMG_20210223_185104 焊接的过程就不讲了，因为板子后面写的很清楚，并且焊点清晰，锡的熔点也很低，很好搞。 image-20210223214527947 最后直接插上去加焊一下就好了 image-20210223214601128 滚轮问题根据知乎上的广大网友交流知道这个可能是滚轮传感器不灵导致的，所以只需要用酒精擦洗一下滚轮传感器的原件，去除氧化或者污物遮挡的部分，就能修好了，所以我这就来试一下这个方法。 因为当时没有留图片，就只能借一下知乎网友的图片了： v2-fbdfab010933dfc48c5acee6aae0633f_720w 就是把中间红色传感器拿酒精擦拭便可以了。 顺手还把各个原件拿酒精清理了一下~ IMG_20210223_184005 结语修理完成的我的鼠标，用两个字形容就是：“舒爽”，简直就像是新的一样，非常的流畅。这样我就不用再花钱买新的鼠标咯。","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"技术杂类","slug":"技术杂类","permalink":"http://blog.fivezha.cn/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E7%B1%BB/"}]},{"title":"【译】探索Rust中的动态分发","date":"2021-02-07T07:43:03.000Z","path":"2021/02/07/translation-Exploring-Dynamic-Dispatch-in-Rust/","text":"关于Rust中trait object和虚表 原文链接：Exploring Dynamic Dispatch in Rust 时间：2017-3-07 本文发表时间在2018edtion之前，观点可能不代表最新版本Rust（比如现在有了dyn关键词） 首先我要说的是我是Rust的新手（尽管到目前为止我很喜欢这门语言！），因此，如果我出现了技术错误，请告知我，我会试着纠正。所以，开始吧。在下面代码片段中可以看到我研究动态分发的真正原因。假设我要创建一个CloningLab结构体，其中包含一个由trait object（在本例中为Mammal）构成的vector： 1234567891011121314151617181920212223struct CloningLab &#123; subjects: Vec&lt;Box&lt;Mammal&gt;&gt;,&#125;trait Mammal &#123; fn walk(&amp;self); fn run(&amp;self);&#125;#[derive(Clone)]struct Cat &#123; meow_factor: u8, purr_factor: u8&#125;impl Mammal for Cat &#123; fn walk(&amp;self) &#123; println!(\"Cat::walk\"); &#125; fn run(&amp;self) &#123; println!(\"Cat::run\") &#125;&#125; 正常运行。你可以可以遍历subjects向量(vector)，并可以调用run或walk方法。但是，当你想对一个trait object添加一个额外的trait约束的话便会报错： 123456789struct CloningLab &#123; subjects: Vec&lt;Box&lt;Mammal + Clone&gt;&gt;,&#125;impl CloningLab &#123; fn clone_subjects(&amp;self) -&gt; Vec&lt;Box&lt;Mammal + Clone&gt;&gt; &#123; self.subjects.clone() &#125;&#125; 报错信息如下： 12345error[E0225]: only the builtin traits can be used as closure or object bounds --&gt; test1.rs:3:32 |3 | subjects: Vec&lt;Box&lt;Mammal + Clone&gt;&gt;, | ^^^^^ non-builtin trait used as bounds 这令我非常的惊奇。在我看来，一个具有多个约束的trait object大抵可以类比于C++中的多继承。我以为其中实例都拥有多个虚函数表指针(vpointer)对应每一个基类，并且能正确分发。鉴于Rust仍还是一门年轻的语言，我很理解为什么开发人员可能不希望引入这种复杂性大大提升的特性(一直坚持糟糕的设计则会事倍功半)，但是我想弄清楚这样的系统究竟是如何运作的(或无法运作)。 Rust中的虚表如C++那样，动态分发在Rust中是通过函数指针表实现的（在Rust文档中有描述）。根据文档，构成Cat的Mammal这个trait object的内存布局由两个指针组成，如下所示： cat_layout-2 令我惊讶的是，对象的数据成员还有一个中间层。这看起来和C++表示形式有所不同： cat_layout_cpp 先是虚表(vtable)指针，随后则是数据成员。Rust方法很有趣。 “构造”trait object时会产生成本，这与C++的方法不同，在C++中，强制转换为基类指针是零成本的（或者对于多重继承来说只是一些附加成本）。但这成本很小。 Rust方法的好处是，如果对象从未在多态上下文中使用过，则该对象不必存储虚表指针。我认为Rust励使用单态性这种说法比较好一些，所以这可能是一个不错的权衡方案。 多约束trait object让我们回到最开始的那个问题，让我们思考一下这个问题如何在C++中解决。如果我们有为某个结构体实现的多个trait(纯虚类)，那么我们的结构体实例内存布局将如下(例：Mammal和Clone)： cat_and_clone_cpp-1 可以看到我们现在有多个虚表指针，每个指针对应于Cat继承的一个基类（包含虚函数）。为了把一个Cat*转为Mammal*，我们不需要做任何事，但是要把Cat*转为一个Clone*，编译器将会为this指针增加 8 字节（用来跳到下一个指针，假定 sizeof(void*) == 8 ）。 不难想象在Rust中类似的情形： cat_clone_rust_candidate_1-1 所以现在在这个trait object里面有两个虚表指针了。如果编译器需要对于Mammal + Clone这个trait object履行动态分发的原则的话，它可以访问对应虚表中的对应项并执行调用。然而Rust(还)并不支持结构体继承，所以并不存在把正确的子对象作为self传递的问题。self永远指向的是data指针。 这看上去好像可以很好的运行，但是这种方案也带来了一些冗余。对于这个类型的大小（size）、对齐（alignment）以及drop指针使我们有了多份拷贝。我们可以通过组合虚表来消除这些冗余。这基本上就是当你执行 trait 继承时会发生的事情： 123trait CloneMammal: Clone + Mammal&#123;&#125;impl&lt;T&gt; CloneMammal for T where T: Clone + Mammal&#123;&#125; 以这种方式使用 trait 继承是一个通常建议的技巧，以绕过 trait 对象的正常限制。trait 继承的使用产生了一个单独的虚表，没有任何冗余。所以内存布局如下： clone_mammal_rust-1 译者：翻译到一半结果发现有人已经翻译完了😅️(人麻了) 那就直接贴网址吧 下面的基本是复制的翻译:点击跳转 更加简单！并且你现在就可以这么做！或许我们真正想要的是，当我们写出一个多约束的 trait 对象时，让编译器为我们生成一个这样的 trait（译者注：指仅含有单个虚表的 trait）。但是等一下，这里存在一些重要的限制。即，你不能把一个Clone + Mammal的 trait 对象转为一个Clone的 trait 对象。这似乎是很奇怪的行为，但是不难看到为什么这样的转换行不通。 假定你尝试写出下面的代码： 12345678910let cat = Cat &#123; meow_factor: 7 purr_factor: 8&#125;;// No problem, a CloneMammal is impl for Catlet clone_mammal: &amp;CloneMammal = cat;// Error!let clone: &amp;Clone = &amp;clone_mammal; 第 10 行一定无法编译，因为编译器不可能找到对应的虚表来放入这个 trait 对象。它只知道这个被引用的对象实现了Clone + Mammal，但是它无法区分这二者。当然，我们可以区分它一定是个Cat，但是如果代码像下面这样呢： 1234567891011121314151617let cat = Cat &#123; meow_factor: 7 purr_factor: 8&#125;;let dog = Dog &#123; ... &#125;;let clone_mammal: &amp;CloneMammal;if get_random_bool() == true &#123; clone_mammal = &amp;cat;&#125; else &#123; clone_mammal = &amp;dog;&#125;// Error! How can the compiler know what vtable to// point to?let clone: &amp;Clone = &amp;clone_mammal; 这里的问题就更加清晰了。编译器怎么知道要对 17 行正在构造的 trait 对象放入什么样的虚表呢？如果clone_mammal指向一个Cat，那么它应该是Clone的Cat虚表，如果它指向一个Dog，那么它应该是Clone的Dog虚表。 所以 trait 继承这种方式有这种限制。你无法把一个 trait 对象转成 trait 对象的其他类型，即使当这个你想要的 trait 对象比你已经拥有的更加具体。 多个虚表指针的方式对于具有多约束的trait对象来说，看起来是一种好的方式。通过它，转换为一个低约束的trait对象就不是问题了。编译器应该使用的虚表就是Clone虚表指针指向的位置。 下面就不是我复制的了 结论我希望完成这些能对一些读者带来收获。它肯定帮助我整理了对trait object的思考方式。在实践中，我认为这并不是一个真正紧迫的问题，这个限制只是让我感到惊讶罢了。 最终代码(自己实现)12345678910111213141516171819202122232425262728293031trait NewTrait: Mammal + std::clone::Clone &#123;&#125;struct CloningLab&lt;T: NewTrait&gt; &#123; subjects: Vec&lt;Box&lt;T&gt;&gt;,&#125;impl&lt;T: NewTrait&gt; CloningLab&lt;T&gt; &#123; fn clone_subjects(&amp;self) -&gt; Vec&lt;Box&lt;T&gt;&gt; &#123; self.subjects.clone() &#125;&#125;trait Mammal &#123; fn walk(&amp;self); fn run(&amp;self);&#125;#[derive(Clone)]struct Cat &#123; meow_factor: u8, purr_factor: u8,&#125;impl Mammal for Cat &#123; fn walk(&amp;self) &#123; println!(\"Cat::walk\"); &#125; fn run(&amp;self) &#123; println!(\"Cat::run\") &#125;&#125; 总的来说，解决思路便是以泛型限制trait object，可能是Rust团队希望单态和多态分别用不同的语法来实现吧。","categories":[{"name":"translation","slug":"translation","permalink":"http://blog.fivezha.cn/categories/translation/"}],"tags":[{"name":"rust","slug":"rust","permalink":"http://blog.fivezha.cn/tags/rust/"}]},{"title":"MacBook Pro(2020 M1)半个月使用体验","date":"2021-01-26T05:29:35.000Z","path":"2021/01/26/a-week-with-macbookpro-m1/","text":"记录我这半个月以来使用M1芯片版本的MacBookPro的各种优缺点和坑点 前言因为听闻Mac开发很爽之类的言论，再加上看了各种M1芯片评测视频之后，个人决定购买这台MacBook Pro (2020 M1)。以下便是个人这半个月来使用的体会。 外观 image-20210126183625360 image-20210126183902163 image-20210126184724275 传承着苹果一贯的设计，金属机身 + 抛光苹果LOGO + TouchBar。但是本次macbook的键盘再也不是之前让人诟病的蝶式键盘了，而是配备了全新的妙控键盘，个人认为手感还是不如本人上一个游戏本，但是对于一个轻薄本来说，也是能说得过去的水平。 触控板触控板可谓是MBP的灵魂所在了，又大又顺滑，同时多种手势和压感区分也让你面对这台电脑就如同面对一台巨大的iPad一样，毫不夸张的说，这个超大的触控板对于我来说已经是可以完美替代鼠标的存在了，配合TouchBar，基本上可以不用移动很多距离便可以完成许多操作。 屏幕Retina屏幕+HDPI，开机的那一刻，艳丽又精确的颜色，肆意又狂妄，让人赞叹又享受。同时macOS对于颜色管理这块也是拿捏的死死的，专用的屏幕颜色管理软件+方便的导入导出功能，让你随意切换色彩空间映射，真不愧是设计师的最爱。 TouchBar这个的确值得单独拿出来说，TouchBar在许多应用中都有适配，比如我现在正在使用的Typora，TouchBar上便是如插入代码块、图片、表格等常用的操作。 Typora 而在IDEA中则是编译和运行的快捷键，甚至在IINA中，TouchBar甚至展示了整个视频的预览，可以快速拖动。 IINA 接口本次的接口是非常不满意的，从四个TypeC变成了两个TypeC接口，同时支持USB4.0和雷电3协议，这就导致去掉电源占用的一个接口之后只剩下了一个接口提供日常使用，显而易见，扩展坞是少不了了。顺便一提，貌似雷电3协议的外设都非常贵（比如4K显示器啥的），个人偏向DIY(显示器之类的完全可以DIY)和寻找替代品。 M1芯片关于这个芯片的跑分就不说了，b站上很多up都说过。个人认为这颗芯片是要比10代低压i9要强的，平时生活中完全感受不到卡顿，基本上没有看到过占用100%的情况（可能是多核优化问题）。 性能 macOS 个人选择的是16g+512g的组合，虽然没用过8G版本，但是个人上一个游戏本开始使用的便是8G内存，开始如果说是日常使用还是比较够用的，但是如果打开多个IDE或者打开Android Srudio之后，内存就会被迅速占满，进而使用交换内存，到了这个时候，电脑即使使用ssd作为交换内存，也还是非常的卡顿，具体现象就是输入一个字母需要等待很久时间才会出现代码提示，并且经常性的无响应，需要等待许久才能恢复，同时虚拟机开发也无法进行，实在是难受至极。所以针对吃内存更加严重的macOS，个人果断选取了16g版本。因为IDE大多1g起步，并且还要加本地MySQL之类的应用，硬盘大小起步便需要256g了，如果再加上某些依赖文件夹(没错！说的就是你！node_modules！)，那磁盘占用绝对是巨量的，所以我选择了512g版本。 物理界最新黑洞理论结果 续航得益于ARM芯片的低功耗，本代续航能力达到了一个极其恐怖的地步，2个小时代码作业之后电量竟然只下降了15%。照着么推算官方说14个小时的续航时长大概是准确的。 image-20210214151814187 这次我找了个教室写了一下午代码+看视频，可以看到1点的时候是90%的电量，到了5点的时候则是近50%的电量。 可以看到在4个小时只是掉了40%的电量，所以说如果是轻度使用的话大概应该能撑到14小时左右，如果是一直coding+看视频大概也就10小时就耗完电量了。 image-20210305171343745 日常系统经过这半个月macOS的体验生活,个人感觉这的确是一个风格色彩突出的一个系统，有非常多的偏执的操作需要适应，没办法，大抵这就是从系统到芯片垄断的后果吧。 正常鼠标无法平滑滚动(软件解决) 明明设置鼠标滚轮方向和触摸板滚轮方向是不同位置的选项，但实际却是连通的选项(软件解决) Finder非常不好用，复制粘贴快捷键混乱(软件解决) 注意：m1版本的MacBook进入恢复模式是长按开机键 软件这里个人主要是来推荐一下自己日常经常使用的工具和应用~ Brew包管理器，相当于apt-get和yum。 iTerm2 + Oh-my-ZshShell美化套装，支持多种主题配色，搭配好了非常漂亮。 TyporaMarkdown编写软件，即时渲染，非常方便好用。 IINA颜值和功能兼顾的视频播放器，同时对于TouchBar兼容很好。功能很全面，各种常用的功能都有。 image-20210126233206444 Office365全家桶，不解释。 Parallels Desktop指定虚拟机，融合模式非常好用，有针对m1优化的版本。 Clipy一个剪贴板软件，完全免费，同时有片段保存功能。 image-20210126233106244 Snipaste截图软件，给你如同windows上qq截图一般的截图体验。 The Unarchiver一个免费的解压缩软件，用来替换本来的解压缩软件的。 PicGo图床软件，可以和Typora联合使用，支持多种图床。 image-20210126233816606 新建文件菜单顾名思义，给你的Finder里面加一个新建文件的按钮。 Mos给你更加流畅的鼠标滚轮操作。 image-20210126234123607 Motrix非常好用的开源免费下载软件，支持直链、链接、种子任务，其实是Aira2套娃，总的来说少有的免费还好用的软件。 image-20210126234409924 MagnetmacOS中非常好用的屏幕管理软件，可以快速的进行上下分屏，左右分屏，三等分屏等操作。 image-20210126235555476 ClashX好用的梯子，定制化功能非常多。 开发语言语言这块基本上很多都适配了，比如常用的C/C++，Java，Node Js，Go，Rust等语言都对于m1进行了适配。 IDEVisual Studio Code Insiders这里我使用的是ARM优化版本的vscode，整个使用下来是极其流畅的，基本上jupyter notebook都是秒开，同时文件渲染也很迅速，感觉比Clion还快很多。 image-20210127000440340 IDEA这里其实是代指的JetBrains全家桶，当然也是流畅的，不过第一次打开，输入第一个字母的时候要等一两秒才会出来提示，不过过了之后就丝滑顺畅。 image-20210127000733116 结尾总的来说，如果你是用来日常使用或者进行视频剪辑操作的话，这台电脑就完全够用了，甚至还有很多的性能溢出足以让你用3-5年也没问题。但是如果你是用来进行日常开发，编程等技术类的用途的话，个人建议是观望一段时间，因为大多数日常软件都已经适配了，但是开发相关的软件却有很多没有适配，亦或者是还存在许多Bug，所以提议观望半年或者等M1X。 还有就是关于为什么这段时间都没有发技术相关的博客了，主要原因是最近在准备毕业设计和找工作，背八股文和刷算法，没有什么可以写，如果有时间大抵可以把我最近《CSAPP》和《现代操作系统》的一些笔记分享一下，那大概就这样了，没什么好讲的了，该去学习了。","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"}]},{"title":"2020年，我都干了些什么？","date":"2021-01-01T13:53:51.000Z","path":"2021/01/01/what-i-do-in-2020/","text":"在2020年的末尾对于我整一年的学习经历进行的思考总结 前言本篇文章本来是应该1月1日完成的，但是突然出现了各种各样的事件，导致我在博客更新方面的计划一拖再拖，以至于现在才有时间来更新这篇迟来的年度总结(呜呜呜太难了)，为表歉意，在下也只能给大家看一看我元旦当天早上爬起来去山顶看日出的返图了~ 未升起 升起 2020年，注定是不平凡的一年，年初的疫情直到年末都还在不断影响着我们的生活方式，甚至感觉一年从开头到结尾都如此的压抑。 如果说去年一年的生活是自由且洒脱，那么今年则是闭塞而拘谨，比赛感情上的双重失利，不禁又使得自己对三年来建立起来的自信心产生了动摇，但是万事皆要以辨证的思想来看，正所谓祸兮福所倚，福兮祸所伏，这一年来我也学了很多，因为疫情原因，在家的时间可以说是比之前三年的总和还要多，使得自己可以静下心来学习一些东西的同时放松自己的身心，思考自己的规划方向，就在今年我的Github提交数达到了惊人的1728次，首次破干👏🏻👏🏻👏🏻。 image-20210115104751365 当然，生活再怎么苦，形式再怎么严峻，生活也还是要过的，趁着这我就简要回忆一下我这一年的成长与学习吧。 寒假寒假伊始，大家还未沉浸在抗疫救灾的紧张当中，除湖北地区可能还比较紧张，大家还是处于一种准备过年的愉快氛围当中，当然在下也是准备欢快过年的其中一分子 ，甚至母上打算除夕夜驾车去西安玩(PS：去了)，所以在下就在一些杂七杂八的家事，B站，一些杂乱的代码中度过了这年前的一段时间，平淡又无趣。 当时的我万万没想到的是，无趣的生活将因为疫情的原因如病毒般扩散至这一年的每一个角落。除夕夜，直到我、母上还有我妹到达西安的当天，全国的旅游景点宣告停止开放，使得两日不间断的驾车生活被宣告毫无意义，只得原路返回。恨，无比的憎恨，憎恨当时食用野味的那位“人才”(1.20更新：外交部发言人发话了！🇺🇸真有你的！)。但是又有什么办法呢，在浩瀚宇宙中，自己只是任人推搡的浮萍罢了，只能混迹在人群中随着宇宙变化，海水涨落而行动，此次我深刻的意识到了，要对于形势有着明确的认知，才能对于下一步有着正确的行动，不然，大多就是无用功罢了。 网课随着疫情的不断加重，我们不意外的被安排在了家里上网课。网课生活可以说是“惬意”的，因为本来就不想上那些没有什么兴趣的课程，如若在学校上课，电脑是一定带不到教室里面去的，而在家中上课，则可以以正当理由在课上使用电脑，给了我不小的便利，然而，这学期对我而言，其实实在是没有学到什么东西，大部分都是在兜兜转转中度过，在无所事事的瞎写中度过，在三分钟热度中度过，这其中大部分的原因也只能归咎与自身吧，但还有一些外部私事的影响导致了我这学期没有什么长进（这里恕在下无可奉告）。 这半学期中间其实还穿插了一个比赛，代码还没有开源，并且因为”某些原因“导致我们并未拿到很好的成绩，只能说自己还不够”努力“吧(笑)。 暑假暑假生活可以说是自己开始着手提升自我的开始，首先刚开始我便定下了考研的目标(虽然最后不考了)，开始准备考研。但是我内心实在是没有考研的兴趣，对于我来说，写代码远比枯燥乏味的做题有趣的多，所以我个人用了整整一个月的时间去刷了算法，学了一些之前没有怎么了解过的细枝末节的计算机知识，学习了《算法(第四版)》，在此一提，这本书实在是厚实，课后题对于我来说有点吃力，通常卡住一道题一天都有可能，但就在这时候我的算法提升迅速，周赛经常3~4题，还是很好的一本书的，内容极其详实，配图也很精美。 第二个月就是复习考研罢了（但其实根本没有复习，每天都是打打游戏看看视频啥的度过了），没什么好说的。 返校在经历了9个月的”假期“之后，我终于返回了有点陌生了的学校，见到了许久未见的兄弟们，终于可以愉悦的一起玩耍了(第二天晚上就出去搓了一顿饭)。但这时我其实还未开始复习，同时也要完成物联网大课设，最后完成课设，答辩完成之后已经是10月了，时间已经是不够用的状态了。9月-11月的生活可以看下面这篇文章：我停更的这两个月都在干什么 之后就在12月的时候，我发觉自己基本没有可能了(还有两科一遍都没有看完，政治也还没开始)，故放弃考研。这里说一下，个人认为研究生中，导师的作用是&gt;&gt;&gt;学校的作用的，因为研究生不是如同本科那样的思想来教学了，研究生对于方向，眼界和科研能力都有一定的要求，如果没有一个称职的导师，个人感觉至少我自己是很难一个人走下去的，我如果以极低的分数进去的话也比较难调到好的导师。所以我决定放弃考研，备战春招。 其中还有一个插曲，就是毕设选题了，关于其吐槽这个可以看下面这篇文章：关于学校毕设管理系统的吐槽 结语本文虽然不是1月1日发表的，但是却是1月1日开始写的，总结了我这一年来的经历，大抵也算是一篇垃圾流水帐吧，如若你能看到这里，在下在此表示由衷的感谢你能在浩如烟海的互联网中画时间看我这样一位小透明写的一篇流水帐文章，再次感谢🙏🏻。 每当鱼肚泛白，日出东方之时，便会感叹时间如白驹过隙，悄然流逝，希望新的一年能够一扫去年的阴霾，自信而又细心的迎接每一天，沉下心来学习，每次只做一件事并把它做好。 2020，再见👋🏻 2021，你好🙂️","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"思考感悟","slug":"思考感悟","permalink":"http://blog.fivezha.cn/tags/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F/"}]},{"title":"关于学校毕设管理系统的吐槽","date":"2020-12-11T03:34:34.000Z","path":"2020/12/11/final-project-wesite-bugs/","text":"只是一篇白开水文章，用来吐槽我们学校的管理系统的 前言有人问，马老师发生什么事了？我一看，奥，原来是昨天，有两个年轻人，一个码龄，三年多，一个码龄四年多。他们说：“诶…有一个说是毕设系统有问题，马老师你能不能教教我看”，然后上来就是一个html检索，吭，一个sql注入，一个字典查密码。我说年轻人不讲武德，他忙说对不起，他说他是乱注的。他可不是乱注的，一个“; and 1=1 and 1=2”， 一个“and 0&lt;&gt;(select count(*) from *)”， 训练有所，看来是有备而来。这两个年轻人不讲武德，来骗！来偷袭我这外包公司写的管理系统，这好吗？这不好。我劝这位年轻人，耗子尾汁。好好反思。以后不要再犯这样的小聪明。武林要以和为贵，要讲武德，不要搞窝里斗。 起因哈哈哈，开个小玩笑，来讲一下昨天一晚上发现的搞笑事情吧，起初题目公布了，我们就是浏览了一下，但是他这个系统选题没有指导老师，很烦，就打算从api来看是否有什么思路找出来。结果这一看直接傻眼了，我滴天哪，这个系统竟然把所有数据都写在了一个api里面，这我是真的没想到的，各种隐私数据，导师信息，需求分析，题目类别，id，就连导师密码都写在里面了，不禁令人直呼真牛哇！真牛哇！这都可以的吗，这种程度的程序员都能出来拿工资吗？？现在计算机行业这么不饱和？？ image-20201211120711154 起初，我就是把这些数据爬了下来然后提取了一下数据发群里然后就没再管，直到晚上朋友发的一句话才有了下面这些剧情……. 快乐的耍网站时间裸写在html里面的js和接口晚上，有一位朋友L说这个网站有bug，可以提前选课。起初我是很好奇的，因为提示的api只有一个校验，云端校验并且没有时间戳相关提交字段，怎么说都没办法绕过检测。然后就有了下面的对话： “选课的api和校验的api不是一个啊” “???不是，你怎么知道的api地址的” “直接根据idsearch一下就能找到了” 我立马根据他所说的去搜索了一下，然后就发现了下面的这段令人哭笑不得的代码： image-20201211122145573 奥，闹了半天这个云端校验就是个幌子，选课代码直接裸写到html里面，真有你的啊，青峰软件！到了这时，我才明白，这个网站根本就不是vue之类的主流框架写的，而是利用JQuery和Html粗劣的拼接起来的垃圾平台，甚至JS文件都不是引入+混淆，而是直接正大光明的写到文件里面，好家伙！我直接™好家伙！ 然后我就先自己选了~ image-20201212192048922 跨专业选题根据说明，本专业的人本来只能选本专业的题目的，然而既然选课api被发现了,又发现了参数信息，得知这个选题只要一个id就可以选了，那么我能不能拿别的专业题目来请求选课呢？答案竟然是可以的，后台完全没有对于专业进行相关的校验，直接就是可以随便选了，再次惊呼好家伙！ image-20201211125210778 SQL注入问题既然这个平台都这样了，为什么不再进一步呢，然后！就有了更加惊人的发现，这！个！网！站！居！然！没！有！做！防！注！入！ image-20201211125514580 再！次！好！家！伙！ 弱口令问题+密码加密问题本来弱口令不算做问题，但是教师的初始密码和****\\ (此处保密删除)，这就是很大的问题了。起初发现这个问题是因为在最开始获取数据的时候了解到了密码，查看格式知道是md5加密，本来这种加密手段直接弱口令表/彩虹表一查就出来的，然而，这里的规律提示所有老师的密码都是一样的……然后果断尝试**************(保密)，就……..就成功了！？好家伙，这也可以的吗？ image-20201211130751186 session没有黑名单这个就是老生常谈了，到了这个地步我已经不指望了。果然，没有黑名单处理，session直接持久化保存，不会被顶掉。CSRF攻击防御措施也没有，甚至有时候session id都是放在param里面的，不得不说外包公司的程序员真的是想象力”天马行空”。 结语根据上面的各种漏洞，我们基本可以做到： 利用老师的cookie进行sql注入，达到删库或者shell提权操作，搞垮平台或者直接全部删掉(包括binlog)，然后直接溜之大吉不被任何人发现。 吐槽到这，心理已经对这个学校失望透顶了，外包都只能找到这种程度的，这种甚至不该是公司产品，只不过是一个学生的课程设计级别的罢了。不，可能真的是学生作品，外包公司二次外包，三次外包，最后流入到学生手上的又有多少呢，这一层层之间回扣又吃了多少占比呢，我不敢想象，只能感叹：“还好大学四年没有选择赚钱而选择了学习啊！” 希望学弟学妹们也要引以为戒，写出来能用的代码很容易，写出来可以用的代码却很难，不要老想着那些既得利益，而要长远观察自身的潜在价值，明白自己这个阶段该学习什么，能有什么竞争力，能有什么样的金钱效应，为自己得到什么利益。不要最后35岁烂在外包公司写这种垃圾代码最后“被优化”。 天下熙熙皆为利来，天下攘攘皆为利往 人总是会为了利益不择手段的，哪怕是骗，抢。","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"思考感悟","slug":"思考感悟","permalink":"http://blog.fivezha.cn/tags/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F/"},{"name":"技术杂类","slug":"技术杂类","permalink":"http://blog.fivezha.cn/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E7%B1%BB/"}]},{"title":"我停更的这两个月都在干什么","date":"2020-10-15T14:03:36.000Z","path":"2020/10/15/recent-situation-2020-10/","text":"本博客可能要有一段时间不更新了(泣) 前言已经有一段时间(两个月)没更新过博客了。上下思索，主要有两个原因：一是开学了，事务变多，无心管理博客相关更新，再加上大四的老狗已经无法再在实验室混日子了，导致我现在碰电脑的时间几乎消失掉了；二是面临考研（其实我是不想考的 但是被父母裹挟 很难受），从早晨6：30起床去图书馆再到晚上9：30回去，11点宿舍熄灯，实在是没有时间进行长时间的编程作业，对于博客也没有有效的产出。综上原因，本博客大概率在12月28日之前不会更新了。 正文那么开学的这两个月我到底干了什么呢？细细想来大概就几件事情了。 物联网大课设首先便是物联网大课设了，这个课设的全面程度其实大概是和毕设差不多的吧，不仅要前端后端硬件，还需要安卓来辅佐，实在是全(sang)面(xin)完(bing)善(kuang)呢。 image-20201015225354513 上面虽然说的四个人组队，但是如果真的经历过课设/大作业的懂得都懂，其实大多是时间就是一个人写完。这个课设说混也好混，因为课设不挂人，只要你过去了，然后项目能跑起来，就能过(分数不在考虑范围)。然而我不知道怎么想的，就是愣是想要把这个课设做的尽量的完美，可能是为了给自己大学四年的技术栈做一个总结吧，我这么想着，就做了整整半个多月，甚至还抽出一天通宵写课设。可以说这个课设是融入了我大学学来的精华了。 开源地址：https://github.com/xmmmmmovo/SmartGreenhouse 通宵时间 最后附上一张项目的架构图片： 架构图 和一点截图： 安卓 web 综测奖学金这个事情算是近期来最舒服的一件事情了(毕竟没有人跟钱过不去)，经过了一整年的艰苦学习，终于拿到了一等奖学金了。回首这一年的学习时光，实在是艰辛，前半年每节课都坐在第一排认真听课，在最后一周无数门考试考试周中拼尽力气，在这后半年网课生活中，通宵写文档，可以说这一年，很累，但是确实是我大学三年废物生活中最有意义的一年了。 image-20201016085946052 IMG_20201113_231300 对了，这个事情还收回了我当时大二结束立下的flag，成功收回一等奖学金flag，舒服~ 玩乐虽然考研复习很紧张，本鼠人还是抽出了国庆一天时间跟朋友出去尽情的玩耍，吃了海底捞(我的奖学金​哭了😥​)，看了姜子牙。最大的感触可能就是希望自己像最后彩蛋里那样，一战封神吧。 快乐的火锅人 等待排队时候的咖啡 祝大家一战封神 复习关于复习进度，其实由于自身原因，已经不知道拉下多少进度了，已经准备不去考研去找工作了。 结语感谢你能有耐心来看本废物的这篇流水账文章，我虽然平日自嘲为废物带学生，但是真的到了该拼一枪的时候还是会去稍微的努力一下的，正所谓”宁可身冷，不可心冷；宁可人穷，不可志穷”。再高耸的山峰，如若自己在山脚便退却，便永世不得参得一览众山小的美貌了。","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"通知","slug":"通知","permalink":"http://blog.fivezha.cn/tags/%E9%80%9A%E7%9F%A5/"}]},{"title":"记一次核酸检测经历","date":"2020-08-22T16:23:45.000Z","path":"2020/08/23/fever-test/","text":"记录一次很慌的核酸检测经历 前言收到电话通知了，没有事情，检测是阴性，烧也退下去了。 起因20号早晨莫名其妙发烧了，本来以为没事情的，结果吃了退烧药啥的都不管用，一直到了第二天还在发烧，有点慌了，就去医院做了一下核酸检测。 image-20200822012126040 过程总结一下 核酸检测 的基本步骤吧: 填表 医生采样 完毕 看上去就这么简单吧, 但是这个采样又是什么样子的呢? 这里其实有两种方案, 第一种就是下面这种,先来看看描述: 采样人员一手轻扶被采集人员的头部，一手执拭子，拭子贴鼻孔进入，沿下鼻道的底部向后缓缓深入，由于鼻道呈弧形，不可用力过猛，以免发生外伤出血。待拭子顶端到达鼻咽腔后壁时，轻轻旋转一周（如遇反射性咳嗽，应停留片刻） ，然后缓缓取出拭子，将拭子头浸入含2～3ml病毒保存液（也可使用等渗盐溶液、组织培养液或磷酸盐缓冲液）的管中，尾部弃去，旋紧管盖。 听上去是不是云里雾里的? 然而相信我, 直接看到图片之后直接会 心 肺 停 止 的, 你看这难道不是处刑吗? img img img 啊哈, 不过好在这里还有第二个方案, 也是更加普及的方案: 被采集人员先用生理盐水漱口，采样人员将拭子放入无菌生理盐水中湿润(禁止将拭子放入病毒保存液中，避免抗生素引起过敏)，被采集人员头部微仰，嘴张大，并发“啊”音，露出两侧咽扁桃体，将拭子越过舌根，在被采集者两侧咽扁桃体稍微用力来回擦拭至少3次，然后再在咽后壁上下擦拭至少3次，将拭子头浸入含2～3ml病毒保存液（也可使用等渗盐溶液、组织培养液或磷酸盐缓冲液）的管中，尾部弃去，旋紧管盖。咽拭子也可与鼻咽拭子放置于同一管中。 “看上去”是不是更加”温柔”了?啧啧啧, 请看下面这个图: img 没错! 这个就是直接往你喉咙里捅…….直接捅到嗓子眼的那种…… ”什么？你以为是二选一？“哦不，是两个都要做！感觉呢，感觉就是非常酸爽，就像是吃了一斤的芥末混合着催吐剂一样，整个人都不好了。。。 img 后续也不知道怎么作下了，一直发烧到了22号才有所好转，体温恢复了正常，但是头痛难忍+胳膊莫名其妙的极其酸痛使得我现在无法入睡，只得起床写下此篇小记，用以记录和转移注意力缓解疼痛感。。。。 最后附上检查结果： image-20200823013551713 不过医生的字真的是草的不得了。。。。但起码还能看懂点。。。。 image-20200823013649688","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"}]},{"title":"给准大一的萌新们的一份小指南","date":"2020-08-11T03:29:51.000Z","path":"2020/08/11/freshman-guide/","text":"本文章原写于2019-08-14，现转移到个人博客上用来继续给各位刚入大学的萌新指出一条路来。 前言首先欢迎来到中北大学大数据学院！ 这个暑假，强烈建议打一下C语言，高数的基础，还有请不要忘记你所学过的英语知识。 开学虽然没有考试，但是你要想比别人走的更远，请先比别人准备更多的东西。 开学之后会有实验室宣讲纳新，咱们院的话具体有安卓，动漫，物联网，自主可控，大数据与网络安全，ACM/ICPC集训队。(注:群文件里有咱们院各个实验室简介,可以先简单了解一下,但还是要看宣讲选择) 软件学院有ACM实验室和网络安全研究所，喜欢硬件机器人或者机械之类的话六院（仪器电子）有机器人实验室，五院（信息与通信）有卓创，信号与系统，十五院（电器）有电子，电气，轨道等等。 所以说，基本上只要有想学的方向都会有相应的学习平台。 P.S. 群文件里已经根据下面的标题分好类了所以下面所有群文件资料地址请看标题。以后群文件代指群文件里/标题名文件夹 工具解压缩工具 bandizip (BANDIZIP-SETUP.exe) 一个免费轻量的压缩解压缩工具 并且里面的自动解压功能很好用！ 下载工具 百度网盘下载(这里本来是pandownload的，但是凉了) qBittorrentEE-v4.2.5.12 PDF阅读工具 文电通PDF reader(GaaihoReader_CHS_ALL_4.20.exe) 一个台湾公司出品的软件，免费没有广告，并且很轻量！ Adobe Acrobat C语言这门课是你们刚上大学便会开的课程，并且也大概率是你学的第一门语言，重要性不必分说。 并且实验室面试也是会参考一部分C语言知识储量的，所以很重要！ 资料！编程软件编程软件乃是基础，群文件里有电脑端跟Android手机端(IOS请自行解决因为我也没用过233333)两个编程软件： DEV-Cpp(Dev-Cpp 5.11 TDM-GCC 4.9.2 Setup.exe) 电脑端软件 安装步骤也是配套的 SimpleC(simpleC_1.2.29.apk) Android编程软件 C/C++-programming language 离线 IOS编程软件 这个因为苹果政策原因只能贴AppStore网址了 https://apps.apple.com/cn/app/c-c-programming-language-%E7%A6%BB%E7%BA%BF/id1016322367 C/C++$ 同样是IOS上的，这个是上面那个的付费版多了代码提示 https://apps.apple.com/cn/app/c-c-%24/id1003101482 书本群文件里有一本C Primer Plus (第五版) 中文版.pdf，这本书讲授C语言很全面，基本各个类型均有涉及，比课本要讲的清晰明确，是很好的入门书籍。 视频这边推荐浙江大学翁恺老师的网课，网易云课堂/中国大学MOOC跟B站搜索翁恺便可找到 下面贴出网易云课堂的网址： https://mooc.study.163.com/course/1000002011#/info 中国大学MOOC还没有开课也贴一下： https://www.icourse163.org/course/ZJU-199001 Pythonpython作为一门类脚本语言，其最大的特点就是简单易学，入门迅速，并且上手后很容易写出成品程序，可以快速树立编程信心，让自己对编程有兴趣，多写代码也对自己大有益处。 环境配置 群文件里有Environment Variable Setting.zip文件 这个是自动配置脚本 如果不会使用也可以参考下面的博客:https://zhuanlan.zhihu.com/p/42984735 教程 廖雪峰博客：全面而又细致的入门级教程，不过只有纯文字https://www.liaoxuefeng.com/wiki/1016959663602400 莫烦python：带有视频，容量上较廖雪峰先生博客少https://morvanzhou.github.io/tutorials/python-basic/basic/ 十分钟 Python 从 Zero 到 Hero：适合有一定基础的(学过至少一门语言的)https://zhuanlan.zhihu.com/p/33406196 高等数学高等数学，以下简称高数。这是你们大学生活中极其重要的一门学科，因为计算机 ≈ 数学知识的应用，所以高数线代概率请务必打好基础。 并且在日后的编程中，无论是业务还是算法，用到数学知识的地方都是极多的，尤其是当下最热门的人工智能方向，更是数学应用的极致体现。 资料 PPT 群文件里有高数上课用的PPT 川大徐小湛老师的视频 这个讲的很慢很仔细 适合没有基础的萌新看 上部分视频：https://www.bilibili.com/video/av57879350?from=search&amp;seid=1260147609372582774 下部分视频：https://www.bilibili.com/video/av57932680?from=search&amp;seid=1260147609372582774 英语知识不要扔掉英语！ 不要扔掉英语！ 不要扔掉英语！ 大学生尤其是计算机系的学生，英语极其重要，因为第一手，最前沿的资料大多都是英文资料，不要等着有人翻译成中文，因为那时这个技术已经落后了！ 所以先从单词开始，像高中那样慢慢积累吧，因为一门语言是不可能一蹴而就的。 不要忘了大学等级考试也是很重要的。 写在最后上面说了很多，但是并不是让你都学习，浅尝辄止不如不学，还有半个月的暑假生活，在下希望宁们能够把其中一样做好便已经超出大部分人很多了。 ​ ​ ———-2019.08.14 ​ 卑微小扎","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"萌新指南","slug":"萌新指南","permalink":"http://blog.fivezha.cn/tags/%E8%90%8C%E6%96%B0%E6%8C%87%E5%8D%97/"}]},{"title":"算法(第四版)笔记(7)---二分搜索和一些应用","date":"2020-07-30T22:57:49.000Z","path":"2020/07/31/algorithm4-1-binary-search/","text":"二分搜索和一些用到二分思想的题目 前言二分搜索可以说是应用非常广泛的一类算法了，非常多的暴力算法优化方案都是在一些条件下用二分，并且二分效率很高，可以让$\\mathcal{O}(N)$算法秒变$\\mathcal{O}(log_2N)$，效率大大提高(超时就先往二分上靠再说)，故本篇文章就讨论一下二分算法和一些关于二分的题目。 二分搜索最基础的版本，用于在一个有序序列中查找需要的元素： 1234567891011121314151617181920212223242526272829303132333435/** * 在一个列表中二分查找到某个值 * @author xmmmmmovo * @date 2020/7/28 11:46 * @param list 列表 * @param key 需要查找的值 * @param lo 左范围 默认为0 * @param hi 右范围 默认为list.size - 1 * @return 查找到了就返回下标，没查找到就返回-1 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; binarySearch( list: List&lt;T&gt;, key: T, _lo: Int = 0, _hi: Int = list.size - 1): Int &#123; var lo = _lo var hi = _hi while (lo &lt;= hi) &#123; val mid = lo + (hi - lo) / 2 when &#123; key &lt; list[mid] -&gt; &#123; hi = mid - 1 &#125; key &gt; list[mid] -&gt; &#123; lo = mid + 1 &#125; else -&gt; &#123; return mid &#125; &#125; &#125; return -1&#125; 因为每一次都会是比上一次缩减1/2的搜查量，$\\cfrac{N}{2^k} = 1$，所以时间复杂度为$$\\mathcal{O}(\\log_2N)$$空间复杂度为$$\\mathcal{O}(1)$$ 查找列表中是否存在某元素查找列表中是否存在某元素，这个问题，其实用遍历或者二分都可以解，并且不会特别影响时间复杂度，因为排序算法时间复杂度$\\mathcal{O}(Nlog_2N)$已经决定了这个算法的时间复杂度，但是利用二分搜索更能提升算法效率，说不准就卡那么几毫秒。 123456789101112131415/** * 查找列表中是否存在某元素，利用[binarySearch]二分查找 * @author xmmmmmovo * @date 2020/7/28 11:49 * @param list 列表 * @param key 需要查找的元素 * @return 返回是否存在 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; containsInList(list: List&lt;T&gt;, key: T): Boolean &#123; val sorted = list.sorted() // 这里调用了上面的函数 val res = binarySearch(sorted, key) return res != -1&#125; 时间复杂度：$$\\mathcal{O}(Nlog_2N + log_2N)\\\\=\\mathcal{O}(Nlog_2N)$$空间复杂度:$$\\mathcal{O}(N)$$因为启用了额外的数组。 三数之和本题目也可以使用二分搜索做，最开始是使用蛮力法解决，时间复杂度为$\\mathcal{O}(N^3)$，将其中最后一个元素的选取改为二分查找后便成为了$\\mathcal{O}(N^2)$，复杂度大大降低。原理就是先排序，依旧是两重循环找出前两个数字，第三个数值利用二分法从剩余元素中找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 查找已排序元素中是否有重复元素 * @author xmmmmmovo * @date 2020/7/28 11:50 * @param list 列表 * @return 是否存在重复元素 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; containsDuplicatesInSorted(list: List&lt;T&gt;): Boolean &#123; for (i in 0 until list.size - 1) &#123; if (list[i] == list[i + 1]) return true &#125; return false&#125;/** * 二分法[binarySearch]求三数之和 * @author xmmmmmovo * @date 2020/7/28 16:09 * @param list 数字列表 * @return 满足和为0的所有组合的列表 * @throws IllegalArgumentException 数组元素小于3个时抛出异常 * @since version-1.0 */fun threeSumBinaryFast(list: List&lt;Int&gt;, num: Int): List&lt;List&lt;Int&gt;&gt; &#123; val res = LinkedList&lt;List&lt;Int&gt;&gt;() val sl = list.sorted().run &#123; if (containsDuplicatesInSorted(this)) distinct() else this &#125; if (list.size &lt; 3) throw IllegalArgumentException(\"数组非重复元素小于3个!\") for (i in sl.indices) &#123; for (j in i + 1 until sl.size) &#123; val k = binarySearch(sl, num - (sl[i] + sl[j]), j + 1) if (k != -1) &#123; res.add(listOf(sl[i], sl[j], sl[k])) &#125; &#125; &#125; return res&#125; 时间复杂度方面，排序+循环时间复杂度$\\mathcal{O}(N\\log_2N+N^2\\log_2N)$，化简得：$$\\mathcal{O}(N^2)$$空间复杂度:$$\\mathcal{O}(N)$$排序产生的中间数组。 数组局部最小元素题目是这样描述的： 题目描述 思路已经很明确了，即是每一次都往小部分缩小1/2的范围，最终查找到的符合条件的mid就成功了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 局部最小元素 * @author xmmmmmovo * @date 2020/7/30 19:36 * @param list 数字列表 * @param _lo 左边界 默认为0 * @param _hi 右边界 默认为list.size - 1 * @return 最小元素数字 * @throws IllegalArgumentException 数组元素小于3个时抛出异常 * @since version-1.0 */fun partialMinElem(list: List&lt;Number&gt;, _lo: Int = 0, _hi: Int = list.size - 1): Int &#123; if (list.size &lt; 3) throw IllegalArgumentException(\"数组元素小于3个！\") var lo = _lo var hi = _hi // 两边需要单独测试 if (list[lo] &lt; list[lo + 1]) return lo if (list[hi] &lt; list[hi - 1]) return hi while (lo in _lo..hi &amp;&amp; hi &lt;= _hi) &#123; // 取mid val mid = lo + (hi - lo) / 2 /** * 这里分为三个情况 * ↘↗直接返回 * ↗↗往左走 * ↗↘都可以，原题是往小的地方走(因为部分排序过的数组会更快) * ↘↘往右走 * 总之就是往小的地方走 */ when &#123; mid == _lo -&gt; if (list[mid] &lt; list[mid + 1]) return mid else lo = mid + 1 mid == _hi -&gt; if (list[mid] &lt; list[mid - 1]) return mid else hi = mid - 1 list[mid - 1] &gt; list[mid] &amp;&amp; list[mid] &lt; list[mid + 1] -&gt; &#123; return mid &#125; list[mid - 1] &lt; list[mid] &amp;&amp; list[mid] &lt; list[mid + 1] -&gt; &#123; hi = mid - 1 &#125; list[mid - 1] &lt; list[mid] &amp;&amp; list[mid] &gt; list[mid + 1] -&gt; &#123; if (list[mid - 1] &gt;= list[mid + 1]) lo = mid + 1 else hi = mid - 1 &#125; else -&gt; &#123; lo = mid + 1 &#125; &#125; &#125; // 当所有元素都是一样的时候才没有最小值，返回-1 return -1&#125; 时间复杂度(最差)：$$\\mathcal{O}(2log_2N)$$为什么是这个时间复杂度呢，因为在最差情况下，向一边走完之后发现没有结果，然后就往另一边走，才发现结果，所以总体是$\\mathcal{O}(2log_2N)$。 空间复杂度：$$\\mathcal{O}(1)$$ 矩阵局部最小元素题目是这样描述的： 题目描述 这个题目也是跟上个题目类似，就是每一次缩减1/2的大小，不过这个并非数组，而是一个矩阵，所以我们对于复杂度不能用上一个题目那种分析方式来写。本题目的思路便是先从最中间元素开始搜查，根据上一题目的四种情况进行讨论，横向讨论完在下一次用纵向讨论，这样每一次都是缩减1/2，最终找到负荷情况的i，j就可以了。 但其实这个题目混沌的一批，如果用遍历+二分的做法的话，就会使得时间复杂度成为$\\mathcal{O}(Nlog_2N)$，而非题目所要求的$\\mathcal{O}(N)$，所以才要一直二分下去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 矩阵局部最小元素 * @author xmmmmmovo * @date 2020/7/30 19:36 * @param matrix 矩阵 * @return 最小元素数字 * @throws IllegalArgumentException 矩阵为空的时候抛出异常 * @since version-1.0 */fun &lt;T : Number&gt; matrixPartialMinElem(matrix: List&lt;List&lt;T&gt;&gt;): Pair&lt;Int, Int&gt; &#123; if (matrix.isEmpty()) throw IllegalArgumentException(\"矩阵不能为空！\") var lor = 0 var hir = matrix.size - 1 while (lor &lt;= hir) &#123; val mr = lor + (hir - lor) / 2 val kc = partialMinElem(matrix[mr]) when &#123; kc == -1 -&gt; &#123; lor++ &#125; mr == 0 -&gt; if (matrix[mr + 1][kc] &gt; matrix[mr][kc]) return Pair(mr, kc) else lor = mr + 1 mr == matrix.size - 1 -&gt; if (matrix[mr][kc] &lt; matrix[mr - 1][kc]) return Pair(mr, kc) else hir = mr - 1 matrix[mr - 1][kc] &gt; matrix[mr][kc] &amp;&amp; matrix[mr][kc] &lt; matrix[mr + 1][kc] -&gt; return Pair(mr, kc) matrix[mr - 1][kc] &lt; matrix[mr][kc] &amp;&amp; matrix[mr][kc] &lt; matrix[mr + 1][kc] -&gt; hir = mr - 1 matrix[mr - 1][kc] &lt; matrix[mr][kc] &amp;&amp; matrix[mr][kc] &gt; matrix[mr + 1][kc] -&gt; if (matrix[mr - 1][kc] &gt;= matrix[mr + 1][kc]) lor = mr + 1 else hir = mr - 1 else -&gt; lor = mr + 1 &#125; &#125; return Pair(-1, -1)&#125; 时间复杂度方面： 这个我怎么推都是$\\mathcal{O}((log_2N)^2)$的复杂度（其实有推出一个$\\mathcal{O}(2N)$来，但是总感觉不是特别靠谱），如果有大佬能推出来$\\mathcal{O}(N)$的复杂度可以在下面留言，感谢！ 空间复杂度方面：$$\\mathcal{O}(1)$$没什么好说的。 双调查找题目是这样描述的： image-20200802133247034 可以发现，这个像是局部最小值的变形，这里面必定有极大值，所以我们把问题分解成了三个子问题： 找到最大值 向左二分找值 向右二分找值 这样三个二分查找总共最差则是$\\mathcal{O}(3log_2N)$，满足题意。为什么这里可以直接用二分法找最大值呢，因为这个数组很特殊，先增后减，可以说局部最大值就是最大值，所以可以利用二分查找直接找出。 局部最大函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 局部最大元素 * @author xmmmmmovo * @date 2020/7/30 19:36 * @param list 数字列表 * @param _lo 左边界 默认为0 * @param _hi 右边界 默认为list.size - 1 * @return 最大元素下标 * @throws IllegalArgumentException 数组元素小于3个时抛出异常 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; partialMaxElem( list: List&lt;T&gt;, _lo: Int = 0, _hi: Int = list.size - 1): Int &#123; var lo = _lo var hi = _hi while (lo &lt;= hi) &#123; // 取mid val mid = lo + (hi - lo) / 2 when &#123; mid == _lo -&gt; if (list[mid] &gt; list[mid + 1]) return mid else lo = mid + 1 mid == _hi -&gt; if (list[mid] &gt; list[mid - 1]) return mid else hi = mid - 1 list[mid - 1] &lt; list[mid] &amp;&amp; list[mid] &gt; list[mid + 1] -&gt; &#123; return mid &#125; list[mid - 1] &gt; list[mid] &amp;&amp; list[mid] &gt; list[mid + 1] -&gt; &#123; hi = mid - 1 &#125; list[mid - 1] &gt; list[mid] &amp;&amp; list[mid] &lt; list[mid + 1] -&gt; &#123; if (list[mid - 1] &lt;= list[mid + 1]) lo = mid + 1 else hi = mid - 1 &#125; else -&gt; &#123; lo = mid + 1 &#125; &#125; &#125; // 当所有元素都是一样的时候才没有最小值，返回-1 return -1&#125; 双栈查找函数： 12345678910111213141516171819202122232425262728/** * 双调查找 * @author xmmmmmovo * @date 2020/7/31 15:42 * @param list 数字列表 * @param _lo 左边界 默认为0 * @param _hi 右边界 默认为list.size - 1 * @return 查找元素下标 * @throws IllegalArgumentException 查不到最大元素时抛出常 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; doubleToneSearch( list: List&lt;T&gt;, key: T, _lo: Int = 0, _hi: Int = list.size - 1): Int &#123; val mi = partialMaxElem(list) if (mi == -1) throw IllegalArgumentException(\"请输入正确的双调列表！\") if (list[mi] == key) return mi val l = binarySearch(list, key, _lo, mi - 1) val r = binarySearch(list.subList(mi + 1, _hi + 1).reversed(), key) return when &#123; r == -1 -&gt; l l == -1 -&gt; _hi - r else -&gt; l &#125;&#125; 时间复杂度（最差）：$$\\mathcal{O}((\\frac{1}{2}+\\frac{1}{2}+2)log_2N) =\\\\\\mathcal{O}(3log_2N)$$ 空间复杂度：$$\\mathcal{O}(N)$$用了一半的反转数组。 仅用加减实现的二分查找题目是这样描述的： image-20200802233108582 说的挺高深的，其实就是利用倒了斐波那契数列，个人感觉可能还能有数列满足指数级，暂时还没时间去想，有空可能会去想。 为什么能用斐波那契数列来求解呢？这还要跟斐波那契数列的特性有关系，我们知道斐波那契数列的规律是这样的：$$\\mathcal{f}(n)=\\begin{cases}1, &amp; \\mbox{if }n\\mbox{ is 1} \\\\1, &amp; \\mbox{if }n\\mbox{ is 2} \\\\\\mathcal{f}(n - 1) + \\mathcal{f}(n-2), &amp;\\mbox{if }n\\mbox{ is &gt;=3}\\end{cases}$$所以从分割点的左右两边来看，都包含有f(1)..f(n-2)的所有信息，只不过右边比左边多出了f(n-1)，所以无论是左边分还是右边往下分，都是可以分离直到f(1)产生的，这就是为什么能用斐波那契数列代替二分搜索的原因。 知道了原因，我们就来思考条件，首先一个首要条件便是：列表大小必须是斐波那契数列其中的某个元素 - 1才可以进行，所以我们需要先将数组扩充到大于这个数组长度的最小斐波那契数列的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 创建最大值大于[length]的第一个数 * @author xmmmmmovo * @date 2020/8/3 1:01 * @param length 最长值 * @return 数列 * @since version-1.0 */fun makeFibonacciListUntilLength(length: Int): List&lt;Int&gt; &#123; return when (length) &#123; 0 -&gt; emptyList() 1 -&gt; listOf(1, 1, 2) 2 -&gt; listOf(1, 1, 2, 3, 5) else -&gt; &#123; val fl = mutableListOf(1, 1) var nv = 2 while (length &gt; nv - 1) &#123; fl.add(nv) nv += fl[fl.size - 2] &#125; fl.add(nv) fl &#125; &#125;&#125;/** * 斐波那契二分搜索 * @author xmmmmmovo * @date 2020/7/31 16:09 * @param list 列表 * @param key 需要查找的值 * @param _lo 左范围 默认为0 * @param _hi 右范围 默认为list.size - 1 * @return 查找到了就返回下标，没查找到就返回-1 * @since version-1.0 */fun &lt;T : Comparable&lt;T&gt;&gt; fibonacciBinarySearch( list: List&lt;T&gt;, key: T, _lo: Int = 0, _hi: Int = list.size - 1): Int &#123; if (list.isEmpty()) return -1 if (list.size &lt; 3) return list.indexOf(key) // 此时最末尾的值肯定是刚好大于长度的那个 val fbl = makeFibonacciListUntilLength(_hi - _lo + 1) val tl = list.toMutableList() tl.addAll(List((fbl.last() - 1 - list.size)) &#123; list.last() &#125;) var lo = _lo var hi = if (_hi == list.lastIndex) tl.lastIndex else _hi var k = fbl.lastIndex while (lo &lt;= hi) &#123; val mid = lo + fbl[k - 1] - 1 when &#123; tl[mid] &gt; key -&gt; &#123; hi = mid - 1 k-- &#125; // 小堆就-2，因为少了f(n-1)的信息 tl[mid] &lt; key -&gt; &#123; lo = mid + 1 k -= 2 &#125; else -&gt; return if (mid &gt;= _hi) list.lastIndex else mid &#125; &#125; return -1&#125; 时间复杂度：$$\\mathcal{O}(log_2N)$$空间复杂度：$$\\mathcal{O}(N)$$越往后来说空间增加都近似于前一个数值的$\\frac{1}{3}$，所以空间复杂度约为$\\mathcal{O}(N)$ GithubGithub","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"}]},{"title":"如何利用GitHubAction自动化测试你的kotlin程序并部署文档到GithubPage","date":"2020-07-28T01:42:12.000Z","path":"2020/07/28/github-action-kotlin-test-action/","text":"简单的实践操作 前言这两天一直在写算法，但是一个一个测试太麻烦了，并且也没有文档看，简直累人，所以就写了个action让它自动生成并部署到GithubPage上面去，爽了。 测试引入依赖12345678dependencies &#123; ...... testImplementation( 'org.assertj:assertj-core:3.12.2', 'org.junit.jupiter:junit-jupiter-api:5.4.2' ) testRuntime('org.junit.jupiter:junit-jupiter-engine:5.4.2')&#125; 编写测试task123test &#123; useJUnitPlatform()&#125; 完成！看看效果吧~ test 测试成功~ 文档生成本次使用的是kotlin官方文档生成器dokka，内含有多种生成方案，并且可以集成到Gradle中，爽的。 引入依赖这里以插件方式引入： 1234plugins &#123; ...... id 'org.jetbrains.dokka' version '0.10.1'&#125; 编写task12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455dokka &#123; // 样式，具体看官方文档 outputFormat = 'javadoc' outputDirectory = \"$buildDir/dokka\" disableAutoconfiguration = false cacheRoot = 'default' configuration &#123; moduleName = 'doc' // Use to include or exclude non public members. includeNonPublic = false // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated = false // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented = true // Do not create index pages for empty packages skipEmptyPackages = true // This is a list of platform names that will be shown in the final result. See the \"Platforms\" section of this readme targets = [\"JVM\"] // Platform used for code analysis. See the \"Platforms\" section of this readme platform = \"JVM\" sourceRoot &#123; // 源文件目录 path = \"src\" &#125; sourceLink &#123; // Unix based directory relative path to the root of the project (where you execute gradle respectively). path = \"src/main/kotlin\" // or simply \"./\" // URL showing where the source code can be accessed through the web browser url = \"https://github.com/xmmmmmovo/Algorithms4thEditionKotlinSolutions/blob/master/src/main/kotlin\" //remove src/main/kotlin if you use \"./\" above // 指定行数前缀，github是#L lineSuffix = \"#L\" &#125; // 用于链接java官方文档 jdkVersion = 8 // Disable linking to online kotlin-stdlib documentation noStdlibLink = false // Disable linking to online JDK documentation noJdkLink = false &#125;&#125; 完成！看看效果~ 成功~ 自动化每次都运行脚本太累了，干脆直接用CI自动跑了，这里用的是GithubAction，具体如何使用可以看：如何利用GitHubAction和GithubPage部署React应用 这篇，这里只写出yml文件: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# workflow namename: Test Workflowon: push: branches: - masterjobs: test: name: Kotlin Tests runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # 验证wrapper - name: validate wrapper uses: gradle/wrapper-validation-action@v1 # 安装jdk - name: Set up JDK 8 uses: actions/setup-java@v1 with: java-version: 1.8 # 缓存 - name: Cache Gradle packages uses: actions/cache@v2 with: path: ~/.gradle/caches key: $&#123;&#123; runner.os &#125;&#125;-gradle-$&#123;&#123; hashFiles('**/*.gradle') &#125;&#125; restore-keys: $&#123;&#123; runner.os &#125;&#125;-gradle # 给权限 - name: Grant execute permission for gradlew run: chmod +x gradlew # 测试程序 - name: Test with gradle run: ./gradlew test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# workflow namename: Doc Workflowon: release: types: [published] branches: - masterjobs: test: name: Kotlin Documentation Generation runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # 验证wrapper - name: validate wrapper uses: gradle/wrapper-validation-action@v1 # 安装jdk - name: Set up JDK 8 uses: actions/setup-java@v1 with: java-version: 1.8 # 缓存 - name: Cache Gradle packages uses: actions/cache@v2 with: path: ~/.gradle/caches key: $&#123;&#123; runner.os &#125;&#125;-gradle-$&#123;&#123; hashFiles('**/*.gradle') &#125;&#125; restore-keys: $&#123;&#123; runner.os &#125;&#125;-gradle # 给权限 - name: Grant execute permission for gradlew run: chmod +x gradlew # 缓存 # 暂时还未找到hash值的解决方案，找到了请pr # - name: Cache Dokka # uses: actions/cache@v2 # with: # path: ~/.cache/dokka # key: $&#123;&#123; runner.os &#125;&#125;-dokka-$&#123;&#123; hashFiles('**/*') &#125;&#125; # restore-keys: $&#123;&#123; runner.os &#125;&#125;-dokka # 生成文档 - name: Generate documentation run: ./gradlew dokka # 部署到ghpage - name: Deploy to gh-pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; publish_dir: ./build/dokka 完成！测试一下~ 成功~ 结语爽到了爽到了~ GitHub地址","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"github","slug":"github","permalink":"http://blog.fivezha.cn/tags/github/"},{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"},{"name":"gradle","slug":"gradle","permalink":"http://blog.fivezha.cn/tags/gradle/"}]},{"title":"如何利用GitHubAction和gulp自动化部署压缩你的GithubPage+Hexo博客","date":"2020-07-24T13:37:09.000Z","path":"2020/07/24/github-action-blog/","text":"差点翻车 前言GithubAction作为Github提供的免费的CI/CD服务，让开发者感受到了自动化的爽，相比起Travis CI来说，GitHubAction集成方便，非常适合快速部署的操作，本教程便是一篇如何利用GithubAction对于GithubPage+Hexo博客进行自动化部署，并利用gulp进行压缩。 配置GithubAction生成key首先依旧是申请key， 12cd ~/.sshssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" image-20200724215856700 此时会生成.pub的公钥与没有后缀的私钥： 成功生成密钥 配置仓库首先新建一个空仓库，用于存放你的博客根目录，新建完成后将博客根目录所有文件都上传到这个仓库中，传完项目结构大体如下： image-20200724220337436 然后开始配置仓库，首先 image-20200724220449987 image-20200724220517055 配置成你的公钥，然后在上传博客的仓库中，上传你的私钥： image-20200724220651398 注意这里的私钥名字一定要跟后面Action里面设置的一样！(不知道就跟我一样) 配置workflow在博客根目录新建.github文件夹，再在.github文件夹里新建workflows文件夹，新建完在workflows文件夹里新建deploy.yml文件，然后按照如下编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# workflow namename: Deploy To Github Pages# 当有 push 到仓库就运行on: [push]jobs: deploy: name: Deploy Hexo Public To Pages runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: # 切换到master # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # 安装node # from: https://github.com/actions/setup-node - name: Setup Node.js 11.x uses: actions/setup-node@master with: node-version: \"11.x\" # 缓存 node_modules - name: Cache node modules uses: actions/cache@v2 with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; restore-keys: | $&#123;&#123; runner.OS &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;- $&#123;&#123; runner.OS &#125;&#125;-build- $&#123;&#123; runner.OS &#125;&#125;- # 安装hexo并生成 - name: Setup Hexo Dependencies run: | npm install hexo-cli -g npm install hexo generate # 部署到GitHubPage # from https://github.com/peaceiris/actions-gh-pages - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; # 这里写你自己的仓库名 external_repository: xmmmmmovo/xmmmmmovo.github.io publish_branch: master publish_dir: ./public commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; 好了，这样就已经配置完成了，你每次提交到此仓库，便会自动帮你运行部署到GithubPage上去。 测试 image-20200724221510619 image-20200724221450653 可以看到，已经成功运行了。 配置gulp我们随便点开一个文件： image-20200724221832348 可以看到，里面充斥着大量的空格，积少成多，这会占用非常多的时间，让你的博客感觉加载起来很慢，所以既然我们都是全自动化部署了，我们不如直接在进行一遍压缩操作，这样使你博客加载的更加迅速，体验更加良好。 安装gulp首先进到博客根目录，然后打开命令行，输入(这里其实你直接在package.json里面写也行(因为node_modules已经没用了)，但是我比较懒)： 1npm install gulp@3.9.1 gulp-minify-css gulp-htmlmin gulp-htmlclean --save-dev 待完成后，改写deploy.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# workflow namename: Deploy To Github Pages# 当有 push 到仓库就运行on: [push]jobs: deploy: name: Deploy Hexo Public To Pages runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: # 切换到master # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # 安装node # from: https://github.com/actions/setup-node - name: Setup Node.js 11.x uses: actions/setup-node@master with: node-version: \"11.x\" # 缓存 node_modules - name: Cache node modules uses: actions/cache@v2 with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; restore-keys: | $&#123;&#123; runner.OS &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;- $&#123;&#123; runner.OS &#125;&#125;-build- $&#123;&#123; runner.OS &#125;&#125;- # 安装hexo并生成 - name: Setup Hexo Dependencies run: | npm install hexo-cli -g npm install hexo generate gulp # 部署到GitHubPage # from https://github.com/peaceiris/actions-gh-pages - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; # 这里写你自己的仓库名 external_repository: xmmmmmovo/xmmmmmovo.github.io publish_branch: master publish_dir: ./public # 这里我改成了与原格式相似格式的commit message commit_message: 'Site updated: $&#123;&#123; github.event.head_commit.timestamp &#125;&#125;' 然后编写gulpfile.js文件用来加载gulp： 123456789101112131415161718192021var gulp = require('gulp');var minifycss = require('gulp-minify-css');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'))&#125;);gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest('./public'))&#125;);gulp.task('default', ['minify-html', 'minify-css']); 此时再次提交，等待GithubAction完成之后，便可以查看效果了~ image-20200724222548668 可以看到800多行瞬间变为了16行，是不是很爽~","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"github","slug":"github","permalink":"http://blog.fivezha.cn/tags/github/"}]},{"title":"算法(第四版)笔记(6)---如何利用六个栈使队列所有操作时间复杂度达到O(1)","date":"2020-07-23T10:11:16.000Z","path":"2020/07/23/algorithm4-1-threestackqueue/","text":"第一次看见的前面就标有极难的题目 思路参考本问题其实是有一篇论文作为参考的: 这篇论文是以LISP作为实现语言的，我们本次依旧是使用kotlin进行实现。 当然，这里三个栈需要实现的是双向队列的API，六个栈实现的是单向队列。 实现思路首先，先要说明一个事情——其实栈的实现大多数都是利用顺序表来进行实现的，但是根据算法第四版里面的实现方案，栈其实是利用链表来实现的，虽然不影响后面复杂度分析，但是底层区别首先在这里说清楚。 然而，队列的实现有着顺序表和链表两种解决方案，用顺序表虽然出队列也依旧是$\\mathcal{O}(1)$的效率，但是随着标志位的后移，需要的空间会线性增长，但是如果不后移则会变成$\\mathcal{O}(N)$的复杂度，所以衍生出了循环队列的中间方案。不过Java源码中，给出了一个非常巧妙的方案，它将Queue和Deque作为一个接口，让其他数据结构实现这个接口，这样无论是链表还是线性表，只要实现了这个接口，就可以作为队列来使用。 言归正传，回到这个问题，要分析多个栈实现队列，我们首先分析双栈情况，就是左右横跳，用另一个栈作为中间栈，每一次出队列先把所有的元素移动到另一个栈中再出栈，这样出栈时间复杂度$\\mathcal{O}(N)$，入栈直接压入原栈，时间复杂度$\\mathcal{O}(1)$，但如果我们再利用多个栈进行模拟，就可以把所有操作压缩到$\\mathcal{O}(1)$的时间复杂度了。 根据算法第四版的题目描述，设定的是利用3个栈进行实现，但是这是均摊时间复杂度之后达到的$\\mathcal{O}(1)$，不是真$\\mathcal{O}(1)$，所以本文章又给出了第二种利用六个栈实现的方案。 三个栈实现双向队列(虚假的$\\mathcal{O}(1)$)主要实现Deque的几个方法，具体代码解释已经写到注释里面了，所以直接放代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package ds/* * 使用三个栈实现队列 * 使得所有操作都是O(1) * @Author xmmmmmovo * @Version 1.0 **/class StackDeque&lt;T&gt; &#123; // 左栈 private val lst = Stack&lt;T&gt;() // 右栈 private val rst = Stack&lt;T&gt;() // 中间栈 private val tst = Stack&lt;T&gt;() // 表示存储的栈位置 private var tmpIsRight = false fun isEmpty(): Boolean = lst.isEmpty() &amp;&amp; rst.isEmpty() &amp;&amp; tst.isEmpty() /** * 入左队列 * */ fun pushLeft(element: T) &#123; lst.push(element) &#125; /** * 入右队列 * */ fun pushRight(element: T) &#123; rst.push(element) &#125; /** * 出左队列(对应的是入右队列 * */ fun popLeft(): T &#123; return when &#123; /* * 这里如果左栈有值的话就说明要么左边插入值了 * 要么右边或者中转栈转移到了左栈，无论哪种情况都是栈顶就是最左 * 直接出栈就可以 * */ lst.isNotEmpty() -&gt; lst.pop() /** * 这里先判断中转栈内容是否是存的右栈的内容 * 判断如果是右栈的内容，再判断中转栈是否是空的 * 如果不是就说明右栈已经转移到中转栈中了 * 相当于移动到了左栈，所以直接弹出中转栈 * */ tst.isNotEmpty() &amp;&amp; tmpIsRight -&gt; tst.pop() /** * 这里先判断中转栈内容是否是存的右栈的内容 * 判断如果不是右栈的内容，再判断中转栈是否是空的 * 如果不是就说明是左栈移动到了中栈了 * 相当于移动到了右栈，所以先弹出到左栈再弹出左栈 * */ tst.isNotEmpty() &amp;&amp; !tmpIsRight -&gt; &#123; while (tst.isNotEmpty()) lst.push(tst.pop()) lst.pop() &#125; /** * 这里如果是中转栈是空的并且右栈不为空 * 就直接转移到中转栈再弹出中转栈 * */ tst.isEmpty() &amp;&amp; rst.isNotEmpty() -&gt; &#123; while (rst.isNotEmpty()) tst.push(rst.pop()) tmpIsRight = true // 存的是右栈 tst.pop() &#125; /** * 所有栈都没有内容，自然就抛出异常 * */ else -&gt; throw NoSuchElementException(\"Stack underflow\") &#125; &#125; /** * 出右队列(对应的是出左队列 * */ fun popRight(): T &#123; return when &#123; rst.isNotEmpty() -&gt; rst.pop() tst.isNotEmpty() &amp;&amp; !tmpIsRight -&gt; tst.pop() tst.isNotEmpty() &amp;&amp; tmpIsRight -&gt; &#123; while (!tst.isEmpty()) rst.push(tst.pop()) rst.pop() &#125; tst.isEmpty() &amp;&amp; lst.isNotEmpty() -&gt; &#123; while (lst.isNotEmpty()) tst.push(lst.pop()) tmpIsRight = false // 存的是左栈 tst.pop() &#125; else -&gt; throw NoSuchElementException(\"Stack underflow\") &#125; &#125; val size: Int get() = lst.size + rst.size + tst.size fun asList(): List&lt;T&gt; &#123; val list = mutableListOf&lt;T&gt;() lst.forEach &#123; list.add(it) &#125; // 如果非空那就得判断tmp里面存储的是左还是右了 // 但是右栈一定要翻转 tst.run &#123; if (tmpIsRight) this else reversed() &#125;.forEach &#123; list.add(it) &#125; rst.reversed().forEach &#123; list.add(it) &#125; return list &#125; override fun toString(): String = asList().toString()&#125; 测试1234567891011val sq = StackDeque&lt;String&gt;()sq.pushLeft(\"a\")sq.pushLeft(\"b\")sq.pushLeft(\"c\")sq.pushLeft(\"d\")sq.pushLeft(\"e\")println(sq.popRight())sq.pushRight(\"f\")sq.pushRight(\"g\")sq.pushRight(\"h\")println(sq.asList()) image-20200725134752097 分析时间复杂度： 这里我们主要分析出队列的时间复杂度，因为入队列操作仅是一个入栈操作，时间复杂度：$$\\mathcal{O}(1)$$出队列方面，因为两端出队列思想相似，所以仅分析其中一边即可。 可以看到，首先先说明一下，队列是先进先出的，所以是右进左出，左进右出，选择右进左出分析，可以看到出方向首先尝试从另一边栈进行出栈操作，如果成功就是$\\mathcal{O}(1)$，如果失败就继续判断中转栈是否是右栈内容，尝试从中转栈进行出栈，成功依旧是$\\mathcal{O}(1)$，当中转栈是左栈或者只有右栈不为空的时候，所需要的时间复杂度才为$\\mathcal{O}(N)$，所以考虑N个元素，最差情况是便是左进右出情况，因为此时才会存在移栈，此时仅在第一次出队列时时间复杂度为$\\mathcal{O}(N)$。所以均摊时间复杂度下，出队列操作的时间复杂度为：$$\\mathcal{O}(N/N)\\\\= \\mathcal{O}(1)$$可以看到是均摊后时间复杂度才达到$\\mathcal{O}(1)$，所以是虚假的$\\mathcal{O}(1)$。 空间复杂度： 虽然这里用到了三个栈，但是所有需求空间加起来是等于添加的总元素的，所以空间是成线性增长的，所以空间复杂度是：$$\\mathcal{O}(N)$$ 六个栈实现单向队列(真正的$\\mathcal{O}(1)$)因为双向会更加绕，所以这里选用单项队列进行讲解，主要方向是右进左出。当然，这里的思想跟上面的有些许不同，三个栈的情况是存在单次操作$\\mathcal{O}(N)$的，所以在这里我们将解决这个问题。 参考博客文章：点此跳转 根据上面的思路，我们发现了整个实现的思路就是均摊，作为双向队列，如果仅用三个栈的话，中间栈只能存储一个栈，所以我们无论如何都需要有一次进行单个栈所有元素转存的方案，所以无法均摊到单个操作上(如果有四个栈可能可行)，但是本次仅用作单项队列，所以对于出栈来说只是左栈需要转存，所以可以把转存操作均摊到每一个出栈操作上来。 整体思路上是在入队列的时候便使得左右两个栈尽量相等，然后在出栈的时候再进行判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/* * Copyright (c) 2020. xmmmmmovo */package ds/** * 用六个栈实现单向队列 * @author xmmmmmovo * @date 2020/7/28 16:43 * @since version-1.0 */class StackDequeOpt&lt;T&gt; &#123; /** * 左栈 */ private var lst = Stack&lt;T&gt;() /** * 右栈 */ private var rst = Stack&lt;T&gt;() /** * 左栈替换栈 用于复制时转换 */ private var tlst = Stack&lt;T&gt;() /** * 右栈替换栈 用于复制时候入队 */ private var trst = Stack&lt;T&gt;() /** * 左翻转栈，用于保护左栈原有数据 */ private var lstrev = Stack&lt;T&gt;() /** * 用于复制过程中的出栈操作 */ private var hlst = Stack&lt;T&gt;() /** * 判断是否在复制 */ private var isCopying = false /** * 需要复制数量 */ private var needCopy = 0 /** * 队列是否为空 * @author xmmmmmovo * @date 2020/7/29 16:54 * @return 返回是否为空 * @since version-1.0 */ fun isEmpty(): Boolean = lst.isEmpty() &amp;&amp; rst.isEmpty() &amp;&amp; tlst.isEmpty() &amp;&amp; trst.isEmpty() &amp;&amp; lstrev.isEmpty() /** * 入右队列 * @author xmmmmmovo * @date 2020/7/29 16:55 * @param element 入元素 * @since version-1.0 */ fun pushRight(element: T) &#123; when &#123; /** * 左栈大于右栈 */ !isCopying &amp;&amp; sizeDiff &gt; 0 -&gt; &#123; needCopy = 0 rst.push(element) &#125; /** * 左右栈相等的时候，因为不知道下一步操作 * 所以提前准备来进行复制操作 */ !isCopying &amp;&amp; sizeDiff == 0 -&gt; &#123; rst.push(element) isCopying = true hlst = lst.clone() oneStep() oneStep() &#125; /** * 如果还在复制直接 入栈到中转栈 * 因为原栈需要别的用处 */ isCopying -&gt; &#123; tlst.push(element) oneStep() oneStep() &#125; &#125; &#125; /** * 出左队列 * @author xmmmmmovo * @date 2020/7/29 16:55 * @return 返回队列第一个元素 * @throws NoSuchElementException 没有元素时抛出 * @since version-1.0 */ fun popLeft(): T &#123; when &#123; /** * 如果没有在copy的时候并且左大于右则直接左栈弹出 */ !isCopying &amp;&amp; sizeDiff &gt; 0 -&gt; &#123; return lst.pop() &#125; /** * 如果没有在复制并且左栈刚好等于右栈，那么就直接弹出左栈 * 这样左栈小于右栈，进入复制状态 */ !isCopying &amp;&amp; sizeDiff == 0 -&gt; &#123; val t = lst.pop() hlst = lst.clone() isCopying = true oneStep() oneStep() return t &#125; /** * 因为复制状态下，所有左栈元素会到hlst中所以直接hlst出栈 */ else -&gt; &#123; val t = hlst.pop() needCopy-- oneStep() oneStep() return t &#125; &#125; &#125; /** * 预览元素 * @author xmmmmmovo * @date 2020/7/29 16:56 * @return 返回队列第一个元素 * @throws NoSuchElementException 没有元素时抛出 * @since version-1.0 */ fun peekLeft(): T = if (isCopying) hlst.peek() else lst.peek() /** * 中间操作 这里是脱离了入栈出栈操作的额外操作 * @author xmmmmmovo * @date 2020/7/29 20:32 * @since version-1.0 */ private fun oneStep() &#123; when &#123; /** * 正在copy的时候左右栈都不是空的，这说明需要进行交换了 * 本次这里右栈进入左栈中转栈 * 左栈进入左栈反转栈(用于后面直接替换 */ isCopying &amp;&amp; lst.isNotEmpty() &amp;&amp; rst.isNotEmpty() -&gt; &#123; needCopy++ tlst.push(rst.pop()) lstrev.push(lst.pop()) &#125; /** * 此状态说明此时左栈已经完成转移，右栈还有剩余 * 把右栈的元素移动到左栈中转栈中 */ isCopying &amp;&amp; lst.isEmpty() &amp;&amp; rst.isNotEmpty() -&gt; &#123; isCopying = true tlst.push(rst.pop()) &#125; /** * 此时说明左右栈都是空栈了 * 但是需要复制的数量大于1 * 就说明lstrev还有剩余可以转移的元素 * 直接转移到左中转栈用于后面计算 */ isCopying &amp;&amp; lst.isEmpty() &amp;&amp; rst.isEmpty() &amp;&amp; needCopy &gt; 1 -&gt; &#123; isCopying = true needCopy-- tlst.push(lstrev.pop()) &#125; /** * 如果左右栈都为空， 并且仅有一个需要复制的 * 那么就直接把最后一个元素并入左栈中转栈 * 中转栈转为主栈 就完成了一个循环 */ isCopying &amp;&amp; lst.isEmpty() &amp;&amp; rst.isEmpty() &amp;&amp; needCopy == 1 -&gt; &#123; isCopying = false needCopy-- tlst.push(lstrev.pop()) lst = tlst rst = trst tlst = Stack() trst = Stack() lstrev = Stack() hlst = Stack() &#125; /** * 同上 */ isCopying &amp;&amp; lst.isEmpty() &amp;&amp; rst.isEmpty() &amp;&amp; needCopy == 0 -&gt; &#123; isCopying = false lst = tlst rst = trst tlst = Stack() trst = Stack() lstrev = Stack() hlst = Stack() &#125; &#125; &#125; /** * 左栈-右栈大小的差值 * @author xmmmmmovo * @date 2020/7/29 20:33 * @since version-1.0 */ private val sizeDiff: Int get() = lst.size - rst.size /** * 队列总长度 * @author xmmmmmovo * @date 2020/7/29 20:33 * @since version-1.0 */ val size: Int get() = lst.size + rst.size + tlst.size + trst.size + lstrev.size&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* * Copyright (c) 2020. xmmmmmovo */package fundamentalimport ds.StackDequeOptimport org.junit.jupiter.api.*import org.junit.jupiter.api.Assertions.*import org.junit.platform.commons.logging.LoggerFactoryinternal class StackDequeOptTest &#123; private val sdo = StackDequeOpt&lt;Int&gt;() companion object &#123; private val log = LoggerFactory.getLogger(StackDequeOptTest::class.java) @BeforeAll @JvmStatic fun before() &#123; log.info &#123; \"StackDequeOptTest start\" &#125; &#125; @AfterAll @JvmStatic fun after() &#123; log.info &#123; \"StackDequeOptTest end\" &#125; &#125; &#125; @Test fun isEmpty() &#123; assertEquals(true, sdo.isEmpty()) sdo.pushRight(1) assertEquals(false, sdo.isEmpty()) sdo.popLeft() assertEquals(true, sdo.isEmpty()) &#125; @Test fun pushRight() &#123; sdo.pushRight(1) sdo.pushRight(2) sdo.pushRight(3) assertEquals(3, sdo.popLeft()) assertEquals(2, sdo.popLeft()) assertEquals(1, sdo.popLeft()) &#125; @Test fun peekLeft() &#123; sdo.pushRight(1) sdo.pushRight(2) sdo.pushRight(3) assertEquals(3, sdo.peekLeft()) sdo.popLeft() assertEquals(2, sdo.peekLeft()) &#125; @Test fun getSize() &#123; assertEquals(0, sdo.size) sdo.pushRight(1) assertEquals(1, sdo.size) sdo.popLeft() assertEquals(0, sdo.size) sdo.pushRight(1) sdo.pushRight(2) sdo.pushRight(3) assertEquals(3, sdo.size) &#125;&#125; 分析时间复杂度： 这里所有复杂度都均摊到了每一个操作上，不会出现某些情况时间复杂度激升的情况，综合时间复杂度：$$\\mathcal{O}(1)$$空间复杂度：$$\\mathcal{O}(N)$$ 总结关于这个题目也是众说纷纭，有的人说作者已经将题目改成了有限个栈而非三个栈，但是官方网站上却标注着使用三个栈实现，然而因为疫情原因，纸质书依旧在学校里躺着，没法证明，但就从电子版来看，作者有很大可能也没有改题。其实这个题目在stackoverflow上面也有人询问(链接)，但是大多数人都暗示了使用三个栈是不可能存在真正的$\\mathcal{O}(1)$的，当然也有一些抖机灵的解法——比如某些套娃栈的邪道解法，真的是天马行空。不管怎么说，对于一道存在这么个争议的题目，也就仅是能到这里了。 GithubGithub","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"}]},{"title":"解决mathjax公式不换行问题","date":"2020-07-23T03:56:03.000Z","path":"2020/07/23/mathjax-newline/","text":"如何解决hexo中mathjax公式不换行 问题在hexo中写公式一般是用LaTex写然后利用Mathjax进行翻译来显示，但是当编写多行公式的时候，比如下面的公式的时候 image-20200723115858343 本来应该渲染出来如下效果 image-20200723141719914 然而实际渲染出来确实下面这个样子： image-20200723115846661 很让人头大，经过多方面排查，最终发现了问题的根源。 解决查看编译过后的html文件发现，其中的\\\\都被转义成了\\，这样是无法利用mathjax进行显示换行的。 image-20200723142052704 所以我们现在要做的很简单，便是把\\\\转义掉，不让它再被编译即可。 image-20200723142327914 可以看到已经被成功转义 image-20200723142423810 现在公式已经会正常显示了 image-20200723142544542","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://blog.fivezha.cn/tags/latex/"}]},{"title":"如何利用GitHubAction和GithubPage部署React应用","date":"2020-07-21T07:03:12.000Z","path":"2020/07/21/github-action-demo/","text":"本文是从物联网工程与技术实践期末文档中抽取出来的，可能格式比较奇怪。 GithubAction官网的第一段，便讲明了此功能的用途和作用。 在 GitHub 操作 的仓库中自动化、自定义和执行软件开发工作流程。 您可以发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程中。 看上去云里雾里，其实就是利用yml进行的自定义脚本操作，用于测试/部署的时候的一些列繁琐重复工作实现全流水线自动化作业的功能。 GithubPage 您可以为自己、您的组织或项目设置一个基本 GitHub Pages 站点。 白嫖Github服务器用来部署自己的web应用。部署后链接格式：&lt;用户名&gt;.github.io/&lt;仓库名&gt; 开始编写生成密钥12cd ~/.sshssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" 图2.13 成功生成密钥 此时会生成.pub的公钥与没有后缀的私钥： 图2.14 成功生成密钥 此时再将公钥私钥部署到GitHub： image-20200721163516689 图2.15 GitHub部署公钥 image-20200721163738918 图2.16 GitHub部署私钥 编写deploy.yml文件首先先在仓库根目录新建.github/workflows文件夹，然后在此文件夹下新建deploy.yml文件 然后编写此文件： 1234567891011121314151617181920212223242526name: Deploymenton: push: branches: - masterjobs: deploy: runs-on: ubuntu-latest strategy: matrix: node-version: [12.x] steps: - uses: actions/checkout@v1 - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; - name: Install Packages run: npm install - name: Build page run: npm run build - name: Deploy to gh-pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; publish_dir: ./build 此时自动化流程部署已完成，每次commit便会自动部署到GitHub服务器中。 图2.17 GitHub部署流程 图2.18 自动化部署 添加依赖缓存上面的流程如果仔细查看的话，会发现一个问题——每一次commit都会进行一次Install Package的操作，这样不仅浪费了性能，还极大的浪费了时间，每一次都会浪费平均50s左右的时间进行依赖下载，占用了我们的开发时间，所以我在这里对于node_modules做了缓存操作，最终deploy.yml文件如下： 1234567891011121314151617181920212223242526272829303132333435name: Deploymenton: push: branches: - masterjobs: deploy: runs-on: ubuntu-latest strategy: matrix: node-version: [12.x] steps: - uses: actions/checkout@v1 - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions/setup-node@v1 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; - name: Cache node modules uses: actions/cache@v1 with: path: node_modules key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; restore-keys: | $&#123;&#123; runner.OS &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;- $&#123;&#123; runner.OS &#125;&#125;-build- $&#123;&#123; runner.OS &#125;&#125;- - name: Install Packages run: npm install - name: Build page run: npm run build - name: Deploy to gh-pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; publish_dir: ./build 测试一下： 图2.19 未加缓存 图2.20 添加缓存 可以看到下载依赖的时间从42s变为了9s，可以说是质的飞跃了~ 成果部署成果查看 Github仓库","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"github","slug":"github","permalink":"http://blog.fivezha.cn/tags/github/"},{"name":"typescript","slug":"typescript","permalink":"http://blog.fivezha.cn/tags/typescript/"}]},{"title":"谜之github徽章以及存储介质感悟","date":"2020-07-18T14:51:41.000Z","path":"2020/07/18/github-arctic/","text":"没想到居然这么快就投入使用了 &nbsp;&nbsp;&nbsp;&nbsp;今天点开了许久未打开的GitHub，还没来得及点进动态查看大佬们star的项目之前，自己便先被一则消息吸引了，本着太长不看的原则，还未仔细查看便条件反射般的点了Got it的圆角矩形按钮。之后我的视线便顺着气泡凸起指向的位置寻去，发现了一枚雪花形状新徽章出现在了自己Profile -&gt; Highlights上，让那枚Pro徽章显得不那么孤单。查看了一下详细信息后，阿这，这不是半年前在油管看到过的GitHub北极代码库计划吗？！ image-20200718231856879 &nbsp;&nbsp;&nbsp;&nbsp;当时因为新冠的原因宅在家里实在是太闲了，甚至无聊到了在油管搜索GitHub……. &nbsp;&nbsp;&nbsp;&nbsp;然后就看到了下面的这个视频👇(Youtube视频，显示可能需要某些手段) &nbsp;&nbsp;&nbsp;&nbsp;大致讲的就是把代码存一份到北极去留作备份，用以后来信息断层的人们考古用，用以最容易理解的符号表示解密方案（怎么越听越像自举），然后根据解密方案查找信息。wow，awesome！竟然这么快就上线了，不愧是微软时代的GitHub，有钱就是效率高啊。 &nbsp;&nbsp;&nbsp;&nbsp;虽然没有被采用，但是我最感兴趣的还是其中提到的存储介质——磁带。 &nbsp;&nbsp;&nbsp;&nbsp;说到磁带，应该可以说是很多人的“ 童年 ”了，每天晚上洗脚的时候，每天早晨吃饭的时候，本应该在愉快的动画中度过的时间，被硬生生的安排成英语听力时间，每天听着机械一般的无感情的单词朗读和强挤出来的好似使出了自己毕生实力的浮夸演技对话仅是为了那用于糊弄老师的好似无上的圣旨一般的家长签字。有过类似经历的hxd们估计已经时会心一笑了，然而随着时代发展，磁带这一承载着童年回忆的物件如今却基本上在生活消费市场上销声匿迹了，现代课本也已经基本上全面使用光盘作为附载信息的存储介质了。然而，磁带作为一种经历了半个多世纪的存储介质，却从未消亡，沦为收藏家的玩物，反而在更加高精尖的研究机构/企业存储中继续发光发热。 &nbsp;&nbsp;&nbsp;&nbsp;上面的言论并非胡思乱想的民科行为，而是实打实的存在有公开数据的： image-20200719125239292 中国科学院遥感与数字地球研究所LTO磁带采购公告👆 image-20200719125412481 基因组研究所海量磁带库备份系统正式投入运行👆 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，甚至在中国科学院内部，磁带依旧是很重要的存储介质，不仅在国内，国外各大研究机构也是磁带的“大客户”： 国际评价中子核数据库中便多次提到磁带，并且明确提出离线检索中包含磁带数据，可以说，磁带只不过换了一种新的方式存在，并且发展的更加茁壮。 &nbsp;&nbsp;&nbsp;&nbsp;讲到这里，肯定很多人都会有着大大的疑惑——为什么这些研究机构不使用更加“现代”的存储工具呢？咱们接着往下看。 &nbsp;&nbsp;&nbsp;&nbsp;猛然提到研究机构有点让人不知所措，不如我们先从一些旧照片中找寻一下线索： img ibm 1960s | Ibm, Old computers This room-sized IBM computer from the 1960s was awesome in it's &nbsp;&nbsp;&nbsp;&nbsp;上面一组照片拍摄于上世纪60年代，可以看到当时的磁带存放并用于大型机房，由专业的操作员进行专业的操作的，没错，1952年，IBM成功发布了计算机业内的第一款磁带机，拉开了磁带发展第一时期的序幕。这一时期延续了35年，主要特征是圆轴磁带的使用，并且需要人工手动操作(装载、卸载和归档)。如果说当时使用磁带是没有选择，那么为什么现代科研机构也还是继续使用磁带呢？ &nbsp;&nbsp;&nbsp;&nbsp;别急，接着往下讲，时间跨越到千禧年往后的2002年，此时磁带跨越了第二个时代——近现时代，此时磁带已经不需要那种大型磁带驱动器，不专用于主机，这让便携和低成本产品得以于平民消费市场面世，自然，廉价的存储介质和便于携带的特性很快便掀起了一股风潮……同年，磁带的容量首次超过了最大磁盘的容量，过去，一个磁盘所能容纳的信息量往往需要多盒磁带才能装得下；但是现在情况完全反过来，一盒磁带就可以容纳多个磁盘的数据。磁盘的失败从此便可见一斑。 随身携带的磁带播放器 &nbsp;&nbsp;&nbsp;&nbsp;后面的事情大家也都经历了，计算机硬盘/软盘的出现，改变了家用电脑的存储境况，单位体积的容量大大提升，全面改善了用户体验，这使得家用电脑短暂的磁带存储介质的时代极其短暂。 苹果Ⅱ 使用磁带作为存储媒介 苹果Ⅱ 使用磁带作为存储媒介 雅达利5200 &nbsp;&nbsp;&nbsp;&nbsp;从这里，其实就可以看出民用设备与科研设备选用上的些许差距了，民用设备主要讲究的就是成本和便利，而科研设备主要考虑的则是稳定性和持久性。好了说了这么多，大概历史也说明了，磁带作为一种历史悠久的存储介质，甚至一直到2002年还在发展，但是其单位体积的存储容量使得其无法在民用大放异彩。总结一下，磁带价格低廉，发展没有落后，但是单位体积存储容量小。 &nbsp;&nbsp;&nbsp;&nbsp;相信已经有人分析出来结果了，在这里我引用一下CERN数据存储主管Alberto Pace的分析来说明优点 &nbsp;&nbsp;&nbsp;&nbsp;相比硬盘，磁带储存拥有4大优势：虽然，磁带的装卸是落后的，即使在自动化装置协助下，在储存库中找出对应的磁带并装入读取装置中最快也需要40秒。但是一旦就绪后，磁带的读取速度却可以达到硬盘的4倍。 &nbsp;&nbsp;&nbsp;&nbsp;其次是可靠性。磁带也会遇到损毁的情况，如断裂。但断裂后的磁带仍可以重新接上，而且仅会造成数百MB的损失——这对于动辄上TB的专业储存设备来说，实在小事一桩。但对硬盘来说，物理损坏甚至会导致全部数据丢失。CERN的实际数据是，他们每年储存在磁带上的100PB数据（1PB相当于1000TB），每年会损失数百MB；相对的，储存在硬盘上的50PB 数据，这个数字则达数百TB。 &nbsp;&nbsp;&nbsp;&nbsp;还有就是，对于磁带来说，突然断电也不会损坏记录下来的资料，但对于硬盘来说，这是一件危险的事情。​&nbsp;&nbsp;&nbsp;&nbsp;最后也是最重要的，是磁盘一定程度上更加安全。比如说如果一间公司的数据中心被黑客劫持，他可以在数分钟内让硬盘上50PB数据从此在世上消失，但如果磁带的话，不好意思，可能需要数年。 &nbsp;&nbsp;&nbsp;&nbsp;不过，磁带储存并非只与那些每秒就碰撞出几个GB的核子对撞实验室有密切联系。调查表明，磁带储存也同样适合中小型企业。 &nbsp;&nbsp;&nbsp;&nbsp;首先，磁带储存更便宜也更持久。数据在磁带上往往能存放超过30年；硬盘超过5年的话，如果你是公司的IT主管，你就需要考虑将数据转移了。而且磁带目前仍然是储存成本最低的解决方案，目前大概每GB数据在磁带上的成本为4美分，硬盘的话则为10美分。如果考虑到前面所说的寿命问题，差距将会更大。所以，磁带在展示还并没有出现真正消亡的迹象，我们也看到了这个老一代的产品所寻求的生存潜力。 &nbsp;&nbsp;&nbsp;&nbsp;好了，讲完了一个传奇的历史，其实最让我惊奇的是一个已经淡出生活的物件竟然在另外一个领域还有这不俗的影响，磁带就如同软件语言的C++一样，“老” ，乃于它的历史。而技术却一直在改良。磁带和其他大部分储存媒介一样，磁带的储存密度也一直在攀升（遵循摩尔定律）。其实这种想当然的事情并不少见，比如常年混迹手机圈子的人，总会说一句： 索尼要凉 &nbsp;&nbsp;&nbsp;&nbsp;但其实呢，索尼靠着全世界的音乐版权，hi-res，PS系列，相机，电视······如此之多的产业早就让索尼赚的盆满钵满，说不准手机产业就是拿来试水的，到时候，公开宣布退出的时候，大抵又会有人说道： 索尼果然凉了 &nbsp;&nbsp;&nbsp;&nbsp;当然，这其实很正常，因为人类就是这样的生物，在丹尼尔 · 卡尼曼所著的《思考，快与慢》第五章中便描述了这种现象，下面我提出一个问题，再做出分析： 现在我公司有大量的重要数据集静态资源需要长时间稳定使用，仅是用于读取，请问我选取存储介质的时候是选用SSD还是HDD呢？ 请作答。 。 。 。 &nbsp;&nbsp;&nbsp;&nbsp;hummmmm，相信有人很快选了HDD了，因为长时间稳定存储还是大量的存储，听说过SSD损耗的估计都早早排除了SSD这个选项了。事实上呢，这里应该选用SSD，因为仅是用于读取，而SSD的读取是不会有损耗的，仅是写入会有损耗（这里可以去看一下SSD原理就明白了），所以这里建议选取快速的SSD更佳。 &nbsp;&nbsp;&nbsp;&nbsp;当然，你可能会说：“这SSD读取不损耗我也不知道啊”，那你为什么不去百度呢？其实这里是你的“系统1”——经验系统在作怪，你想当然的把你已知的信息带入了当前环境中来，导致你不能存在客观的逻辑判断。 &nbsp;&nbsp;&nbsp;&nbsp;下面是原书中的形容： a b &nbsp;&nbsp;&nbsp;&nbsp;几乎可以说，我们大多数时间都不能离开这个系统，它能帮助我们做出大量的简单的判断，比如闹铃响了需要关闹铃，手机没电了需要充电，这些都是由你的“系统1”来做出判断，但当你被这个系统牵着鼻子走，很少觉得自己会有“系统2”判断的时候，便是你需要警觉的时候，因为，我们独立思考的人格，才是我们作为一个活在这个多面的世界中的最好体现。 &nbsp;&nbsp;&nbsp;&nbsp;这便是小弟的一点点延展思考，仅代表自己的观点，欢迎反驳，但是不喜勿喷，和平讨论。","categories":[{"name":"daily","slug":"daily","permalink":"http://blog.fivezha.cn/categories/daily/"}],"tags":[{"name":"日常瞎写","slug":"日常瞎写","permalink":"http://blog.fivezha.cn/tags/%E6%97%A5%E5%B8%B8%E7%9E%8E%E5%86%99/"},{"name":"思考感悟","slug":"思考感悟","permalink":"http://blog.fivezha.cn/tags/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F/"}]},{"title":"算法(第四版)笔记(5)---约瑟夫环问题","date":"2020-07-17T09:24:23.000Z","path":"2020/07/17/algorithm4-Josephus/","text":"约瑟夫环问题（蛮力，数学解法） 问题约瑟夫问题是一个很著名的杀人问题： 约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。例如：只有三个人，把他们叫做A、B、C，他们围成一圈，从A开始报数，假设报2的人被杀掉。 首先A开始报数，他报1。侥幸逃过一劫。 然后轮到B报数，他报2。非常惨，他被杀了 C接着从1开始报数 接着轮到A报数，他报2。也被杀死了。 最终胜利者是C 可怜，真可怜，数学家真是心狠手辣（雾） 输入这里跟算法第四版的输入有点不一样，这里我们有三个参数： 总人数 剩余人数 间隔人数 输出最后剩余人的编号合集，由逗号分隔 暴力解法说明顾名思义，求，就是嗯求，靠着大量循环做出来的结果。 循环删除直到剩余人数到需要的人数，每一次循环都删除间隔人数后的那个，最后剩下来的就是活着的人。 image-20200721161113695 实现这里有两个实现，可以使用双向队列实现，也可以用循环链表实现。 双向队列实现代码12345678910111213141516171819202122232425262728/** * 双向队列暴力求法 * 就是嗯求 * */fun queueForceSolution(): String &#123; val sb = StringBuilder() // 初始化队列 val deque = Deque&lt;Int&gt;().apply &#123; for (i in 1..totalPeople) pushRight(i) &#125; // 没有到剩余人数就继续循环 while (deque.size != remainPeople) &#123; // 跳过间隔人数 // 这里的跳过为了不影响后面的循环做的是左出右进的方案 for (q in 1 until intervalPeople) deque.pushRight(deque.popLeft()) deque.popLeft() &#125; return sb.apply &#123; deque.forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != deque.size - 1) append(\", \") &#125; &#125;.toString()&#125; 双向队列实现请看算法(第四版)笔记(4)—Deque,Buffer,四数之和,三数之和 分析时间复杂度： 这里的双向队列采用的是链表实现，所以进出队列的时间复杂度都是$\\mathcal{O}(1)$，所以仅用计算循环时间复杂度。 设总人数 $T$，间隔人数 $I$，剩余人数 $R$。$$\\mathcal{O}((T-R)*I)$$空间复杂度： 存在中间数据结构双向队列，非常数级空间复杂度。$$\\mathcal{O}(N)$$ 循环链表实现循环链表循环链表，就是说头尾相连的链表(就像是人体蜈蚣那样) 所以首先来实现循环链表： 循环链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package ds/** * 循环链表 * 此类仅用于约瑟夫环问题 所以api设计很简单 * */class CircularLinkedList&lt;T&gt; : MutableIterable&lt;T&gt; &#123; private var _size = 0 private var first: Node&lt;T&gt;? = null private var last: Node&lt;T&gt;? = null val size get() = _size fun clear() &#123; var n = first while (n != null) &#123; val next = n.next // 快速gc n.item = null n.next = null n.prev = null n = next &#125; first = null last = null _size = 0 &#125; fun isEmpty(): Boolean = _size == 0 fun add(element: T): Boolean &#123; linkedLast(element) return true &#125; override fun iterator(): MutableIterator&lt;T&gt; &#123; return IteratorImpl(0) &#125; private fun getNode(index: Int): Node&lt;T&gt; &#123; val reIndex = index % _size return if (reIndex &lt; (_size shr 1)) &#123; var node = first for (i in 0 until index) &#123; node = node?.next &#125; node!! &#125; else &#123; var node = last for (i in _size - 2 downTo index) &#123; node = node?.prev &#125; node!! &#125; &#125; /** * 连接尾节点 * */ private fun linkedLast(item: T) &#123; val l = last val nNode = Node(item, l, null) last = nNode if (l == null) &#123; first = last &#125; else &#123; l.next = nNode &#125; first!!.prev = nNode nNode.next = first _size++ &#125; /** * 解连接 * */ private fun unlink(node: Node&lt;T&gt;): T &#123; val npre = node.prev val nnext = node.next val nitem = node.item if (npre == last &amp;&amp; nnext == first) &#123; last = null first = null &#125; else &#123; if (node == first) first = nnext if (node == last) last = npre npre!!.next = nnext nnext!!.prev = npre node.next = null node.prev = null &#125; node.item = null _size-- return nitem!! &#125; /** * 转字符串方法 * */ override fun toString(): String &#123; when (_size) &#123; 0 -&gt; return \"[]\" else -&gt; &#123; val sb = StringBuilder() sb.append(\"[\") var n = first while (n != last) &#123; sb.append(\"$&#123;n!!.item&#125;, \") n = n.next &#125; return sb.append(\"$&#123;n!!.item&#125;]\").toString() &#125; &#125; &#125; companion object &#123; private data class Node&lt;T&gt;( var item: T?, var prev: Node&lt;T&gt;?, var next: Node&lt;T&gt;? ) /** * 查看位置是否合法 * */ internal fun checkPositionIndex(index: Int, size: Int) &#123; if (index &lt; 0 || size == 0) &#123; throw IndexOutOfBoundsException(\"index: $index, size: $size\") &#125; &#125; &#125; private inner class IteratorImpl( private var index: Int = 0 ) : MutableIterator&lt;T&gt; &#123; private var current: Node&lt;T&gt;? = null private var lastReturned: Node&lt;T&gt;? = null init &#123; checkPositionIndex(index, size) current = getNode(index) &#125; override fun hasNext(): Boolean = current != null override fun next(): T &#123; if (!hasNext()) &#123; throw NoSuchElementException() &#125; lastReturned = current current = current?.next index++ return lastReturned?.item ?: throw NoSuchElementException() &#125; override fun remove() &#123; unlink(lastReturned ?: throw IllegalStateException()) index-- &#125; &#125;&#125; 主函数实现12345678910111213141516171819202122232425fun linkedListForceSolution(): String &#123; val sb = StringBuilder() val cl = CircularLinkedList&lt;Int&gt;().apply &#123; for (i in 1..totalPeople) add(i) &#125; val iter = cl.iterator() var cnt = 0 while (iter.hasNext() &amp;&amp; cl.size != remainPeople) &#123; iter.next() cnt++ if (cnt == intervalPeople) &#123; iter.remove() cnt = 0 &#125; &#125; return sb.apply &#123; cl.forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != cl.size - 1) append(\", \") else return@apply &#125; &#125;.toString()&#125; 分析时间复杂度： 这里使用的是循环链表实现，所以进出队列的时间复杂度都是$\\mathcal{O}(1)$，所以仅用计算循环时间复杂度。 设总人数 $T$，间隔人数 $I$，剩余人数 $R$。$$\\mathcal{O}((T-R)*I)$$空间复杂度： 存在中间数据结构循环链表，非常数级空间复杂度。$$\\mathcal{O}(N)$$ 数学解法说明其实数学解法也是应用了一种环的思想，但环思想在此解法中仅是辅助作用，主要的思想是倒推和数学归纳法的应用。 我们先从(T = 2, R = 1, I = 3)开始看起： preview 可以看到， 第一轮删除了2，所以第二轮就从2后面的一位元素开始。 因为我们假设整个数组也是环形的，所以数组结尾后面的元素也是开始的元素，如此反复，所以第二轮删除了0 同理，第三轮删除了4 第四轮删除了1 这样，完整的过程我们就模拟完成了，这也是我们前两种方法的主要思路，模拟整个过程，完成计算。但其实，我们并不需要观察整个数组变化的过程，我们只需要观察我们所需要的关键元素就可以了，在这里即是3，我们从最后一轮选择出的结果倒推，直到推导出此元素最开始在原数组中的位置即可直接输出原数组中的元素。注意：这里我们是先正向推导了一遍才可以直接看出来数字是3的，真实情况下我们是不需要正向推导，而是从结果来反推。 比如上面的例子，第一轮反推，我们首先抛弃数字的概念，设定最后选出来的数字x的下标是0。 为反推到第四轮首先先补上间隔数字，得出[a, x, | a, x]，此时x下标为1 再往上反推，得出[a , x , b, | a, x]，所以x下标为1 再往上，[x, b, c, a, | x, b]，所以x下标为0 再往后就是[c, a , d, x, b, | c, a]，所以最终x的坐标就是3 从此，我们可以发现，每一次倒推的数组组成都是末尾+新数字+开头的反向三明治结构，这就导致每一次倒推的数字下标是$(index + I) \\mod K$，$K$为反推后数组大小。 根据数学归纳法，可以推出如下公式： 设函数$f(K, I)$为$K$个报数时，间隔人数为$I$的时候，所求最终胜出的人的编号。$$f(K, I) = (f(K - 1, I) + I) \\mod K$$测试一下$$f(1,3) = 0\\\\f(2,3) = (f(1, 3) + 3) \\mod 2 = 1\\\\f(3,3) = (f(2, 3) + 3) \\mod 3 = 1\\\\f(4,3) = (f(3, 3) + 3) \\mod 4 = 0\\\\f(5,3) = (f(4, 3) + 3) \\mod 5 = 3$$结果正确~ 实现数学实现代码12345678910111213141516fun mathFastSolution(): String &#123; val sb = StringBuilder() val k = MutableList(remainPeople) &#123; it &#125; for (idx in remainPeople + 1..totalPeople) &#123; k.forEachIndexed &#123; index, i -&gt; k[index] = (i + intervalPeople) % idx &#125; &#125; return sb.apply &#123; k.map &#123; it + 1 &#125; .forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != k.size - 1) append(\", \") &#125; &#125;.toString()&#125; 分析时间复杂度： 这里使用的是数学方法实现。 设总人数 $T$，间隔人数 $I$，剩余人数 $R$。$$\\mathcal{O}((T-R+1)*R)$$空间复杂度： 不存在中间数据结构，仅是用到了循环变量，所以是常数级空间复杂度。$$\\mathcal{O}(1)$$ 类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package algorithmsimport ds.CircularLinkedListimport ds.Dequeclass JosephusSolutions( private var totalPeople: Int = 0, private var intervalPeople: Int = 0, private var remainPeople: Int = 1) &#123; init &#123; checkArguments() &#125; private fun checkArguments() &#123; if ( totalPeople &lt;= 0 || remainPeople &lt;= 0 || intervalPeople &lt;= 0 ) &#123; throw IllegalArgumentException(\"人数不能小于等于0！\") &#125; if (totalPeople &lt; remainPeople) throw IllegalArgumentException(\"总人数不能小于剩余人数！\") &#125; fun changePeopleNumbers( totalPeople: Int, intervalPeople: Int, remainPeople: Int ) &#123; this.totalPeople = totalPeople this.intervalPeople = intervalPeople this.remainPeople = remainPeople checkArguments() &#125; /** * 双向队列暴力求法 * 就是嗯求 * */ fun queueForceSolution(): String &#123; val sb = StringBuilder() // 初始化队列 val deque = Deque&lt;Int&gt;().apply &#123; for (i in 1..totalPeople) pushRight(i) &#125; // 没有到剩余人数就继续循环 while (deque.size != remainPeople) &#123; // 跳过间隔人数 // 这里的跳过为了不影响后面的循环做的是左出右进的方案 for (q in 1 until intervalPeople) deque.pushRight(deque.popLeft()) deque.popLeft() &#125; return sb.apply &#123; deque.forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != deque.size - 1) append(\", \") &#125; &#125;.toString() &#125; fun linkedListForceSolution(): String &#123; val sb = StringBuilder() val cl = CircularLinkedList&lt;Int&gt;().apply &#123; for (i in 1..totalPeople) add(i) &#125; val iter = cl.iterator() var cnt = 0 while (iter.hasNext() &amp;&amp; cl.size != remainPeople) &#123; iter.next() cnt++ if (cnt == intervalPeople) &#123; iter.remove() cnt = 0 &#125; &#125; return sb.apply &#123; cl.forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != cl.size - 1) append(\", \") else return@apply &#125; &#125;.toString() &#125; fun mathFastSolution(): String &#123; val sb = StringBuilder() val k = MutableList(remainPeople) &#123; it &#125; for (idx in remainPeople + 1..totalPeople) &#123; k.forEachIndexed &#123; index, i -&gt; k[index] = (i + intervalPeople) % idx &#125; &#125; return sb.apply &#123; k.map &#123; it + 1 &#125;.forEachIndexed &#123; index, i -&gt; append(\"$&#123;i&#125;号\") if (index != k.size - 1) append(\", \") &#125; &#125;.toString() &#125;&#125; GithubGithub","categories":[{"name":"algorithm4","slug":"algorithm4","permalink":"http://blog.fivezha.cn/categories/algorithm4/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://blog.fivezha.cn/tags/kotlin/"},{"name":"algorithm","slug":"algorithm","permalink":"http://blog.fivezha.cn/tags/algorithm/"}]},{"title":"线性动画/非线性动画","date":"2020-05-01T13:34:56.000Z","path":"2020/05/01/linear-anime/","text":"起因是因为今天看到b站上有自媒体评测 MIUI12 , 说到了动画流畅度那方面弹幕都说线性动画非线性动画什么的, 其实很早之前 MUI 就是全线采用非线性动画了, 但这个线性与非线性又是什么, 有什么区别呢, 我今天就稍微来讲一下.其实这个高中就学习过了, 不过因为最近学习了js, 可以更加明确的展示出来了. 什么是线性动画/非线性动画要理解这个, 首先需要理解一个问题: *什么是动画? * 什么是动画?根据 维基百科 所叙述的: 动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 可以了解到, 动画, 其实就是很多静止的画面利用视觉残留现象做出来的可动的效果, 所以说如果想要模仿动画的效果, 只需要在1s内对一张图片更替一定的量的次数, 人眼就不会看出是否对这张图片进行了更替, 这, 其实就是 帧 .同时,并不是所有的 帧 都是会更改的, 有些帧完全就是不会变化的, 这就引出了 关键帧 的概念, 我们只需要着重关注于关键更改了图象的 帧 即可, 并不需要关注其他状态的 静止帧 .本次编程实践也是只针对于关键帧处理的. 什么是非线性动画在 Maya 用户指南上有这么一句话: 在 Maya 中，有两种类型的片段：源片段和常规剪辑。Maya 通过将角色的原始动画曲线保存在源片段中，来保留及保存角色原始动画曲线。请勿使用源片段为角色设置动画。但是，您可以使用源片段（称为_常规片段_）的副本或_实例_以非线性方式为角色设置动画。请参见动画片段。 __非线性动画的基础是，移动、操纵和混合常规片段，从而为角色生成一系列平滑的动作。_&gt; 看上去很高级, 说白了其实就是动画的关键帧停留位置(时段), 也就是说, 非线性的关键帧所停留的并不是处于常见规律中的, 他可能是遵循二次函数, 遵循震荡函数, 总之, 其规律一定不是线性规律(一次函数). 什么是线性动画所以, 线性动画就很容易理解了, 所有关键帧停留位置其实都是处在一条线中的, 其导数永远是常数. 线性动画/非线性动画有什么用那么, 非线性动画又有着什么样的特殊用途呢?很简单的, 应用在手机上, 这会让你的动画感觉更有动感, 更加精致, 不会像是线性动画那样, 一板一眼.比如 IOS 一直都是非线性动画, 给人的感受就非常的丝滑.而早年间的 Android 动画都是线性动画, 给人的感觉就像是机械一般的精密但刻板. 简单的线性动画(点击图片看动画): img See the Pen 线性动画 by !输认不永DGL (@xmmmmmovo) on CodePen. 简单的非线性(点击图片看动画):圆弧非线性 img See the Pen 加速非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 加减速非线性先加速再减速, 二次函数 See the Pen 二次非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 碰撞反弹 img 如果在开始时有动画效果，比如弹跳 —— 那么它将在最后显示。上图中常规弹跳为红色，easeOut 弹跳为蓝色。 常规弹跳 —— 物体在底部弹跳，然后突然跳到顶部。 easeOut 变换之后 —— 物体跳到顶部之后，在那里弹跳。 See the Pen 碰撞非线性 by !输认不永DGL (@xmmmmmovo) on CodePen. 总结如果理论看不懂, 那大概看例子也能领会了, 有些东西, 不知道是不是我语文太差的缘故, 理论实在是难以形容, 但是当实际例子展示出来了之后, 就会发现, 其实这个还是很容易理解/看出来的嘛.","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"animation","slug":"animation","permalink":"http://blog.fivezha.cn/tags/animation/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.fivezha.cn/tags/javascript/"}]},{"title":"docker笔记","date":"2020-04-24T13:31:13.000Z","path":"2020/04/24/docker-note/","text":"一点点docker笔记 安装docker12345678910111213141516171819curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyunsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\", \"https://dockerhub.azk8s.cn\" ], \"insecure-registries\" : [ \"hub-mirror.c.163.com\", \"mirror.baidubce.com\", \"dockerhub.azk8s.cn\" ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 安装docker-compose12sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 利用Dockerfile定制镜像1234567891011# flask部署FROM python:3.7COPY . /codeWORKDIR /codeRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; pip install -r /code/requirements.txt# 如果太慢了再加上这句 不然镜像站有可能同步不全导致包安装失败# -i https://pypi.tuna.tsinghua.edu.cn/CMD gunicorn app:app -c gunicorn.conf.py --error-logfile /log/gunicorn.log 123docker build -t 'name' .docker run -it 'name'docker run -d 'name' COPY 复制文件 CMD 容器启动命令 ENV 设置环境变量 WORKDIR 指定工作目录 常用指令 docker image/container ls 列出所有镜像/容器 docker rm … 删除镜像 docker attach … 进入容器 docker ps -a 列出所有的container包括没有运行的 docker-compose1234567891011121314151617181920212223242526272829303132# flask redis nginx mysql部署version: '3.6'services: web: build: . container_name: web volumes: - ../logs:/log depends_on: - db - redis db: image: mysql:5.7 environment: - MYSQL_ROOT_PASSWORD=mx/58MFuLJ6^%.q volumes: - ./config/mysql:/docker-entrypoint-initdb.d nginx: image: nginx:1.17 volumes: - ./config/nginx/default.conf:/etc/nginx/conf.d/default.conf depends_on: - web ports: - 8888:80 redis: image: redis:5.0.8 volumes: - ./config/redis/redis.conf:/etc/redis/redis.conf command: redis-server privileged: true build 利用Dockerfile编译的目录 image 镜像 volumes 目录映射关系 depend_on 依赖于 当依赖启动后本service才能启动 port 开放的端口映射 environment 环境变量 privileged 权限 command 自带命令行 常用指令 docker-compose start docker-compose stop docker-compose top 奇技淫巧列出所有的容器 ID1docker ps -aq 停止所有的容器1docker stop $(docker ps -aq) 删除所有的容器1docker rm $(docker ps -aq) 删除所有的镜像1docker rmi $(docker images -q) docker1.3之后的资源清理12docker image prune --force --all # 删除所有不使用的镜像docker container prune -f # 删除所有停止的容器","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.fivezha.cn/tags/docker/"}]},{"title":"opencv中高斯模糊(滤波器)的源码解析(c++版)","date":"2019-02-25T11:40:25.000Z","path":"2019/02/25/gaussianbulr-analyze/","text":"因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码 分析函数接口首先，在下用的是vs版本的opencv，是直接编译好给你静态库(.lib)文件的，所以当我按住ctrl寻找GaussianBlur这个函数时 只发现了其在imgproc.hpp里面提供给你的接口。 大概是下面这个样子的: 高斯模糊函数接口1 高斯模糊函数接口2 该函数将源图像与指定的卷积核进行卷积。并且支持原图像直接进行滤波操作。 可以看到这个函数接口主要由四个部分组成: CV_EXPORTS_W继续往上找 可以发现这是一个宏定义 可以发现 这个宏定义是在编译阶段将CV_EXPORTS替换为了CV_EXPORTS_W再向上查找 会发现 这里又是一个宏组成的用以定义CV_EXPORTS的宏组，这一段其实就是类似于if else的结构，主要的作用机理便是适配各类环境(操作系统) 。从中，我们这里又分成了三个部分进行解析: #if (defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__) &amp;&amp; defined CVAPI_EXPORTS可以看到，这里判断了两个表达式的逻辑与((defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__)和defined CVAPI_EXPORTS) 首先，defined的意义在于寻找后面的字段是否已经被宏定义过。 其次，观察第一个表达式，发现_WIN32 在之前已经被定义过了，通过查阅微软官方宏定义文档发现这个字段作用是基于编译器一个信号，表明是Windows环境下编译及运行的程序。 再查找前后未定义过的字段，继而发现WIN32是只要包含了 Windows.h，那么 WIN32 常量是肯定定义了的设定，不能用于判断平台环境。而WINCE便是判断是否为WINCE环境的程序__CYGWIN__如果事先有了解过cygwin这个程序的话，这个应该不难看懂，也是用以判断环境的定义，而cywin则是在Windows环境下用以模拟Unix环境的软件(P.S.还是蛮好用的) 再次，观察第二个表达式，也是查找字段是否定义过，这个查了一下，发现这个宏定义是存在于opencv.dll这个文件里面的。也就是判断是否已经链接了动态库。 这样这一行便很容易懂了，目的便是判断程序环境是否为Windows且已经链接opencv.dll的库用以进行下一步操作。 再提一句，关于这个操作系统(环境)的判定其实还有很多，这里放一个Qt里面关于系统判定的头文件(147行开始)(版本比较老了 可自行再自己qt里查看) # define CV_EXPORTS __declspec(dllexport)这一句涉及到的主要是dll函数导入，需要和下面最后三行联合起来看#define CV_EXPORTS第二行需要联合上面这句一同分析，首先，这个头文件内部写的都是接口，都是作者自己编写留给别人用以调用的，并且从第一点分析的结果来看，这些接口的实现都是放在opencv.dll文件中的，而第一行的判断便是判断你是否在最需要隐式调用，如果有，那么直接可以利用隐式调用的方法进行函数导出(具体__declspec也有在微软文档里写)反之，如果判断事先未进行链接，那么使用的时候必然是显式调用(没错，就是配置环境的时候配置的lib文件链接，那就是显式调用了参考此篇文章)，既然是显式调用，自然便不需要进行函数导出操作。所以将CV_EXPORTS字段设置为空。 elif defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 4define CV_EXPORTS __attribute__((visibility(&quot;default&quot;)))这两句涉及的主要有两个功能: 1. 判断是否为GCC编译环境 2. 为全局动态库函数设置非隐藏声明对于第一点，类似于分析第一条，可以知道这句的意思便是检查gcc并测试是否高于4.0.0版本(猜测与c++标准有关) void函数返回值，这里返回值为空 GaussianBlur函数名，这里因为是声明所以是跟源码的函数一样，可以很快找到源码定义。 ()括号里面的是函数参数根据上面的说明注释，便可解读出这个函数所有参数意义: src 这是输入图像，这个图像可以拥有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。 dst 这是输出图像，大小与类型与src相同。 ksize 这是卷积核的大小参数(是数字desu)。其中ksize.width和ksize.height可以不同，但是它们必须是一个正奇数(或者零)，并且您不用担心卷积核内部参数问题，卷积核会根据sigma来计算。 sigmaX X方向的卷积核标准偏差。 sigmaY Y方向的高斯核标准偏差; 如果sigmaY为零，则设置为等于sigmaX，如果两个sigma都是零，则它们是从ksize.width和ksize.height计算的（详见cv :: getGaussianKernel）; 这些语义未来均有可能修改，建议指定所有ksize，sigmaX和sigmaY。 borderType 像素外推模式，请参阅cv :: BorderTypes sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur。这里显示了函数的相关函数，是观察源码的重要提示 这样，对于函数接口的解析就算是完成了，从中我们可以得出以下几个结论： 直接ctrl寻找到底是不能找到原函数代码的。 找到原函数的同时也需要sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur这一些列函数辅助理解。 这个函数在cv命名空间中，名称应该为cv::GaussianBlur 。 所以接下来第一步便是需要在源码中寻找到真正的函数实现。 源码解析理解高斯模糊函数高斯模糊函数本质是利用高斯滤波器对于给定图像进行平滑操作。平滑操作时什么，是减少噪点。噪点的原因又是什么，是单个像素包含的信息过于独立。如何减少噪点，很简单，只需要让每个像素点包含有周围像素的部分信息就行了呗。选用什么方法，最简单的方法便是——卷积(见下图)。利用一个给定的以某种分布函数构建的二维卷积内核，将中心点对准像素点，进行卷积操作，得到的像素点便包含了周围像素的不完全信息，这样子附近的像素点差异性便会越来越小，当整张图像(或选中部分)卷积完成后，每个像素点便不再过于独立，每个便有了附近像素点的信息，这样字图像便不会看上去那么的“扎眼”，会温润平滑许多，这就是高斯模糊的本质了。 卷积操作 [相信看图大概大家就能明白卷积是个啥东西了 再结合上面语句应该就差不多了] 查找函数利用grep命令，很容易便能找到这个函数，找到文件并切到这个函数定义，便可以窥见整个函数的全貌了。 查找 以下是cv::GaussianBlur函数全貌: func1 func2 分析函数分析这个函数之前，首先先要从内部关联的函数看起。 CV_INSTRUMENT_REGION()这一行末尾没有分号，这样的类似函数的字符段有很大可能是一个宏定义变量，经查找，在private.hpp文件中有以下定义： ///// General instrumentation // General OpenCV region instrumentation macro #define CV_INSTRUMENT_REGION() CV_INSTRUMENT_REGION_META(cv::instr::TYPE_GENERAL, cv::instr::IMPL_PLAIN) 经查找，这个字段主要是关于初始化以及边界类型的判断。 if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )1234567891011121314151617181920212223242526272829303132333435363738394041int type = _src.type();Size size = _src.size();_dst.create( size, type );/** 根据说明文档中所写的 BORDER_CONSTANT = 0, //!&lt; `iiiiii|abcdefgh|iiiiiii`with some specified `i` BORDER_REPLICATE = 1, //!&lt; `aaaaaa|abcdefgh|hhhhhhh` BORDER_REFLECT = 2, //!&lt; `fedcba|abcdefgh|hgfedcb` BORDER_WRAP = 3, //!&lt; `cdefgh|abcdefgh|abcdefg` BORDER_REFLECT_101 = 4, //!&lt; `gfedcb|abcdefgh|gfedcba` BORDER_TRANSPARENT = 5, //!&lt; `uvwxyz|absdefgh|ijklmno` BORDER_REFLECT101 = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_DEFAULT = BORDER_REFLECT_101, //!&lt; same as BORDER_REFLECT_101 BORDER_ISOLATED = 16 //!&lt; do not look outside of ROI BORDER_CONSTANT 需要设置borderValue 指定 ' i ' 值（常数） BORDER_REPLICATE ，复制边界像素 BORDER_REFLECT ，反射复制边界像素 BORDER_REFLECT_101，以边界为对称轴反射复制像素*//* 这里是说如果边缘扩展不是常数扩展，且在规定图像范围内部，便执行下列操作*/if( borderType != BORDER_CONSTANT &amp;&amp; (borderType &amp; BORDER_ISOLATED) != 0 )&#123; // 如果输入矩阵是一个行向量，则滤波核的高强制为1 // 下面同理 if( size.height == 1 ) ksize.height = 1; if( size.width == 1 ) ksize.width = 1;&#125;// 如果核宽跟核高都是一直接复制输出if( ksize.width == 1 &amp;&amp; ksize.height == 1 )&#123; _src.copyTo(_dst); return;&#125; CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))这里很明显是一个被宏定义的字段，通过查找，我们能够找到其定位在modules/core/include/opencv2/core/openvx/ovx_defs.hpp当中 func3 按每行解析的话就是如下: 123456789101112131415161718192021// 用于检测基于OpenVX的实现的实用程序宏#ifdef HAVE_OPENVX // 如果检测到OPENVX便执行下列语句 // 下面这两句主要作用也是标识 #define IVX_HIDE_INFO_WARNINGS // 隐藏警告信息 #define IVX_USE_OPENCV // 使用opencv的标识 #include \"ivx.hpp\" // 将hpp文件包含进来 #define CV_OVX_RUN(condition, func, ...) \\ // ...会被替换 // 这里为了给外界提供OpenVX使用表示 利用宏定义做成了一个接口 // 而这个接口则是主要为了提供硬件层面加速用的(主要面向对象是嵌入式设计) if (cv::useOpenVX() &amp;&amp; (condition) &amp;&amp; func) \\ &#123; \\ // __VA_ARGS__是可变参数宏定义 用以替换上面...的内容 return __VA_ARGS__; \\ &#125;#else // 否则便执行下面这条 #define CV_OVX_RUN(condition, func, ...)#endif // HAVE_OPENVX 其中useOpenVX()函数主要是返回一个bool类型的变量用以判断是否使用openVX用以计算。 所以CV_OVX_RUN()这句话便是对于嵌入式设计进行尝试性的优化操作。 ifdef至endif部分123456789//若之前有过HAVE_TEGRA_OPTIMIZATION优化选项的定义，则执行宏体中的tegra优化版函数并返回#ifdef HAVE_TEGRA_OPTIMIZATION // 拷贝到临时变量(暂不知为什么要拷贝到一个临时变量里面去) Mat src = _src.getMat(); Mat dst = _dst.getMat(); if(sigma1 == 0 &amp;&amp; sigma2 == 0 &amp;&amp; tegra::useTegra() &amp;&amp; tegra::gaussian(src, dst, ksize, borderType)) return;#endif 这里也显而易见是尝试tegra优化。 但是为什么拷贝到临时变量里也可以改变原值，这里需要进一步到Mat变量的运算符重载里面进行参考。 12345678910111213141516171819202122232425262728293031inlineMat&amp; Mat::operator = (const Mat&amp; m)&#123; if( this != &amp;m ) &#123; if( m.u ) CV_XADD(&amp;m.u-&gt;refcount, 1); release(); // 归零初始化 /** 归零后进行基本数据共享 */ flags = m.flags; if( dims &lt;= 2 &amp;&amp; m.dims &lt;= 2 ) &#123; dims = m.dims; rows = m.rows; cols = m.cols; step[0] = m.step[0]; step[1] = m.step[1]; &#125; else copySize(m); data = m.data; datastart = m.datastart; // 共享数据头 dataend = m.dataend; // 共享数据尾 datalimit = m.datalimit; allocator = m.allocator; // 内存共享 u = m.u; &#125; return *this; // 返回当前对象的引用&#125; 我们可以发现在=重载的时候仅是进行的浅拷贝操作，意思是只将数据头数据尾进行复制，而所有数据的内存数据都是相通共享的。固仅需要一方变量更改便会联动所有对其进行过浅拷贝的变量变化。 剩下部分1234567891011121314151617181920212223242526272829/** 这里主要是针对opencl(GPU加速)无法使用的情况进行CPU版本计算 这个IPP是一个Intel提供的开源的计算机视觉加速库，可以提供很多算法的Intel专属的多线程优化方案API，这也是为什么下面在opencl的gpu优化代码之后还又添加了利用CPU版本的filter2D的计算方案(因为有部分Intel专属的优化函数，针对APU和老式的Intel CPU(09年之前)无法进行计算，所以只能选取最普通的filter2D计算方案执行) 官网FAQ(有兴趣可以了解一下): https://software.intel.com/en-us/articles/intel-integrated-performance-primitives-intel-ipp-open-source-computer-vision-library-opencv-faq/*/CV_IPP_RUN(!(ocl::useOpenCL() &amp;&amp; _dst.isUMat()), ipp_GaussianBlur( _src, _dst, ksize, sigma1, sigma2, borderType));Mat kx, ky;/** 这里是新建一个高斯卷积内核(后面讲)*/createGaussianKernels(kx, ky, type, ksize, sigma1, sigma2);/** 这里是针对ksize = 3 or 5的情况做了opencl优化(A卡N卡均可享受opencl优化qwq)*/CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= 2 &amp;&amp; ((ksize.width == 3 &amp;&amp; ksize.height == 3) || (ksize.width == 5 &amp;&amp; ksize.height == 5)) &amp;&amp; (size_t)_src.rows() &gt; ky.total() &amp;&amp; (size_t)_src.cols() &gt; kx.total(), ocl_GaussianBlur_8UC1(_src, _dst, ksize, CV_MAT_DEPTH(type), kx, ky, borderType));/** 这里便是利用filter2D进行操作了 传入Point(-1, -1) 是指内核中的锚点(就是后面的anchor)位置。默认值（-1，-1）表示锚点位于内核中心。 0 则是存储单位 默认是0 后面会通过计算改变并存储*/sepFilter2D(_src, _dst, CV_MAT_DEPTH(type), kx, ky, Point(-1,-1), 0, borderType); 这里在下主要解析createGaussianKernels与sepFilter2D这两个函数，主要是因为无论是openvx_gaussianBlur还是ipp_GaussianBlur以及ocl_GaussianBlur_8UC1都有着大量未知的API，要读懂这些API还需要大量文档查阅，在下在此就先不解析了。 所以首先先来看一下createGaussianKernels这个函数： 1234567891011121314151617181920212223242526272829303132333435/** 这个函数仅是用于是创建高斯卷积核*/static void createGaussianKernels( Mat &amp; kx, Mat &amp; ky, int type, Size ksize, double sigma1, double sigma2 )&#123; int depth = CV_MAT_DEPTH(type); // 根据输入图像类型获得位深度 if( sigma2 &lt;= 0 ) sigma2 = sigma1; // 非正则与sigma1相同 // 从sigma自动检测内核大小(如果用户没有设置ksize的话) // 根据CV_8U来计算 大致接近7*sigma 或者 9*sigma // cvRound函数还内联了汇编 在下看不懂了 // |1 的原因是使宽高为奇数 if( ksize.width &lt;= 0 &amp;&amp; sigma1 &gt; 0 ) ksize.width = cvRound(sigma1*(depth == CV_8U ? 3 : 4)*2 + 1)|1; if( ksize.height &lt;= 0 &amp;&amp; sigma2 &gt; 0 ) ksize.height = cvRound(sigma2*(depth == CV_8U ? 3 : 4)*2 + 1)|1; // 这句只是为了保证卷积核的宽跟高是正奇数 CV_Assert( ksize.width &gt; 0 &amp;&amp; ksize.width % 2 == 1 &amp;&amp; ksize.height &gt; 0 &amp;&amp; ksize.height % 2 == 1 ); // 取最大 sigma1 = std::max( sigma1, 0. ); sigma2 = std::max( sigma2, 0. ); kx = getGaussianKernel( ksize.width, sigma1, std::max(depth, CV_32F) ); if( ksize.height == ksize.width &amp;&amp; std::abs(sigma1 - sigma2) &lt; DBL_EPSILON ) // 这里 如果判断核高与核宽相等，且sigma相差很小的情况下 // 便可以直接进行赋值操作，减少了计算量 ky = kx; else ky = getGaussianKernel( ksize.height, sigma2, std::max(depth, CV_32F) );&#125; 从中我们还需要解析getGaussianKernel这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768cv::Mat cv::getGaussianKernel( int n, double sigma, int ktype )&#123; // 这里定义了一个常量用以规定大小 const int SMALL_GAUSSIAN_SIZE = 7; // 一个4 * 7的矩阵，用于对奇数长度小内核进行优化计算 static const float small_gaussian_tab[][SMALL_GAUSSIAN_SIZE] = &#123; &#123;1.f&#125;, &#123;0.25f, 0.5f, 0.25f&#125;, &#123;0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f&#125;, &#123;0.03125f, 0.109375f, 0.21875f, 0.28125f, 0.21875f, 0.109375f, 0.03125f&#125; &#125;; /** 这里计算滤波系数（数组） 如果 内核尺寸为奇数 且小于7 并且sigma小于等于0 那么滤波系数便是根据上面的small_gaussian_tab决定的 否则便是0 */ const float* fixed_kernel = n % 2 == 1 &amp;&amp; n &lt;= SMALL_GAUSSIAN_SIZE &amp;&amp; sigma &lt;= 0 ? small_gaussian_tab[n&gt;&gt;1] : 0; /** 检测数据类型是否为float和double */ CV_Assert( ktype == CV_32F || ktype == CV_64F ); Mat kernel(n, 1, ktype); // 建立一维向量 // 定义指针指向数据 float* cf = kernel.ptr&lt;float&gt;(); double* cd = kernel.ptr&lt;double&gt;(); // 当sigma小于0时，采用公式得到sigma(只与n有关)，大于0就可以直接使用了。 double sigmaX = sigma &gt; 0 ? sigma : ((n-1)*0.5 - 1)*0.3 + 0.8; // 表达式中e指数要用到 double scale2X = -0.5/(sigmaX*sigmaX); double sum = 0; int i; for( i = 0; i &lt; n; i++ ) &#123; double x = i - (n-1)*0.5; // 根据上面计算出来的系数来决定是否重新计算值 double t = fixed_kernel ? (double)fixed_kernel[i]:std::exp(scale2X*x*x); //根据精度选择变量 if( ktype == CV_32F ) &#123; cf[i] = (float)t; sum += cf[i]; &#125; else &#123; cd[i] = t; sum += cd[i]; &#125; &#125; sum = 1./sum; // 归一化操作，计算需要除的数值 for( i = 0; i &lt; n; i++ ) &#123; if( ktype == CV_32F ) cf[i] = (float)(cf[i]*sum); else cd[i] *= sum; &#125; return kernel; // 返回建立好的一维内核&#125; 这两个函数的主要目的就是计算出高斯卷积核，这里选用分离计算，就是先计算水平（x）方向的一维卷积核，再根据sigma判断是否重新计算垂直（y）方向的一维卷积内核，这样子分离计算再针对尺寸较大的滤波器也可以有很高的效率，并且分离计算结合多线程也是很好的选择。 看完高斯内核的建立，我们知道高斯模糊主要利用了分离计算，那最后sepFilter2D函数也很容易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void cv::sepFilter2D( InputArray _src, OutputArray _dst, int ddepth, InputArray _kernelX, InputArray _kernelY, Point anchor, double delta, int borderType )&#123; CV_INSTRUMENT_REGION() /* 这里考虑如果输入函数是UMat形式且维度小于等于2的情况下 优先考虑使用opencl优化过的filter2D计算 */ CV_OCL_RUN(_dst.isUMat() &amp;&amp; _src.dims() &lt;= 2 &amp;&amp; (size_t)_src.rows() &gt; _kernelY.total() &amp;&amp; (size_t)_src.cols() &gt; _kernelX.total(), ocl_sepFilter2D(_src, _dst, ddepth, _kernelX, _kernelY, anchor, delta, borderType)) Mat src = _src.getMat(), kernelX = _kernelX.getMat(), kernelY = _kernelY.getMat(); if( ddepth &lt; 0 ) ddepth = src.depth(); _dst.create( src.size(), CV_MAKETYPE(ddepth, src.channels()) ); Mat dst = _dst.getMat(); /* 找到src的矩阵的矩阵头存入wsz当中，并且将偏移量存入ofs变量中 这两个变量用于快速读取全部图像 */ Point ofs; Size wsz(src.cols, src.rows); if( (borderType &amp; BORDER_ISOLATED) == 0 ) src.locateROI( wsz, ofs ); /* 进行预先检测内核是否有误 */ CV_Assert( kernelX.type() == kernelY.type() &amp;&amp; (kernelX.cols == 1 || kernelX.rows == 1) &amp;&amp; (kernelY.cols == 1 || kernelY.rows == 1) ); Mat contKernelX = kernelX.isContinuous() ? kernelX : kernelX.clone(); Mat contKernelY = kernelY.isContinuous() ? kernelY : kernelY.clone(); /* 生成一个二维滤波(filter2D)引擎 */ Ptr&lt;hal::SepFilter2D&gt; c = hal::SepFilter2D::create( src.type(), dst.type(), kernelX.type(), contKernelX.data, kernelX.cols + kernelX.rows - 1, contKernelY.data, kernelY.cols + kernelY.rows - 1, anchor.x, anchor.y, delta, borderType &amp; ~BORDER_ISOLATED); /* 调用这个引擎 */ c-&gt;apply(src.data, src.step, dst.data, dst.step, dst.cols, dst.rows, wsz.width, wsz.height, ofs.x, ofs.y);&#125; 剩下的便是寻找到这个引擎跟调用函数的实现了。 12345678910111213141516171819202122232425262728293031/* Ptr类似于boost::shared_ptr，它是Boost库的一部分 (http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm) 和 std::shared_ptr[C ++ 11标准]（http://en.wikipedia.org/wiki/C++11） P.S.其实大部分c++11标准都是boost库里面抄过来的*/Ptr&lt;SepFilter2D&gt; SepFilter2D::create(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType)&#123; &#123; ReplacementSepFilter * impl = new ReplacementSepFilter(); if (impl-&gt;init(stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType)) &#123; return Ptr&lt;hal::SepFilter2D&gt;(impl); &#125; delete impl; &#125; &#123; OcvSepFilter * impl = new OcvSepFilter(); impl-&gt;init(stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType); return Ptr&lt;hal::SepFilter2D&gt;(impl); &#125;&#125; 经查找，SepFilter2D是一个结构体，内含有上面的create函数以及两个虚函数(apply与析构函数)，这就说明对于不同的impl有着不同的apply跟init。 然后，从ReplacementSepFilter的函数开始看起: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** 这个结构体继承自SepFilter2D 具体作用便是使用hal api进行优化加速计算 是一个关于移动和嵌入式设计的库*/struct ReplacementSepFilter : public hal::SepFilter2D&#123; /** 这里的cvhalFilter2D是一个结构体 其目的就是作为context变量使用(ctx 便是context简写) */ cvhalFilter2D *ctx; bool isInitialized; /** 委托构造函数 委托了两个构造函数进行构造 一个是定义了context为0，另一个则是定义了isInitialized为否 关于context(上下文)这个概念可以百度一下 在下是看的这篇: https://wanderinghorse.net/computing/papers/context_types.html */ ReplacementSepFilter() : ctx(0), isInitialized(false) &#123;&#125; /** 初始化函数 */ bool init(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType) &#123; // 这里返回的值根据是否初始化成功赋值的 int res = cv_hal_sepFilterInit(&amp;ctx, stype, dtype, ktype, kernelx_data, kernelx_len, kernely_data, kernely_len, anchor_x, anchor_y, delta, borderType); // 这里首先判断res是否与CV_HAL_ERROR_OK(0)相等 // 如果不相等便将0赋值给isInitialized // 否则便是将1赋值 isInitialized = (res == CV_HAL_ERROR_OK); return isInitialized; &#125; /** 这个是ReplacementSepFilter的执行函数 */ void apply(uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, int width, int height, int full_width, int full_height, int offset_x, int offset_y) &#123; if (isInitialized) &#123; // 这里是调用并返回是否成功的结果 int res = cv_hal_sepFilter(ctx, src_data, src_step, dst_data, dst_step, width, height, full_width, full_height, offset_x, offset_y); // 判断res是否与CV_HAL_ERROR_OK(0)不等 // 如果不等便无法调用 // 进入错误选项跳出滤波器 if (res != CV_HAL_ERROR_OK) CV_Error(Error::StsNotImplemented, \"Failed to run HAL sepFilter implementation\"); &#125; &#125; /** 这里的析构函数在本篇不解析 */ ~ReplacementSepFilter() &#123; if (isInitialized) &#123; int res = cv_hal_sepFilterFree(ctx); if (res != CV_HAL_ERROR_OK) CV_Error(Error::StsNotImplemented, \"Failed to run HAL sepFilter implementation\"); &#125; &#125;&#125;; 在接下来便是OcvSepFilter函数: 12345678910111213141516171819202122232425262728293031323334353637383940struct OcvSepFilter : public hal::SepFilter2D&#123; /** 建立一个滤波引擎 f */ Ptr&lt;FilterEngine&gt; f; int src_type; int dst_type; bool init(int stype, int dtype, int ktype, uchar * kernelx_data, int kernelx_len, uchar * kernely_data, int kernely_len, int anchor_x, int anchor_y, double delta, int borderType) &#123; src_type = stype; dst_type = dtype; /** 分离卷积所以建立了X与Y的卷积内核 */ Mat kernelX(Size(kernelx_len, 1), ktype, kernelx_data); Mat kernelY(Size(kernely_len, 1), ktype, kernely_data); /** 创建一个创建可分离的线性滤波器 */ f = createSeparableLinearFilter( stype, dtype, kernelX, kernelY, Point(anchor_x, anchor_y), delta, borderType &amp; ~BORDER_ISOLATED ); return true; &#125; void apply(uchar* src_data, size_t src_step, uchar* dst_data, size_t dst_step, nt width, int height, int full_width, int full_height, int offset_x, int offset_y) &#123; Mat src(Size(width, height), src_type, src_data, src_step); Mat dst(Size(width, height), dst_type, dst_data, dst_step); // 因为Ptr将模板设置为了FilterEngine，所以这里apply调用的是FilterEngine的启动函数 f-&gt;apply(src, dst, Size(full_width, full_height), Point(offset_x, offset_y)); &#125;&#125;; 然后便是分析createSeparableLinearFilter 这个函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230/** 可以看到其返回的是是一个引擎， 所以里面肯定是有横向与纵向线性滤波器了(所以才使用可分离的qwq)*/cv::Ptr&lt;cv::FilterEngine&gt; cv::createSeparableLinearFilter( int _srcType, int _dstType, InputArray __rowKernel, InputArray __columnKernel, Point _anchor, double _delta, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; // 定义变量 Mat _rowKernel = __rowKernel.getMat(), _columnKernel = __columnKernel.getMat(); // 求矩阵的数组类型，数据类型包过通道数，深度，和据类型3种 _srcType = CV_MAT_TYPE(_srcType); _dstType = CV_MAT_TYPE(_dstType); // 求深度(输入输出都求) int sdepth = CV_MAT_DEPTH(_srcType), ddepth = CV_MAT_DEPTH(_dstType); // 求输入矩阵的通道数并判断输入矩阵是否与输出矩阵通道数相等 int cn = CV_MAT_CN(_srcType); CV_Assert( cn == CV_MAT_CN(_dstType) ); // rowsize int rsize = _rowKernel.rows + _rowKernel.cols - 1; // columnsize int csize = _columnKernel.rows + _columnKernel.cols - 1; // 如果内核锚点是负数，则从中心点开始进行 if( _anchor.x &lt; 0 ) _anchor.x = rsize/2; if( _anchor.y &lt; 0 ) _anchor.y = csize/2; /** 获得内核的类型 大致分为五种： KERNEL_GENERAL 通用内核 无任何对称性或其他属性 KERNEL_SYMMETRICAL kernel[i] == kernel[ksize-i-1] (系数对称)，且锚点位于中心 KERNEL_ASYMMETRICAL kernel[i] == -kernel[ksize-i-1] (系数相反对称)，锚点同上 KERNEL_SMOOTH 所有内核元素都是非负的并且总和为1 KERNEL_INTEGER 所有内核系数都是整数 */ int rtype = getKernelType(_rowKernel, _rowKernel.rows == 1 ? Point(_anchor.x, 0) : Point(0, _anchor.x)); int ctype = getKernelType(_columnKernel, _columnKernel.rows == 1 ? Point(_anchor.y, 0) : Point(0, _anchor.y)); Mat rowKernel, columnKernel; /** 在CV_32F, sdepth, ddepth中找到最大值并赋值给bdepth bdepth: 位深度 */ int bdepth = std::max(CV_32F,std::max(sdepth, ddepth)); int bits = 0; /** 判断如果 输入输出图像都是8位无符号型且内核使用平滑对称核 或者 输出图像为16位有符号型且使用整形对称或反对称核 那么就不需要进行任何转换便可以直接使用， 否则便需要转换，因为输入前后的图像格式是完全相等的 所以delta就默认是0了 */ if( sdepth == CV_8U &amp;&amp; ( (rtype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp; ctype == KERNEL_SMOOTH+KERNEL_SYMMETRICAL &amp;&amp; ddepth == CV_8U) || ( (rtype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp; (ctype &amp; (KERNEL_SYMMETRICAL+KERNEL_ASYMMETRICAL)) &amp;&amp; (rtype &amp; ctype &amp; KERNEL_INTEGER) &amp;&amp; ddepth == CV_16S ) ) ) &#123; // 重新给bdepth赋值 bdepth = CV_32S; // 此时bits(单位字节)将根据位深度进行计算，如果是8位无符号型则直接赋值为8位 bits = ddepth == CV_8U ? 8 : 0; // 此时将row内核转换为CV_32S，即32位整数型，并且根据单位字节转换比例因子 // 如果不加比例因子那么图像会变得很白 // (可参见这篇提问https://bbs.csdn.net/topics/392411554) // 比例因子：将原矩阵的所有元素乘以alpha _rowKernel.convertTo( rowKernel, CV_32S, 1 &lt;&lt; bits ); _columnKernel.convertTo( columnKernel, CV_32S, 1 &lt;&lt; bits ); // 在这里是将单位字节*2 bits *= 2; // 根据单位字节计算出了存储单位(偏移量) _delta *= (1 &lt;&lt; bits); &#125; else &#123; /** 如果不属于上面if里的任何一种情况，那么需要进行转换，用以使数据类型统一 */ if( _rowKernel.type() != bdepth ) _rowKernel.convertTo( rowKernel, bdepth ); else rowKernel = _rowKernel; if( _columnKernel.type() != bdepth ) _columnKernel.convertTo( columnKernel, bdepth ); else columnKernel = _columnKernel; &#125; // 缓冲区存储，用于写入单个色所有素信息(包括多通道与深度信息) int _bufType = CV_MAKETYPE(bdepth, cn); // getLinearRowFilter是根据不同的输入图像类型，输出图像返回不同的线性滤波器 Ptr&lt;BaseRowFilter&gt; _rowFilter = getLinearRowFilter( _srcType, _bufType, rowKernel, _anchor.x, rtype); Ptr&lt;BaseColumnFilter&gt; _columnFilter = getLinearColumnFilter( _bufType, _dstType, columnKernel, _anchor.y, ctype, _delta, bits ); // 利用这两个线性滤波器建立滤波引擎 return Ptr&lt;FilterEngine&gt;( new FilterEngine(Ptr&lt;BaseFilter&gt;(), _rowFilter, _columnFilter,_srcType, _dstType, _bufType, _rowBorderType, _columnBorderType, _borderValue ));&#125;/** 建立滤波引擎函数*/FilterEngine::FilterEngine( const Ptr&lt;BaseFilter&gt;&amp; _filter2D, const Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter, const Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter, int _srcType, int _dstType, int _bufType, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; init(_filter2D, _rowFilter, _columnFilter, _srcType, _dstType, _bufType, _rowBorderType, _columnBorderType, _borderValue);&#125;void FilterEngine::init( const Ptr&lt;BaseFilter&gt;&amp; _filter2D, const Ptr&lt;BaseRowFilter&gt;&amp; _rowFilter, const Ptr&lt;BaseColumnFilter&gt;&amp; _columnFilter, int _srcType, int _dstType, int _bufType, int _rowBorderType, int _columnBorderType, const Scalar&amp; _borderValue )&#123; // 依旧是获取类型 _srcType = CV_MAT_TYPE(_srcType); _bufType = CV_MAT_TYPE(_bufType); _dstType = CV_MAT_TYPE(_dstType); // 临时变量 srcType = _srcType; // 计算单个像素大小 // 下面会降解 int srcElemSize = (int)getElemSize(srcType); // 下面这些全是建立临时变量的 dstType = _dstType; bufType = _bufType; filter2D = _filter2D; rowFilter = _rowFilter; columnFilter = _columnFilter; // 这里是判断行列边缘类型是否出问题 if( _columnBorderType &lt; 0 ) _columnBorderType = _rowBorderType; rowBorderType = _rowBorderType; columnBorderType = _columnBorderType; // 检测边界填充类型是否不是wrap(复制元素填充)类型 CV_Assert( columnBorderType != BORDER_WRAP ); // 检测是否为可分离滤波器(因为这个是通用滤波引擎 并不知道是否为可分离滤波器) if( isSeparable() ) &#123; // 检测横纵滤波器类型是否相等 CV_Assert( rowFilter &amp;&amp; columnFilter ); // 并以横纵滤波器定义内核大小 ksize = Size(rowFilter-&gt;ksize, columnFilter-&gt;ksize); // 锚点也根据滤波器锚点定义 anchor = Point(rowFilter-&gt;anchor, columnFilter-&gt;anchor); &#125; else &#123; // 如果不是 检测缓冲图像类型是否与输入图像类型相等 CV_Assert( bufType == srcType ); // 这里跟上面定义差不多，不过是非分离滤波器所以是只有一个(filter2D二维滤波器) ksize = filter2D-&gt;ksize; anchor = filter2D-&gt;anchor; &#125; // 这个一看就懂了 CV_Assert( m 0 &lt;= anchor.x &amp;&amp; anchor.x &lt; ksize.width &amp;&amp; 0 &lt;= anchor.y &amp;&amp; anchor.y &lt; ksize.height ); // 根据边缘填充类型进行像素计算 borderElemSize = srcElemSize/(CV_MAT_DEPTH(srcType) &gt;= CV_32S ? sizeof(int) : 1); // 这里也很好懂 int borderLength = std::max(ksize.width - 1, 1); // 重定义边缘向量大小(这里是所占空间大小) borderTab.resize(borderLength*borderElemSize); // 初始化 maxWidth = bufStep = 0; constBorderRow.clear(); // 如果行列边界是常数填充的 if( rowBorderType == BORDER_CONSTANT || columnBorderType == BORDER_CONSTANT ) &#123; // 则计算图像边长 constBorderValue.resize(srcElemSize*borderLength); int srcType1 = CV_MAKETYPE(CV_MAT_DEPTH(srcType), MIN(CV_MAT_CN(srcType), 4)); // 根据位深度将边界像素值转换成可直接使用的vector变量 scalarToRawData(_borderValue, &amp;constBorderValue[0], srcType1, borderLength*CV_MAT_CN(srcType)); &#125; // 初始化size wholeSize = Size(-1,-1);&#125; 我们这时候来看上面提到的getElemSize: 最终这个其实是个宏定义，返回的就是这个宏定义计算的结果： (CV_MAT_CN(type) &lt;&lt; ((((sizeof(size_t)/4+1)*16384|0x3a50) &gt;&gt; CV_MAT_DEPTH(type)*2) &amp; 3)) 首先，针对0x3a50这个奇怪的数值，我们先转换为2进制查看规律，通过查找比对，发现其数值与变量类型有着一一对应的关系，然后16384则是1 &lt;&lt; 14的结果(刚好每个对应两位二进制数值)，这个换成二进制则是 ​ 16384 = 10 00 00 00 00 00 00 ​ 0x3a50 = 11 10 10 01 01 00 00 1 稍微先理解一下，在下先说一下剩下的函数然后一起解析。 这里先计算无符号整型的长度(在64位系统下是4 desu)然后除以4 再加上1 ， 就是说这是2 * 16384 | 0x3a50 就是 01 00 00 00 00 00 00 00 00 11 10 10 01 01 00 00 01 11 10 10 01 01 00 00 的结果右移2 * 深度，观察上面便会发现最终右移之后便使得最后两位二进制数对应的刚好便是对应变量类型所占的二进制数。 这样，在跟3(二进制为11)进行 ‘与‘ 操作，便能得到各个变量的对应所占字节数的对数了。 又因为这里是 通道数 * 2 ^ (所占字节对数) 所以这样就能够计算的出单个像素点所占用的大小(size)了 因为滤波引擎是一个通用引擎，还可用以驱动其他的滤波器(中值滤波或者其他什么的)所以主要的就只不过是根据一些信息初始化用以后面的操作(就是init函数的意思)。 返回了滤波引擎之后便是调用了，这个是apply函数: 123456789101112131415void FilterEngine::apply(const Mat&amp; src, Mat&amp; dst, const Size &amp; wsz, const Point &amp; ofs)&#123; CV_INSTRUMENT_REGION() CV_Assert( src.type() == srcType &amp;&amp; dst.type() == dstType ); // 返回变化y值 int y = start(src, wsz, ofs); // 传参的时候切除第一行与最后一列 proceed(src.ptr() + y*src.step, (int)src.step, endY - startY, dst.ptr(), (int)dst.step );&#125; 其中start便是开始函数后面的proceed则是持续卷积到整个图像的关键，start函数最终返回了起始的Y值，一句一句写太累了，我就不解释了，只贴出start与proceed函数： *这两块其实在下分析的很差，很多函数都没看懂，有很大可能错误，建议先跳过，在下以后c++学透了还会回来改的。 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225/** 滤波引擎 发动！*/int FilterEngine::start(const Mat&amp; src, const Size &amp;wsz, const Point &amp;ofs)&#123; start( wsz, src.size(), ofs); return startY - ofs.y;&#125;int FilterEngine::start(const Size &amp;_wholeSize, const Size &amp;sz, const Point &amp;ofs)&#123; int i, j; wholeSize = _wholeSize; // 根据偏移量与矩阵头设置范围 roi = Rect(ofs, sz); // 依旧是错误检测，很好懂 CV_Assert( roi.x &gt;= 0 &amp;&amp; roi.y &gt;= 0 &amp;&amp; roi.width &gt;= 0 &amp;&amp; roi.height &gt;= 0 &amp;&amp; roi.x + roi.width &lt;= wholeSize.width &amp;&amp; roi.y + roi.height &lt;= wholeSize.height ); // 下面这些依旧是初始化 int esz = (int)getElemSize(srcType); int bufElemSize = (int)getElemSize(bufType); // 定值检查 const uchar* constVal = !constBorderValue.empty() ? &amp;constBorderValue[0] : 0; int _maxBufRows = std::max(ksize.height + 3, std::max(anchor.y, ksize.height-anchor.y-1)*2+1); if( maxWidth &lt; roi.width || _maxBufRows != (int)rows.size() ) &#123; rows.resize(_maxBufRows); maxWidth = std::max(maxWidth, roi.width); int cn = CV_MAT_CN(srcType); srcRow.resize(esz*(maxWidth + ksize.width - 1)); if( columnBorderType == BORDER_CONSTANT ) &#123; constBorderRow.resize(getElemSize(bufType) *(maxWidth + ksize.width - 1 + VEC_ALIGN)); uchar *dst = alignPtr(&amp;constBorderRow[0], VEC_ALIGN), *tdst; int n = (int)constBorderValue.size(), N; N = (maxWidth + ksize.width - 1)*esz; tdst = isSeparable() ? &amp;srcRow[0] : dst; for( i = 0; i &lt; N; i += n ) &#123; n = std::min( n, N - i ); for(j = 0; j &lt; n; j++) tdst[i+j] = constVal[j]; &#125; if( isSeparable() ) (*rowFilter)(&amp;srcRow[0], dst, maxWidth, cn); &#125; int maxBufStep = bufElemSize*(int)alignSize(maxWidth + (!isSeparable() ? ksize.width - 1 : 0),VEC_ALIGN); ringBuf.resize(maxBufStep*rows.size()+VEC_ALIGN); &#125; // 调整bufstep，使环形缓冲区的已使用部分在内存中保持紧凑 bufStep = bufElemSize*(int)alignSize(roi.width + (!isSeparable() ? ksize.width - 1 : 0),16); // dx1是检测锚点位置是否与范围边界检测 dx1 = std::max(anchor.x - roi.x, 0); // 检测内核是否存在偏差 dx2 = std::max(ksize.width - anchor.x - 1 + roi.x + roi.width - wholeSize.width, 0); // 如果存在偏差则重新计算边界表 if( dx1 &gt; 0 || dx2 &gt; 0 ) &#123; if( rowBorderType == BORDER_CONSTANT ) &#123; int nr = isSeparable() ? 1 : (int)rows.size(); for( i = 0; i &lt; nr; i++ ) &#123; uchar* dst = isSeparable() ? &amp;srcRow[0] : alignPtr(&amp;ringBuf[0],VEC_ALIGN) + bufStep*i; // 在内存中用后者填充前者，最后一个参数是大小 memcpy( dst, constVal, dx1*esz ); memcpy( dst + (roi.width + ksize.width - 1 - dx2)*esz, constVal, dx2*esz ); &#125; &#125; else &#123; int xofs1 = std::min(roi.x, anchor.x) - roi.x; int btab_esz = borderElemSize, wholeWidth = wholeSize.width; int* btab = (int*)&amp;borderTab[0]; for( i = 0; i &lt; dx1; i++ ) &#123; int p0 = (borderInterpolate(i-dx1, wholeWidth, rowBorderType) + xofs1)*btab_esz; for( j = 0; j &lt; btab_esz; j++ ) btab[i*btab_esz + j] = p0 + j; &#125; for( i = 0; i &lt; dx2; i++ ) &#123; int p0 = (borderInterpolate(wholeWidth + i, wholeWidth, rowBorderType) + xofs1)*btab_esz; for( j = 0; j &lt; btab_esz; j++ ) btab[(i + dx1)*btab_esz + j] = p0 + j; &#125; &#125; &#125; rowCount = dstY = 0; /** 这整个函数其实最重要的就是这个 上面这些都是防止错误进行的调整 并用以计算下面这个值的 这个startY是另一方向的偏离值，就是说一个像素到另一个像素的偏离量 */ startY = startY0 = std::max(roi.y - anchor.y, 0); endY = std::min(roi.y + roi.height + ksize.height - anchor.y - 1, wholeSize.height); if( columnFilter ) columnFilter-&gt;reset(); if( filter2D ) filter2D-&gt;reset(); return startY;&#125;int FilterEngine::proceed( const uchar* src, int srcstep, int count, uchar* dst, int dststep )&#123; CV_Assert( wholeSize.width &gt; 0 &amp;&amp; wholeSize.height &gt; 0 ); const int *btab = &amp;borderTab[0]; int esz = (int)getElemSize(srcType), btab_esz = borderElemSize; uchar** brows = &amp;rows[0]; int bufRows = (int)rows.size(); int cn = CV_MAT_CN(bufType); int width = roi.width, kwidth = ksize.width; int kheight = ksize.height, ay = anchor.y; int _dx1 = dx1, _dx2 = dx2; int width1 = roi.width + kwidth - 1; int xofs1 = std::min(roi.x, anchor.x); bool isSep = isSeparable(); bool makeBorder = (_dx1 &gt; 0 || _dx2 &gt; 0) &amp;&amp; rowBorderType != BORDER_CONSTANT; int dy = 0, i = 0; src -= xofs1*esz; count = std::min(count, remainingInputRows()); CV_Assert( src &amp;&amp; dst &amp;&amp; count &gt; 0 ); /** 这里就是卷积的主函数了 */ for(;; dst += dststep*i, dy += i) &#123; int dcount = bufRows - ay - startY - rowCount + roi.y; dcount = dcount &gt; 0 ? dcount : bufRows - kheight + 1; dcount = std::min(dcount, count); count -= dcount; for( ; dcount-- &gt; 0; src += srcstep ) &#123; int bi = (startY - startY0 + rowCount) % bufRows; uchar* brow = alignPtr(&amp;ringBuf[0], VEC_ALIGN) + bi*bufStep; uchar* row = isSep ? &amp;srcRow[0] : brow; if( ++rowCount &gt; bufRows ) &#123; --rowCount; ++startY; &#125; memcpy( row + _dx1*esz, src, (width1 - _dx2 - _dx1)*esz ); if( makeBorder ) &#123; if( btab_esz*(int)sizeof(int) == esz ) &#123; const int* isrc = (const int*)src; int* irow = (int*)row; for( i = 0; i &lt; _dx1*btab_esz; i++ ) irow[i] = isrc[btab[i]]; for( i = 0; i &lt; _dx2*btab_esz; i++ ) irow[i + (width1 - _dx2)*btab_esz] = isrc[btab[i+_dx1*btab_esz]]; &#125; else &#123; for( i = 0; i &lt; _dx1*esz; i++ ) row[i] = src[btab[i]]; for( i = 0; i &lt; _dx2*esz; i++ ) row[i + (width1 - _dx2)*esz] = src[btab[i+_dx1*esz]]; &#125; &#125; if( isSep ) (*rowFilter)(row, brow, width, CV_MAT_CN(srcType)); &#125; int max_i = std::min(bufRows, roi.height - (dstY + dy) + (kheight - 1)); for( i = 0; i &lt; max_i; i++ ) &#123; int srcY = borderInterpolate(dstY + dy + i + roi.y - ay, wholeSize.height, columnBorderType); if( srcY &lt; 0 ) // can happen only with constant border type brows[i] = alignPtr(&amp;constBorderRow[0], VEC_ALIGN); else &#123; CV_Assert( srcY &gt;= startY ); if( srcY &gt;= startY + rowCount ) break; int bi = (srcY - startY0) % bufRows; brows[i] = alignPtr(&amp;ringBuf[0], VEC_ALIGN) + bi*bufStep; &#125; &#125; if( i &lt; kheight ) break; i -= kheight - 1; if( isSeparable() ) (*columnFilter)((const uchar**)brows, dst, dststep, i, roi.width*cn); else (*filter2D)((const uchar**)brows, dst, dststep, i, roi.width, cn); &#125; dstY += dy; CV_Assert( dstY &lt;= roi.height ); return dy;&#125; 总结 C++语法复杂度感觉世界上排的了前十 复杂但却也是少有的可以直接操作内存的语言之一，内联汇编效率不要太高 用轮子很简单，但是造轮子很难，造出普适性的轮子更难，自己用感觉有些算法还是很容易写的，但是要照顾到大量的其他语法或者平台那就很困难了 优化不一定是自己算法的优化，还有使用平台的优化，用别人的轮子真的很爽 大型项目里面代码风格各异，变量命名方案比较混乱，并且简写的比较多，看起来真的头大。。。。 在下的代码逻辑思维还是太低了，希望能够在毕业的时候看上20000行代码用以提升自己 相比之下python源码看起来真的舒服死了55555 借物表 attribute 机制详解(一) What is this #ifdef GNUC about? 关于VC预定义常量_WIN32，WIN32，_WIN64等预定义宏的介绍（整理、转载） opencv的CV_EXPORT 图像处理基础(4)：高斯滤波器详解 C/C++ 可变参数宏与VA_ARGS 宏 #、##、VA_ARGS和##VA_ARGS的作用 OpenVX嵌入式图像处理（一）硬件平台及软件介绍 OpenCV3.x中UMat对象介绍与使用 opencv学习之GaussianBlur()源码解析 手撕OpenCV源码之GaussianBlur OpenCV的一些宏 感谢以上各位大佬给在下提供的各类知识","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"cv","slug":"cv","permalink":"http://blog.fivezha.cn/tags/cv/"},{"name":"c++","slug":"c","permalink":"http://blog.fivezha.cn/tags/c/"}]},{"title":"nazo.io攻略(完)","date":"2018-10-15T11:22:26.000Z","path":"2018/10/15/nazo-io-answer/","text":"有点像小学玩过的某个解密游戏的游戏 偶然又发现了这种类型的游戏 鄙人玩了2个小时 写了点攻略 希望能够帮到你 顺便附上网址(其实就是nazo.io)1.欢迎 1 直接输入:welcome即可 2.规则 2 点击：key即可出现答案——gotcha 3.从右往左念 3 顾名思义，从右往左念：key is where 答案便是：where 4.完形填空 4 这关便是教你使用搜索引擎搜索答案（其实大多数时间搜不到。。。。 百度 答案便是：survival 5.Morse 5 摩尔斯电码，没什么好说的 答案：sos 6.Base64 6 就是base64解码 随便找个网站就行了 解密 答案：1029174037 6.Base64(新) image-20200712000900198 答案：bytealigned 7.OICQ 7 这个标题是qq的前身名称 这里有个提示：你刚输入了什么？/以及联系作者 很清楚 ，上一题的答案就是作者的QQ号 qq搜索 看 果不其然 答案：macintosh 7.RCNB.app(新) image-20200712001003985 编码随便百度一下就出来了 答案：unprintable 8.IDNs 8 这个题也是那种没有知识前提就不会的那种 正巧前两天刚买域名的时候看见了中文域名，所以这题小case😄 直接访问：错的是.世界便可知道答案 直接访问 答案：saionjisekai 9.角度 9 这张图片是斜角图片，就是字都向内偏向了45° 用画图打开拉长一下就知道答案了：pineapple 10.回到上世纪 10 典型的百度搜图题目 答案：mouse 11.Unicode 11 可能部分手机字库支持不全看不了 答案：neweroslesstofu 11.Unicode(新) image-20200712001517859 答案：oopscode 12.1A2B 12 小时候的猜数题目 大意是：有一个未知数需要猜测 下面0A0B代表不仅数字没猜对位置也没猜对 0A2B代表数字猜对了两个但是位置没猜对 3A0B代表着数字跟位置都猜对的有三位有一位数字跟位置都没猜对 答案：9506 13.虚无 13 中间有图片，新窗口打开便可知 新页面打开 答案：thealpha 14.我爱记歌词 14 hint是里的歌词是种子，歌名又是小苹果，图片名字叫apple 不用多说了吧 ——图种 图种 答案：greendam 15.声音的轨迹 15 音波解析 随便找个能看音波的软件就行了 妹子挺好看 答案：koenokiseki 16.虚掩 16 打开隐藏图片之后发现是多层结构 直接将遮罩层大小改为0 key显现 key 密码：secretvg 17.虚空 17 空格切换 这里的字符由全角跟半角的空格组成 替换任意一种便可知道答案 答案 答案：entropy 18.Twitter科学上网 18 打开发现居然作者是位打ctf的大佬 作者推特 答案：th4nky0u 18.Twitter(新)访问一下url就可以知道了 image-20200712001718333 答案：shortweet 19.最后感谢语 hit3 我是20位通关的(正儿八经的第20位 ←.hit1)，你呢？ 20.强迫症与总结(↑.hit2) 花了我2个多小时的游戏终于完美落下了帷幕 期初我只是想分享一下在群里，没想到大家兴致如此之高，以至于最后都为找到一个个key而兴致高涨😄 这种游戏果然需要跟大家一起玩才有意思嘛 总之，游戏体验良好，5⭐️ 好评！","categories":[{"name":"games","slug":"games","permalink":"http://blog.fivezha.cn/categories/games/"}],"tags":[{"name":"game","slug":"game","permalink":"http://blog.fivezha.cn/tags/game/"}]},{"title":"git超简单教程","date":"2018-04-20T12:34:09.000Z","path":"2018/04/20/git-guide/","text":"git的超简单用法（以test-repository为例） 初始化1.初始化git的email与name首先先打开git(这个随便在哪个文件夹都可以) 12$ git config --global user.name \"这里写你的名字\"$ git config --global user.email \"这里写你的邮箱\" 2.设置ssh连接PS：这一步主要是防止他人盗用你的github账号所设置的双重保护，仅是为了安全，不设置这步也可运行 1$ ssh-keygen -t rsa -C \"这里是你的邮箱\" 然后你能在你c://用户//13256(这里是你的用户名)//.ssh里面找到以下三个文件 文件列表 然后登陆github网站 在setting里面找到ssh设置 然后新建ssh填入你id_rsa.pub里面的东西就ok了(title随便填) setting add key 然后点add key就完事儿了 连接仓库1.获取项目URL首先找到你想要clone（类似下载）到本地的项目页面按照箭头复制项目地址 enter image description here 2.在本地clone项目首先找到你想要在本地硬盘clone（下载）的地址 右键点击Git Bash Here enter image description here 然后输入以下指令（就只有第一行） git clone 你刚刚复制的网址 enter image description here 完成后关闭这个命令提示框！完成后关闭这个命令提示框！完成后关闭这个命令提示框！Then你就会发现在目录下有一个你clone的仓库的名字的文件夹了（如下图） enter image description here 3.进入clone后的仓库（文件夹）进行修改和push进入刚刚clone的那个文件夹，此时你可以随意修改文件内容 增加内容 修改完成后，在clone的文件夹里 右键然后点击Git Bash Here 然后输入下面三行指令 git add .git commit -m ‘随便上传点东西’git push origin master（主分支一般为master,如果你没别的分支就写master）注：第二行 ‘ ‘ 里面的东西随便写 这里主要写你push的东西主要修改了什么（会在项目上显示）push时可能会让你输入邮箱密码 填上就行 enter image description here 在项目中显示的修改信息 enter image description here 4.更新自己修改后的文件如果你后来修改了文件想要同步到github上面去的话，那么: 重复步骤 3中的 三个指令便可以了5. 分支开发这个有点大就直接放地址了菜鸟教程的教程 简单介绍的 还有廖雪峰老师的教程 ！推荐！讲的很详细！","categories":[{"name":"study","slug":"study","permalink":"http://blog.fivezha.cn/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.fivezha.cn/tags/git/"}]}]